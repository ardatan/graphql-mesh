// @generated by protobuf-ts 2.4.0 with parameter generate_dependencies,long_type_string,server_grpc1,// @generated from protobuf file "authors/v1/authors_service.proto" (package "authors.v1", syntax proto3),// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MESSAGE_TYPE } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
/**
 * @generated from protobuf message authors.v1.ListAuthorsRequest
 */
export interface ListAuthorsRequest {}
/**
 * @generated from protobuf message authors.v1.GetAuthorRequest
 */
export interface GetAuthorRequest {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
}
/**
 * @generated from protobuf message authors.v1.ListAuthorsResponse
 */
export interface ListAuthorsResponse {
  /**
   * @generated from protobuf field: repeated authors.v1.Author items = 1;
   */
  items: Author[];
}
/**
 * @generated from protobuf message authors.v1.Author
 */
export interface Author {
  /**
   * @generated from protobuf field: string id = 1;
   */
  id: string;
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: string editor = 3;
   */
  editor: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ListAuthorsRequest$Type extends MessageType<ListAuthorsRequest> {
  constructor() {
    super('authors.v1.ListAuthorsRequest', []);
  }
  create(value?: PartialMessage<ListAuthorsRequest>): ListAuthorsRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<ListAuthorsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListAuthorsRequest
  ): ListAuthorsRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(message: ListAuthorsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message authors.v1.ListAuthorsRequest
 */
export const ListAuthorsRequest = new ListAuthorsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAuthorRequest$Type extends MessageType<GetAuthorRequest> {
  constructor() {
    super('authors.v1.GetAuthorRequest', [{ no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }]);
  }
  create(value?: PartialMessage<GetAuthorRequest>): GetAuthorRequest {
    const message = { id: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<GetAuthorRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetAuthorRequest
  ): GetAuthorRequest {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: GetAuthorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message authors.v1.GetAuthorRequest
 */
export const GetAuthorRequest = new GetAuthorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListAuthorsResponse$Type extends MessageType<ListAuthorsResponse> {
  constructor() {
    super('authors.v1.ListAuthorsResponse', [
      { no: 1, name: 'items', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Author },
    ]);
  }
  create(value?: PartialMessage<ListAuthorsResponse>): ListAuthorsResponse {
    const message = { items: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<ListAuthorsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ListAuthorsResponse
  ): ListAuthorsResponse {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated authors.v1.Author items */ 1:
          message.items.push(Author.internalBinaryRead(reader, reader.uint32(), options));
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: ListAuthorsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* repeated authors.v1.Author items = 1; */
    for (let i = 0; i < message.items.length; i++)
      Author.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message authors.v1.ListAuthorsResponse
 */
export const ListAuthorsResponse = new ListAuthorsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Author$Type extends MessageType<Author> {
  constructor() {
    super('authors.v1.Author', [
      { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: 'editor', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<Author>): Author {
    const message = { id: '', name: '', editor: '' };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
    if (value !== undefined) reflectionMergePartial<Author>(this, message, value);
    return message;
  }
  internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Author): Author {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string id */ 1:
          message.id = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string editor */ 3:
          message.editor = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
          let d = reader.skip(wireType);
          if (u !== false) (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
      }
    }
    return message;
  }
  internalBinaryWrite(message: Author, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
    /* string id = 1; */
    if (message.id !== '') writer.tag(1, WireType.LengthDelimited).string(message.id);
    /* string name = 2; */
    if (message.name !== '') writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string editor = 3; */
    if (message.editor !== '') writer.tag(3, WireType.LengthDelimited).string(message.editor);
    let u = options.writeUnknownFields;
    if (u !== false) (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message authors.v1.Author
 */
export const Author = new Author$Type();
/**
 * @generated ServiceType for protobuf service authors.v1.AuthorsService
 */
export const AuthorsService = new ServiceType('authors.v1.AuthorsService', [
  { name: 'GetAuthor', options: {}, I: GetAuthorRequest, O: Author },
  { name: 'ListAuthors', options: {}, I: ListAuthorsRequest, O: ListAuthorsResponse },
]);
