---
description: GraphQL Mesh Serve Runtime allows you to serve your unified GraphQL schema
---

import { Callout } from '@theguild/components'

# Serve Introduction

GraphQL Mesh's Serve Runtime allows you to serve your unified GraphQL schema in any environment that
runs JavaScript such as Node.js, Bun, Deno, Google Cloud Functions, Azure Functions, Cloudflare
Workers, and more.

This unified graph can be composed by using [GraphQL Mesh Compose](/v1/compose) or **Federation
Supergraph**.

GraphQL Mesh can also act as a proxy so you can enhance an existing GraphQL API with features like
[monitoring/tracing](/v1/serve/features/monitoring-tracing)
[caching](/v1/serve/features/performance), [rate limiting](/v1/serve/features/security/rate-limit),
[some security layers](/v1/serve/features/security) and more.

It can be fetched from either a local file, a remote URL, or a schema registry such as
[GraphQL Hive](https://the-guild.dev/graphql/hive) or
[Apollo GraphOS](https://www.apollographql.com/docs/graphos/).

To summarize, GraphQL Mesh Serve allows you to:

- Serve your unified graph in any environment that runs JavaScript
- Act as an HTTP proxy to enhance an existing GraphQL API
- Adds an extra layer of security, performance, and monitoring to your API

## Installation of CLI

In order to get started, you need to have [Node.js](https://nodejs.org) installed in your
environment. Then, you can install Serve CLI with your favorite package manager:

```sh npm2yarn
npm i @graphql-mesh/serve-cli
```

## Basic Usage with Unified GraphQL

Let's say you have a composed unified graph generated by [Mesh Compose](/v1/compose) in
`unifiedgraph.graphql` and you want to serve it.

You can easily serve it by using the following command.

```sh
mesh-serve --fusiongraph=unifiedgraph.graphql
```

For Federation Supergraph, you can use the following command.

```sh
mesh-serve --supergraph=supergraph.graphql
```

<Callout>
  See `Configure as a Proxy` section if you just want to proxy an existing GraphQL API.
</Callout>

## CLI Arguments

<Callout>All of those can be passed in the configuration file as well</Callout>

- `--fusiongraph`: Path to the unified graph file in Mesh Compose CLI format
- `--supergraph`: Path to the supergraph file in Federation Supergraph format
- `--port` or `-p`: Port to serve the unified graph (default: 4000)
- `--host` or `-h`: Host to serve the unified graph (default: localhost)
- `--fork`: Count of workers to spawn. defaults to `os.availableParallelism()` when NODE_ENV is
  "production", otherwise only one (the main) worker

## Configuration

If you need to configure the Serve runtime, you need to create or modify the `mesh.config.ts` file
in the root of your project.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  // Configuration here
})
```

### Configure Unified Graph

#### `fusiongraph` or `supergraph`

You can provide `GraphQLSchema`, `DocumentNode` which has the AST of the unified graph or `string`
which is the `SDL` representation of the unified graph.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  fusiongraph: './unified.graphql',
  // or
  supergraph: 'https://example.com/supergraph.graphql',
  // or you can provide a function that returns a promise of the schema
  fusiongraph: () =>
    fetch('https://example.com/unified.graphql', {
      headers: {
        Authorization: 'Bearer token'
      }
    }).then(res => res.text())
})
```

#### `polling`

Let's say you have a source that can be changed after a while, it can be a CDN, schema registry or a
local file. So by enabling this option, Mesh can poll the source and update the schema
automatically.

If a function is provided as in the example above, that function will be called every time the
polling interval is reached.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  polling: 5_000 // Polling interval in milliseconds
})
```

#### `additionalResolvers`

You can provide additional resolvers to the unified graph. This can be useful if you want to add a
custom resolver to the unified graph, or override the existing one.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  additionalResolvers: {
    Query: {
      hello: () => 'Hello World'
    }
  }
})
```

<Callout>
  `TODO: A dedicated page is needed for programmatic version of @resolveTo with Incontext SDK`
</Callout>

#### `transports` (Advanced usage only)

<Callout>
  This is an advanced feature and should be used with caution. Use this only if you know what you
  are doing.
</Callout>

GraphQL Mesh Transports are the key component of the serve runtime's execution in GraphQL Mesh. It
allows the gateway to communicate with the subgraph. For example `@graphql-mesh/transport-rest` is
used to communicate with the REST subgraphs generated by
[OpenAPI](/v1/compose/source-handlers/openapi) and
[JSON Schema](/v1/compose/source-handlers/json-schema) source handlers. And GraphQL subgraphs use
GraphQL HTTP Transport(`@graphql-mesh/transport-http`).

GraphQL Mesh looks up the unified graph, and checks the kind of the subgraph, and loads it by
checking the `@graphql-mesh/transport-{kind}` package, then loads it to create an executor for the
subgraph. You can see how an example `@transport` definition looks like
[here](https://github.com/ardatan/graphql-mesh/blob/master/e2e/auto-type-merging/__snapshots__/auto-type-merging.test.ts.snap#L4).

And see the implementation of the default `transport` loading logic
[here](https://github.com/ardatan/graphql-mesh/blob/master/packages/fusion/runtime/src/utils.ts#L32).

You can replace this logic by providing your own `transports`.

### Configure Mesh as a GraphQL Proxy

#### `proxy`

HTTP executor options to proxy all incoming requests to another HTTP endpoint.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  proxy: {
    endpoint: 'https://example.com/graphql',
  })
});
```

##### `endpoint`

The URL of the GraphQL endpoint to proxy requests to.

##### `headers`

Additional headers to include when querying the original schema It can be a plain object or a
function that returns a plain object.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  proxy: {
    endpoint: 'https://example.com/graphql',
    headers: execReq => ({
      // This will pass the original request headers to the proxied request
      authorization: execReq.context.headers.authorization
    })
  }
})
```

##### `useGETForQueries`

Whether to use the GET HTTP method for queries when querying the original schema. In that case, the
query will be sent as a query string parameter named `query`.

##### `method`

The HTTP method to use when querying the original schema. Default is `POST`.

##### `timeout`

The timeout in milliseconds for the request to the original schema. There is no timeout by default.

##### `retry`

Retry attempts in case of a failure. Default is 0.

##### `credentials`

Request Credentials (default: 'same-origin')
[Learn more](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)

### Configure Server

#### `sslCredentials` for HTTPS

This is the option to provide SSL Credentials for HTTPS Server. If this is provided, Mesh will be
served via HTTPS instead of HTTP.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  sslCredentials: {
    key_file_name: 'path/to/key.pem',
    cert_file_name: 'path/to/cert.pem',
    ca_file_name: 'path/to/ca.pem',
    passphrase: 'passphrase',
    dh_params_file_name: 'path/to/dhparams.pem',
    ssl_ciphers: 'ECDHE-R',
    // This translates to SSL_MODE_RELEASE_BUFFERS
    ssl_prefer_low_memory_usage: false
  }
})
```

#### `browser`

This is the option to open the browser automatically when the server is started.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  /**
   * Path to the browser that will be used by `mesh serve` to open a playground window in development mode
   * This feature can be disabled by passing `false`
   */
  browser: true // or `google-chrome` or `firefox` or `safari` or `edge` or `opera` or `vivaldi` or `brave` or `chromium` or `msedge` or `false`
})
```

#### `port` and `host`

These are the options to configure the port and host of the server in the configuration file rather
than passing them as CLI arguments.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  port: 4000,
  host: 'localhost'
})
```

#### `plugins`

This is the option to extend your Mesh Gateway with plugins. GraphQL Mesh uses
[GraphQL Yoga](https://the-guild.dev/graphql/yoga-server/docs/features/envelop-plugins), and it uses
[Envelop](https://the-guild.dev/graphql/envelop) plugin system which allows you to hook into the
different phases of the GraphQL execution to manipulate or track the entire workflow step-by-step.

[See dedicated plugins feature page for more information](/v1/serve/features/custom-plugins)

#### `cors`

[See dedicated CORS feature page for more information](/v1/serve/features/security/cors)

#### `graphiql`

You can configure GraphiQL playground that allows you to play with your GraphQL API.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  graphiql: {
    defaultQuery: 'query { hello }'
  }
})
```

[Learn more about available GraphiQL Options from the dedicated GraphQL Yoga page](https://the-guild.dev/graphql/yoga-server/docs/features/graphiql)

`TODO: Move those into a dedicated GraphiQL page under Features`

#### `landingPage`

If you want to disable the landing page, you can set this option to `false`.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  landingPage: false
})
```

#### `batching`

[See dedicated page](/v1/serve/features/performance/request-batching)

#### `fetchAPI` (Advanced usage only)

<Callout>
  This is an advanced feature and should be used with caution. Use this only if you know what you
  are doing. Use it on your own risk.
</Callout>

GraphQL Mesh heavily relies on WHATWG Fetch API not only as a HTTP Client but also for handling HTTP
Server components. So it uses [`@whatwg-node/fetch`](https://github.com/ardatan/whatwg-node) by
default which is a platform agnostic implementation of the Fetch API. If you want to use a different
Fetch API implementation, you can provide it here.

```ts filename="mesh.config.ts"
import fetch from 'node-fetch'
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  fetchAPI: {
    fetch
  }
})
```

#### `logger`

By default, Mesh uses a simple logger that logs to the console by using standard `console` methods.

Using this option, you can do;

- Disable logging by providing `false`
- Provide your own logger instance
- Choose a log level

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'
import { createLogger } from 'some-logger-library'

export const serveConfig = defineServeConfig({
  logger: createLogger()
  // or
  logger: 'info' // or 'debug' or 'warn' or 'error'
  // or
  logger: false
})
```

`TODO: Move those into a dedicated Logging page under Features`
[GraphQL Mesh uses the same logging mechanism of GraphQL Yoga](https://the-guild.dev/graphql/yoga-server/docs/features/logging-and-debugging)

#### `graphqlEndpoint`

This is the option to provide a custom GraphQL endpoint for the server. By default, it is
`/graphql`.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  graphqlEndpoint: '/my-graphql-endpoint'
})
```

#### `maskedErrors`

This is enabled by default for security reasons.

[Learn more about Error Masking](/v1/serve/features/security/error-masking)

#### `cache`

Provide a cache storage for the server. By default, Mesh uses an in-memory cache.

[Learn more about Caching](/v1/serve/features/performance)

#### `pubsub`

Provide a PubSub instance for the server. By default, Mesh uses an in-memory PubSub. In order to
have a better scalability, you can provide a custom PubSub.

[Learn more about Subscriptions and Webhooks to see if you need this option](/v1/serve/features/subscriptions-webhooks)

#### `healthCheckEndpoint` and `readinessCheckEndpoint`

[Learn more about Health Check and Readiness Check](/v1/serve/features/health-check)
