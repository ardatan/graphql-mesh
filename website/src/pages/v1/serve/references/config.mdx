---
description: Mesh Serve Configuration Reference
---

import { Callout } from '@theguild/components'

## Configuration Reference

<Callout>
  This page is currently under construction and expected to change. Please feel free to reach out to
  us directly in case you are having any troubles.
</Callout>

An overview of all the configuration options for the `mesh.config.ts` used by the `mesh-serve` CLI.

Both TypeScript (`*.ts`) and JavaScript (`*.js`) config filetypes are supported.

## Default config files

The following list of files are loaded by default, sorted by priority:

- `mesh.config.ts` _(recommended)_
- `mesh.config.mts`
- `mesh.config.cts`
- `mesh.config.js`
- `mesh.config.mjs`
- `mesh.config.cjs`

### Supergraph Related

#### `supergraph`

You can provide `GraphQLSchema`, `DocumentNode` which has the AST of the supergraph or `string`
which is the `SDL` representation of the supergraph.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  supergraph: './supergraph.graphql',
  // or
  supergraph: 'https://example.com/supergraph.graphql',
  // or you can provide a function that returns a promise of the schema
  supergraph: () =>
    fetch('https://example.com/unified.graphql', {
      headers: {
        Authorization: 'Bearer token'
      }
    }).then(res => res.text())
})
```

<Callout>

For GraphQL Hive and Apollo GraphOS, you probably don't need to provide the `supergraph` option.

- If you use GraphQL Hive, please refer to the dedicated section for
  [Fetching Supergraph from Hive CDN](/v1/serve/schema-registry/hive#publishing-subgraphs-to-hive-cdn)
- If you use Apollo GraphOS, please refer to the dedicated section for
  [Fetching Supergraph from Apollo GraphOS](/v1/serve/schema-registry/apollo-graphos).

</Callout>

#### `polling`

Let's say you have a source that can be changed after a while, it can be a CDN, schema registry or a
local file. So by enabling this option, Mesh can poll the source and update the schema
automatically.

If a function is provided as in the example above, that function will be called every time the
polling interval is reached.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  polling: 5_000 // Polling interval in milliseconds
})
```

#### `additionalResolvers`

You can provide additional resolvers to the supergraph. This can be useful if you want to add a
custom resolver to the supergraph, or override the existing one.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  additionalResolvers: {
    Query: {
      hello: () => 'Hello World'
    }
  }
})
```

#### `transports` (Advanced usage only)

<Callout>
  This is an advanced feature and should be used with caution. Use this only if you know what you
  are doing.
</Callout>

GraphQL Mesh Transports are the key component of the serve runtime's execution in GraphQL Mesh. It
allows the gateway to communicate with the subgraph. For example `@graphql-mesh/transport-rest` is
used to communicate with the REST subgraphs generated by
[OpenAPI](/v1/compose/source-handlers/openapi) and
[JSON Schema](/v1/compose/source-handlers/json-schema) source handlers. And GraphQL subgraphs use
GraphQL HTTP Transport(`@graphql-mesh/transport-http`).

GraphQL Mesh looks up the supergraph, and checks the kind of the subgraph, and loads it by checking
the `@graphql-mesh/transport-{kind}` package, then loads it to create an executor for the subgraph.
You can see how an example `@transport` definition looks like
[here](https://github.com/ardatan/graphql-mesh/blob/master/e2e/auto-type-merging/__snapshots__/auto-type-merging.test.ts.snap#L4).

And see the implementation of the default `transport` loading logic
[here](https://github.com/ardatan/graphql-mesh/blob/master/packages/fusion/runtime/src/utils.ts#L32).

You can replace this logic by providing your own `transports`.

### Subgraphs

If you want to serve a single subgraph, you can provide the subgraph configuration as well. You can
generate subgraphs by using [Mesh Compose](/v1/compose) or any other Federation compliant tool
listed
[here](https://www.apollographql.com/docs/federation/building-supergraphs/supported-subgraphs/).

#### `subgraph`

You can provide `GraphQLSchema`, `DocumentNode` which has the AST of the subgraph or `string` which
is the `SDL` representation of the subgraph

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  subgraph: './subgraph.graphql',
  // or
  subgraph: 'https://example.com/subgraph.graphql',
  // or you can provide a function that returns a promise of the schema
  subgraph: () =>
    fetch('https://example.com/subgraph.graphql', {
      headers: {
        Authorization: 'Bearer token'
      }
    }).then(res => res.text())
})
```

<Callout>
  The rest of the configuration options are the same as the supergraph configuration.
</Callout>

### Configure Mesh as a GraphQL Proxy

#### `proxy`

HTTP executor options to proxy all incoming requests to another HTTP endpoint.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  proxy: {
    endpoint: 'https://example.com/graphql'
  }
})
```

##### `endpoint`

The URL of the GraphQL endpoint to proxy requests to.

##### `headers`

Additional headers to include when querying the original schema It can be a plain object or a
function that returns a plain object.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  proxy: {
    endpoint: 'https://example.com/graphql',
    headers: execReq => ({
      // This will pass the original request headers to the proxied request
      authorization: execReq.context.headers.authorization
    })
  }
})
```

##### `useGETForQueries`

Whether to use the GET HTTP method for queries when querying the original schema. In that case, the
query will be sent as a query string parameter named `query`.

##### `method`

The HTTP method to use when querying the original schema. Default is `POST`.

##### `timeout`

The timeout in milliseconds for the request to the original schema. There is no timeout by default.

##### `retry`

Retry attempts in case of a failure. Default is 0.

##### `credentials`

Request Credentials (default: 'same-origin')
[Learn more](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)

#### `skipValidation`

By default, Mesh validates the operations on the gateway against the introspected schema. This is
recommended to keep it enabled for security reasons. But it brings a performance overhead. If you
want to disable this validation and send the operations directly to the upstream service, you can
set this option to `true`.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  proxy: {
    endpoint: 'https://example.com/graphql'
  },
  skipValidation: true
})
```

### Configure Server

#### `sslCredentials` for HTTPS

This is the option to provide SSL Credentials for HTTPS Server. If this is provided, Mesh will be
served via HTTPS instead of HTTP.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  sslCredentials: {
    key_file_name: 'path/to/key.pem',
    cert_file_name: 'path/to/cert.pem',
    ca_file_name: 'path/to/ca.pem',
    passphrase: 'passphrase',
    dh_params_file_name: 'path/to/dhparams.pem',
    ssl_ciphers: 'ECDHE-R',
    // This translates to SSL_MODE_RELEASE_BUFFERS
    ssl_prefer_low_memory_usage: false
  }
})
```

#### `browser`

This is the option to open the browser automatically when the server is started.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  /**
   * Path to the browser that will be used by `mesh serve` to open a playground window in development mode
   * This feature can be disabled by passing `false`
   */
  browser: true // or `google-chrome` or `firefox` or `safari` or `edge` or `opera` or `vivaldi` or `brave` or `chromium` or `msedge` or `false`
})
```

#### `port` and `host`

These are the options to configure the port and host of the server in the configuration file rather
than passing them as CLI arguments.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  port: 4000,
  host: 'localhost'
})
```

#### `plugins`

This is the option to extend your Mesh Gateway with plugins. GraphQL Mesh uses
[GraphQL Yoga](https://the-guild.dev/graphql/yoga-server/docs/features/envelop-plugins), and
[Envelop](https://the-guild.dev/graphql/envelop) plugin system which allows you to hook into the
different phases of the GraphQL execution to manipulate or track the entire workflow step-by-step.

[See dedicated plugins feature page for more information](/v1/serve/features/custom-plugins)

#### `cors`

[See dedicated CORS feature page for more information](/v1/serve/features/security/cors)

#### `graphiql`

You can configure GraphiQL playground that allows you to play with your GraphQL API.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  graphiql: {
    defaultQuery: 'query { hello }'
  }
})
```

[Learn more about available GraphiQL Options from the dedicated GraphQL Yoga page](https://the-guild.dev/graphql/yoga-server/docs/features/graphiql)

`TODO: Move those into a dedicated GraphiQL page under Features`

#### `landingPage`

If you want to disable the landing page, you can set this option to `false`.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  landingPage: false
})
```

#### `batching`

[See dedicated page](/v1/serve/features/performance/request-batching)

#### `fetchAPI` (Advanced usage only)

<Callout>
  This is an advanced feature and should be used with caution. Use this only if you know what you
  are doing. Use it on your own risk.
</Callout>

GraphQL Mesh heavily relies on WHATWG Fetch API not only as a HTTP Client but also for handling HTTP
Server components. So it uses [`@whatwg-node/fetch`](https://github.com/ardatan/whatwg-node) by
default which is a platform agnostic implementation of the Fetch API. If you want to use a different
Fetch API implementation, you can provide it here.

```ts filename="mesh.config.ts"
import fetch from 'node-fetch'
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  fetchAPI: {
    fetch
  }
})
```

#### `logger`

By default, Mesh uses a simple logger that logs to the console by using standard `console` methods.

Using this option, you can do;

- Disable logging by providing `false`
- Provide your own logger instance
- Choose a log level

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'
import { createLogger } from 'some-logger-library'

export const serveConfig = defineServeConfig({
  logger: createLogger()
  // or
  logger: 'info' // or 'debug' or 'warn' or 'error'
  // or
  logger: false
})
```

`TODO: Move those into a dedicated Logging page under Features`
[GraphQL Mesh uses the same logging mechanism of GraphQL Yoga](https://the-guild.dev/graphql/yoga-server/docs/features/logging-and-debugging)

#### `graphqlEndpoint`

This is the option to provide a custom GraphQL endpoint for the server. By default, it is
`/graphql`.

```ts filename="mesh.config.ts"
import { defineConfig as defineServeConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineServeConfig({
  graphqlEndpoint: '/my-graphql-endpoint'
})
```

#### `maskedErrors`

This is enabled by default for security reasons.

[Learn more about Error Masking](/v1/serve/features/security/error-masking)

#### `cache`

Provide a cache storage for the server. By default, Mesh uses an in-memory cache.

[Learn more about Caching](/v1/serve/features/performance)

#### `pubsub`

Provide a PubSub instance for the server. By default, Mesh uses an in-memory PubSub. In order to
have a better scalability, you can provide a custom PubSub.

[Learn more about Subscriptions and Webhooks to see if you need this option](/v1/serve/features/subscriptions-webhooks)

#### `healthCheckEndpoint` and `readinessCheckEndpoint`

[Learn more about Health Check and Readiness Check](/v1/serve/features/health-check)
