import Image from 'next/image'
import jaegerScreenshot from '@/public/assets/jaeger.png'
import { Callout } from '@theguild/components'

# OpenTelemetry

This plugins integrates [OpenTelemetry](https://opentelemetry.io/) tracing with your GraphQL
execution and lifecycle.

The following features are supported in this plugin:

- HTTP request tracing: tracks the incoming HTTP request and the outgoing HTTP response
- GraphQL Lifecycle tracing: tracks the GraphQL execution lifecycle (parse, validate and execution).
- Upstream HTTP calls: tracks the outgoing HTTP requests made by the GraphQL execution.
- Context propagation: propagates the trace context between the incoming HTTP request and the
  outgoing HTTP requests.

---

<Image src={jaegerScreenshot} loading="eager" placeholder="empty" alt="OpenTelemetry Jaeger UI" />

## Getting Started

```sh npm2yarn
npm i @graphql-mesh/plugin-opentelemetry
```

## Usage Example

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        // A simple output to the console.
        // You can add more exporters here, please see documentation below for more examples.
        createStdoutExporter()
      ],
      serviceName: 'my-custom-service-name', // Optional, the name of your service
      tracer: myCustomTracer, // Optional, a custom tracer to use
      inheritContext: true, // Optional, whether to inherit the context from the incoming request
      propagateContext: true, // Optional, whether to propagate the context to the outgoing requests
      // Optional config to customize the spans. By default all spans are enabled.
      spans: {
        http: true, // Whether to track the HTTP request/response
        graphqlParse: true, // Whether to track the GraphQL parse phase
        graphqlValidate: true, // Whether to track the GraphQL validate phase
        graphqlExecute: true, // Whether to track the GraphQL execute phase
        subgraphExecute: true, // Whether to track the subgraph execution phase
        upstreamFetch: true // Whether to track the upstream HTTP requests
      }
    })
  ]
})
```

## Configuration Options

### Exporters and Integrations

Exporters are responsible for sending the spans to a OpenTelemetry backend. You can use one of the
built-in exporters, or create your own custom exporter.

#### Stdout

A simple exporter that writes the spans to the `stdout` of the process.

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [createStdoutExporter()]
    })
  ]
})
```

#### OTLP over HTTP

An exporter that writes the spans to an OTLP-supported backend.

```ts filename="mesh.config.ts"
import { createOtlpHttpExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        createOtlpHttpExporter({
          url: 'http://my-otlp-backend:4318'
          // ...
          // additional options to pass to @opentelemetry/exporter-trace-otlp-http
          // https://www.npmjs.com/package/@opentelemetry/exporter-trace-otlp-http
        })
      ]
    })
  ]
})
```

#### OTLP over gRPC

```ts filename="mesh.config.ts"
import { createOtlpGrpcExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        createOtlpGrpcExporter({
          url: 'http://my-otlp-backend:4317'
          // ...
          // additional options to pass to @opentelemetry/exporter-trace-otlp-grpc
          // https://www.npmjs.com/package/@opentelemetry/exporter-trace-otlp-grpc
        })
      ]
    })
  ]
})
```

#### Jaeger

[Jaeger](https://www.jaegertracing.io/) supports [OTLP over HTTP/gRPC](#otlp-over-http), so you can
use it by pointing the `createOtlpHttpExporter`/`createOtlpGrpcExporter` to the Jaeger endpoint:

```ts filename="mesh.config.ts"
import { createOtlpHttpExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        // or createOtlpGrpcExporter
        createOtlpHttpExporter({
          url: 'http://my-otlp-backend:4318/v1/traces'
        })
      ]
    })
  ]
})
```

> Your Jaeger instance needs to have OTLP ingestion enabeld, so verify that you have the
> `COLLECTOR_OTLP_ENABLED=true` environment variable set, and that ports `4317` and `4318` are
> acessible.

To test this integration, you can run a local Jaeger instance using Docker:

```
docker run -d --name jaeger \
  -e COLLECTOR_OTLP_ENABLED=true \
  -p 5778:5778 \
  -p 16686:16686 \
  -p 4317:4317 \
  -p 4318:4318 \
  jaegertracing/all-in-one:latest
```

#### NewRelic

[NewRelic](https://newrelic.com/) supports [OTLP over HTTP/gRPC](#otlp-over-http), so you can use it
by configuring the `createOtlpHttpExporter`/`createOtlpGrpcExporter` to the NewRelic endpoint:

```ts filename="mesh.config.ts"
import { createOtlpHttpExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        createOtlpHttpExporter({
          url: 'http://<newrelic-endpoint>:4318'
        })
      ]
    })
  ]
})
```

> For additional information and NewRelic ingestion endpoints, see
> [**New Relic OTLP endpoint**](https://docs.newrelic.com/docs/opentelemetry/best-practices/opentelemetry-otlp/).

#### DataDog

[DataDog Agent](https://docs.datadoghq.com/agent/) supports [OTLP over HTTP/gRPC](#otlp-over-http),
so you can use it by pointing the `createOtlpHttpExporter` to the DataDog Agent endpoint:

```ts filename="mesh.config.ts"
import { createOtlpHttpExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        createOtlpHttpExporter({
          url: 'http://<datadog-agent-host>:4318'
        })
      ]
    })
  ]
})
```

> For additional information, see
> [**OpenTelemetry in Datadog**](https://docs.datadoghq.com/opentelemetry/interoperability/otlp_ingest_in_the_agent/?tab=host#enabling-otlp-ingestion-on-the-datadog-agent).

#### Zipkin

[Zipkin](https://zipkin.io/) is using a custom protocol to send the spans, so you can use the Zipkin
exporter to send the spans to a Zipkin backend:

```ts filename="mesh.config.ts"
import { createZipkinExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        createZipkinExporter({
          url: 'http://<zipkin-host>:9411/api/v2/spans'
          // ...
          // additional options to pass to @opentelemetry/exporter-zipkin
          // https://www.npmjs.com/package/@opentelemetry/exporter-zipkin
        })
      ]
    })
  ]
})
```

#### Batching

All built-in processors allow you to configure batching options by an additional argument to the
factory function.

The following configuration are allowed:

- `true` (default): enables batching and use
  [`BatchSpanProcessor`](https://opentelemetry.io/docs/specs/otel/trace/sdk/#batching-processor)
  default config.
- `object`: enables batching and use
  [`BatchSpanProcessor`](https://opentelemetry.io/docs/specs/otel/trace/sdk/#batching-processor)
  with the provided configuration.
- `false` - disables batching and use
  [`SimpleSpanProcessor`](https://opentelemetry.io/docs/specs/otel/trace/sdk/#simple-processor)

> By default, the batch processor will send the spans every 5 seconds or when the buffer is full.
>
> `{ scheduledDelayMillis: 5000, maxQueueSize: 2048, exportTimeoutMillis: 30000, maxExportBatchSize: 512 }`

> You can learn more about the batching options in the
> [Picking the right span processor](https://opentelemetry.io/docs/languages/js/instrumentation/#picking-the-right-span-processor)
> page.

#### Custom Exporter

You may also create an configure custom exporters and processors. To do so, please refer to
[Customer Exporters in OpenTelemetry documentation](https://opentelemetry.io/docs/languages/js/exporters/#custom-exporters).

### Reported Spans

The plugin exports OpenTelemetry spans for the following operations:

#### HTTP

<Callout>
  This span is created for each incoming HTTP request, and acts as a root span for the entire
  request. Disabling this span will also disable the other hooks and spans.
</Callout>

By default, the plugin will a root span for the HTTP layer as a span (`METHOD /path`) with the
following attributes for the HTTP request:

- `http.method`: The HTTP method
- `http.url`: The HTTP URL
- `http.route`: The HTTP status code
- `http.scheme`: The HTTP scheme
- `http.host`: The HTTP host
- `net.host.name`: The hostname
- `http.user_agent`: The HTTP user agent (based on the `User-Agent` header)
- `http.client_ip`: The HTTP connecting IP (based on the `X-Forwarded-For` header)

And the following attributes for the HTTP response:

- `http.status_code`: The HTTP status code

> An error in the this phase will be reported as an
> [error span](https://opentelemetry.io/docs/specs/semconv/exceptions/exceptions-spans/) with the
> HTTP status text and as an OpenTelemetry
> [`Exception`](https://opentelemetry.io/docs/specs/otel/trace/exceptions/).

You may disable this by setting `spans.http` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        http: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        http: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onRequest` hook](https://github.com/ardatan/whatwg-node/blob/master/packages/server/src/plugins/types.ts#L16-L25).

#### GraphQL Parse

By default, the plugin will report the validation phase as a span (`graphql.validate`) with the
following attributes:

- `graphql.document`: The GraphQL query string
- `graphql.operation.name`: The operation name

> An error in the parse phase will be reported as an
> [error span](https://opentelemetry.io/docs/specs/semconv/exceptions/exceptions-spans/), including
> the error message and as an OpenTelemetry
> [`Exception`](https://opentelemetry.io/docs/specs/otel/trace/exceptions/).

You may disable this by setting `spans.graphqlParse` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlParse: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlParse: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onParse` hook](https://the-guild.dev/graphql/envelop/v4/plugins/lifecycle#before).

#### GraphQL Validate

By default, the plugin will report the validation phase as a span (`graphql.validate`) with the
following attributes:

- `graphql.document`: The GraphQL query string
- `graphql.operation.name`: The operation name

> An error in the validate phase will be reported as an
> [error span](https://opentelemetry.io/docs/specs/semconv/exceptions/exceptions-spans/), including
> the error message and as an OpenTelemetry
> [`Exception`](https://opentelemetry.io/docs/specs/otel/trace/exceptions/).

You may disable this by setting `spans.graphqlValidate` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlValidate: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlValidate: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onValidate` hook](https://the-guild.dev/graphql/envelop/v4/plugins/lifecycle#before-1).

#### GraphQL Execute

By default, the plugin will report the execution phase as a span (`graphql.execute`) with the
following attributes:

- `graphql.document`: The GraphQL query string
- `graphql.operation.name`: The operation name
- `graphql.operation.type`: The operation type (`query`/`mutation`/`subscription`)

> An error in the execute phase will be reported as an
> [error span](https://opentelemetry.io/docs/specs/semconv/exceptions/exceptions-spans/), including
> the error message and as an OpenTelemetry
> [`Exception`](https://opentelemetry.io/docs/specs/otel/trace/exceptions/).

You may disable this by setting `spans.graphqlExecute` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlExecute: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        graphqlExecute: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onExecute` hook](https://the-guild.dev/graphql/envelop/v4/plugins/lifecycle#before-3).

#### Subgraph Execute

By default, the plugin will report the subgraph execution phase as a span (`subgraph.execute`) with
the following attributes:

- `graphql.document`: The GraphQL query string executed to the upstream
- `graphql.operation.name`: The operation name
- `graphql.operation.type`: The operation type (`query`/`mutation`/`subscription`)
- `mesh.upstream.subgraph.name`: The name of the upstream subgraph

In addition, the span will include the following attributes for the HTTP requests;

- `http.method`: The HTTP method
- `http.url`: The HTTP URL
- `http.route`: The HTTP status code
- `http.scheme`: The HTTP scheme
- `net.host.name`: The hostname
- `http.host`: The HTTP host

And the following attributes for the HTTP response:

- `http.status_code`: The HTTP status code

You may disable this by setting `spans.subgraphExecute` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        subgraphExecute: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans.subgraphExecute` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        subgraphExecute: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onSubgraphHook` hook](/v1/serve/features/custom-plugins#onsubgraphexecute).

#### Upstream Fetch

By default, the plugin will report the upstream fetch phase as a span (`http.fetch`) with the
information about outgoing HTTP calls.

The following attributes are included in the span:

- `http.method`: The HTTP method
- `http.url`: The HTTP URL
- `http.route`: The HTTP status code
- `http.scheme`: The HTTP scheme
- `net.host.name`: The hostname
- `http.host`: The HTTP host

And the following attributes for the HTTP response:

- `http.status_code`: The HTTP status code

You may disable this by setting `spans.upstreamFetch` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        upstreamFetch: false
      }
    })
  ]
})
```

Or, you may filter the spans by setting the `spans.upstreamFetch` configuration to a function:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      spans: {
        /* ... */
        upstreamFetch: payload => {
          // Filter the spans based on the payload
          return true
        }
      }
    })
  ]
})
```

> The `payload` object is the same as the one passed to the
> [`onFetch` hook](/v1/serve/features/custom-plugins#onfetch).

### Tracer

You can use this plugin with any kind of OpenTelemetry
[tracer](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#tracer),
and integrate it to any tracing/metric platform that supports this standard.

### OpenTelemetry Context Propagation

By default, the plugin will
[propagate the trace context](https://opentelemetry.io/docs/concepts/context-propagation/) between
the incoming HTTP request and the outgoing HTTP requests.

You may disable this by setting `inheritContext` or `propagateContext` to `false`:

```ts filename="mesh.config.ts"
import { createStdoutExporter, useOpenTelemetry } from '@graphql-mesh/plugin-opentelemetry'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const gatewayConfig = defineConfig({
  plugins: [
    useOpenTelemetry({
      exporters: [
        /* ... */
      ],
      // Controls the propagation of the trace context between the incoming HTTP request and the Mesh gateway
      inheritContext: false,
      // Controls the propagation of the trace context between the Mesh gateway and the upstream HTTP requests
      propagateContext: false
    })
  ]
})
```
