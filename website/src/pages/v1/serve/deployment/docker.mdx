import { Callout } from '@theguild/components'

# Docker

Docker is a tool that allows you to package an application and its dependencies into a container
that can run on any system. This makes it easy to deploy applications in a consistent and
reproducible way, regardless of the underlying infrastructure.

To simplify running GraphQL Mesh, you can use the Docker image and the Docker Compose template we
provide. This setup allows you to easily configure and run the gateway without the need to install
Node.js and the required mesh npm packages.

## Prerequisites

Make sure you have Docker installed on your system.

You can follow [the official Docker Engine install manual](https://docs.docker.com/engine/install/)
in case you don't have Docker installed already.

## Configuration

### Arguments

Mesh Serve can be configured with [CLI arguments](/v1/serve/references/cli#arguments) even when
running the image!

For example, changing the supergraph to use the `my-schema.graphql` schema instead looks like this:

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/my-schema.graphql:/serve/my-schema.graphql" \
  ghcr.io/ardatan/mesh-serve --supergraph=my-schema.graphql
```

For a full list of CLI arguments, please refer to the [CLI arguments](./references/cli#arguments).

### Config File

Instead of configuring Mesh Serve with CLI arguments, we support configuring with a config file.

You're recommended to use the `mesh.config.ts` file to configure Mesh Serve. Simply mount the config
file when running the image.

```ts filename="mesh.config.ts"
import { defineConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineConfig({
  proxy: {
    endpoint: 'https://example.com/graphql'
  }
})
```

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/mesh.config.ts:/serve/mesh.config.ts" \
  ghcr.io/ardatan/mesh-serve
```

For a full list of CLI arguments, please refer to the [Config Reference](./references/config).

### Changing port in container

The default port where Mesh Serve listens is `4000`; however, maybe the container is running inside
a network (like when using [Networking in Compose](https://docs.docker.com/compose/networking/)) and
you wish to change the port of Mesh Serve in the image.

You can use the `mesh.config.ts` to change the port, or simply pass in the `--port` argument when
running the image:

```sh
docker run \
  -p 8080:8080 \
  -v "$(pwd)/supergraph.graphql:/serve/supergraph.graphql" \
  ghcr.io/ardatan/mesh-serve --port=8080
```

## Running

Having a `supergraph.graphql` already composed with [Mesh Compose](/v1/compose), running the Docker
image is as easy as:

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/supergraph.graphql:/serve/mesh.config.ts" \
  ghcr.io/ardatan/mesh-serve
```

## Docker Compose

You may have an environment where you want to use [Docker Compose](https://docs.docker.com/compose/)
and would like to add Mesh Serve there.

Start by defining the `docker-compose.yml`

```yaml
services:
  mesh-serve:
    image: ghcr.io/ardatan/mesh-serve
    ports:
      - '4000:4000'
    # Add GraphQL Hive environment variables in case you use it
    # environment:
    #   HIVE_CDN_ENDPOINT: <secret>
    #   HIVE_CDN_KEY: <secret>
    #   HIVE_REGISTRY_TOKEN: <secret>
    volumes:
      - ./mesh.config.ts:/serve/mesh.config.ts
```

And then simply start the services with:

```sh
docker compose up
```

## Extend Docker Image

For cases where you want to add additional functionality, or plugins to the base image - you just
need to create a new Dockerfile basing the image off `ghcr.io/ardatan/mesh-serve`.

For example, adding [Rate Limiting](/v1/serve/features/security/rate-limiting) to the container
would look like this:

### Install plugin

If you want to only add a plugin (or some other dependencies), you can simply extend the image and
install the modules with `npm i`:

```dockerfile filename="Dockerfile"
FROM ghcr.io/ardatan/mesh-serve

RUN npm i @graphql-mesh/plugin-rate-limit
```

### Develop additional resolvers

However, you may have additional resolvers and have a more sophisticated setup with some
dependencies and source code, copying over your project's files is the way to go.

Say you have the following files:

```json filename="package.json"
{
  "name": "my-time",
  "dependencies": {
    "moment": "^2"
  },
  "devDependencies": {
    "@graphql-mesh/serve-cli": "latest"
  }
}
```

```js filename="my-time.ts"
import moment from 'moment'

export const additionalResolvers = {
  Query: {
    formattedToday() {
      return moment().format('DD.MM.YYYY')
    }
  }
}
```

```ts filename="mesh.config.ts"
import { defineConfig } from '@graphql-mesh/serve-cli'
import { additionalResolvers } from './my-time'

export const serveConfig = defineConfig({ additionalResolvers })
```

Your Dockerfile should then look something like this:

```dockerfile filename="Dockerfile"
FROM ghcr.io/ardatan/mesh-serve

# we dont install dev deps because we need them for types only
COPY package.json .
RUN npm i --omit=dev

COPY my-time.ts .
COPY mesh.config.ts .
```

Then build your image:

```sh
docker build -t mesh-serve-w-add-res .
```

And finally start it (the config file is in the image and doesn't need to be mounted):

```sh
docker run -p 4000:4000 mesh-serve-w-add-res
```
