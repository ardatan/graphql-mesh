import { Callout } from '@theguild/components'

# Docker

Docker is a tool that allows you to package an application and its dependencies into a container
that can run on any system. This makes it easy to deploy applications in a consistent and
reproducible way, regardless of the underlying infrastructure.

To simplify running GraphQL Mesh, you can use the Docker image and the Docker Compose template we
provide. This setup allows you to easily configure and run the gateway without the need to install
Node.js and the required mesh npm packages.

## Prerequisites

Make sure you have Docker installed on your system.

You can follow [the official Docker Engine install manual](https://docs.docker.com/engine/install/)
in case you don't have Docker installed already.

## Configuration

### Arguments

Mesh Serve can be configured with [CLI arguments](/v1/serve/references/cli#arguments) even when
running the image!

For example, changing the supergraph to use the `my-schema.graphql` schema instead looks like this:

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/my-schema.graphql:/serve/my-schema.graphql" \
  ghcr.io/ardatan/mesh-serve --supergraph=my-schema.graphql
```

For a full list of CLI arguments, please refer to the [CLI arguments](./references/cli#arguments).

### Config File

Instead of configuring Mesh Serve with CLI arguments, we support configuring with a config file.

You're recommended to use the `mesh.config.ts` file to configure Mesh Serve. Simply mount the config
file when running the image.

```ts filename="mesh.config.ts"
import { defineConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineConfig({
  proxy: {
    endpoint: 'https://example.com/graphql'
  }
})
```

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/mesh.config.ts:/serve/mesh.config.ts" \
  ghcr.io/ardatan/mesh-serve
```

For a full list of CLI arguments, please refer to the [Config Reference](./references/config).

### Changing port in container

The default port where Mesh Serve listens is `4000`; however, maybe the container is running inside
a network (like when using [Networking in Compose](https://docs.docker.com/compose/networking/)) and
you wish to change the port of Mesh Serve in the image.

You can use the `mesh.config.ts` to change the port, or simply pass in the `--port` argument when
running the image:

```sh
docker run \
  -p 8080:8080 \
  -v "$(pwd)/supergraph.graphql:/serve/supergraph.graphql" \
  ghcr.io/ardatan/mesh-serve --port=8080
```

## Running

Having a `supergraph.graphql` already composed with [Mesh Compose](/v1/compose), running the Docker
image is as easy as:

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/supergraph.graphql:/serve/mesh.config.ts" \
  ghcr.io/ardatan/mesh-serve
```

## Docker Compose

You may have an environment where you want to use [Docker Compose](https://docs.docker.com/compose/)
and would like to add Mesh Serve there.

Start by defining the `docker-compose.yml`

```yaml
services:
  mesh-serve:
    image: ghcr.io/ardatan/mesh-serve
    ports:
      - '4000:4000'
    # Add GraphQL Hive environment variables in case you use it
    # environment:
    #   HIVE_CDN_ENDPOINT: <secret>
    #   HIVE_CDN_KEY: <secret>
    #   HIVE_REGISTRY_TOKEN: <secret>
    volumes:
      - ./mesh.config.ts:/serve/mesh.config.ts
```

And then simply start the services with:

```sh
docker compose up
```

## Extend Docker Image

### Install plugin

You may want to add additional functionality, or plugins to the base image - you just need to create
a new Dockerfile basing the image off `ghcr.io/ardatan/mesh-serve`.

If need only a handful of plugins (or some other dependencies), you can simply extend the image and
install the modules with `npm i`:

For example, adding [Rate Limiting](/v1/serve/features/security/rate-limiting) to the container
would look like this:

```dockerfile filename="Dockerfile"
FROM ghcr.io/ardatan/mesh-serve

RUN npm i @graphql-mesh/plugin-rate-limit
```

```sh
docker build -t mesh-serve-w-rate-limit .
```

Configure to use the rate limiting plugin:

```ts filename="mesh.config.ts"
import useRateLimit from '@graphql-mesh/plugin-rate-limit'
import { defineConfig } from '@graphql-mesh/serve-cli'

export const serveConfig = defineConfig({
  plugins: pluginCtx => [
    useRateLimit({
      ...pluginCtx,
      rules: [
        {
          type: 'Query',
          field: 'foo',
          max: 5, // requests limit for a time period
          ttl: 5000, // time period
          // You can use any value from the context
          identifier: '{context.headers.authorization}'
        }
      ]
    })
  ]
})
```

And then simply start the new image with the config file mounted:

```sh
docker run \
  -p 4000:4000 \
  -v "$(pwd)/mesh.config.ts:/serve/mesh.config.ts" \
  mesh-serve-w-rate-limit
```

### Develop plugin

However, you may be developing a plugin and have a setup with some dependencies and source code,
copying over your project's files is the way to go.

In the following example, we're developing a `useTiming` plugin that will add a human readable
execution duration to the GraphQL result `extensions` property.

```json filename="package.json"
{
  "name": "my-timing",
  "dependencies": {
    "moment": "^2"
  },
  "devDependencies": {
    "@graphql-mesh/serve-cli": "latest",
    "@graphql-mesh/serve-runtime": "latest"
  }
}
```

```ts filename="my-timing.ts"
import moment from 'moment'
import type { MeshServePlugin } from '@graphql-mesh/serve-runtime'

export function useTiming(): MeshServePlugin {
  return {
    onExecute() {
      const start = Date.now()
      return {
        onExecuteDone({ result, setResult }) {
          const duration = moment.duration(Date.now() - start)
          if (isAsyncIterable(result)) {
            setResult(
              mapAsyncIterator(result, result => ({
                ...result,
                extensions: {
                  ...result?.extensions,
                  duration: duration.humanize()
                }
              }))
            )
            return
          }
          setResult({
            ...result,
            extensions: {
              ...result?.extensions,
              duration: duration.humanize()
            }
          })
        }
      }
    }
  }
}
```

```ts filename="mesh.config.ts"
import { defineConfig } from '@graphql-mesh/serve-cli'
import { useTiming } from './my-timing'

export const serveConfig = defineConfig({
  plugins: () => [useTiming()]
})
```

Your Dockerfile should then look something like this:

```dockerfile filename="Dockerfile"
FROM ghcr.io/ardatan/mesh-serve

# we dont install dev deps because:
#   1. we need them for type checking only
#   2. Mesh Serve is already available in the docker image
COPY package.json .
RUN npm i --omit=dev

COPY my-time.ts .
COPY mesh.config.ts .
```

Then build your image:

```sh
docker build -t mesh-serve-w-add-res .
```

And finally start it (the config file is in the image and doesn't need to be mounted):

```sh
docker run -p 4000:4000 mesh-serve-w-add-res
```

<Callout>
  For faster development, you can mount the source code as volumes so that you don't have to rebuild
  the image on each run.

```sh
docker run -p 4000:4000 \
  -v "$(pwd)/mesh.config.ts":/serve/mesh.config.ts \
  -v "$(pwd)/my-timing.ts":/serve/my-timing.ts \
  mesh-serve-w-add-res
```

</Callout>
