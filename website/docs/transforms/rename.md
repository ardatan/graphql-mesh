---
id: rename
title: Rename Transform
sidebar_label: Rename
---

The `rename` transform allow you rename GraphQL types and GraphQL fields easily. 

```
yarn add @graphql-mesh/transform-rename
```

## How to use?

Add the following configuration to your Mesh config file:

```yml
transforms:
  - rename:
      mode: bare | wrap
      renames:
        - from:
            type: ApiUser
          to:
            type: User
        - from:
            type: Query
            field: apiUser
          to:
            type: Query
            field: user
```

or you can use regular expressions to rename multiple types, fields or both

```yml
  - rename:
      mode: bare | wrap
      renames:
        - from:
            type: Api(.*)
          to:
            type: $1
          useRegExpForTypes: true

        - from:
            type: Query
            field: api(.*)
          to:
            type: Query
            field: $1
          useRegExpForFields: true

```

## Two different modes
Although apparently both `bare` and `wrap` modes do achieve the same result, when it comes to renaming; they are very different.  
Let's take a look at how they operate.

### Wrap
Wrap applies transformations by adding a wrapping layer to the original GraphQL schema. The handler generates a GraphQL
 schema and passes it to the rename transform. `wrap` receives this schema and rather than updating it, it will apply a layer on top of it, which scope is to provide the values exposed by the names of the original schema to the new names that you define as `renames`.  
This approach is safe as we have used it extensively in `graphql-tools`. However, it might have some runtime implications, since when receiving requests and preparing responses, the wrapping layer needs to apply the `renames` on the fly for every GraphQL operation.

> NOTE: `wrap` is the only approach that works when you want to transform at all-sources (root) level, unless you're using [merger-bare](https://graphql-mesh.com/docs/api/modules/merger-bare/). If you want to remove the possible runtime implications, consider either moving your `renames` at the data source level or opt into `merger-bare`; in order to take advantage of `bare` mode.

Example:
```yaml
sources:
  - name: Countries
    handler:
      soap:
        wsdl: http://webservices.../wso?WSDL
  - name: Users
    handler:
      openapi:
        source: https://api.../swagger.yaml
    transforms:
      rename:
          mode: wrap
          renames:
            - from:
                type: User
                field: lastName
              to:
                type: User
                field: surname
transforms:
  rename:
      mode: wrap # bare won't work here at all-sources (root) level, because you're not using merger-bare
      renames:
        - from:
            type: Country
            field: ISO-3166_Code
          to:
            type: Country
            field: code
```

> ProTip: When you want to use `wrap`, you can omit the "mode" property since this is already applied by default.  

### Bare
Bare is a recent addition and works by applying transformations to the original schema. The handler generates a GraphQL schema and passes it to the rename transform. `bare` will rename types and fields as defined in the schema generated by your handler and will return an updated version of the same schema with the transformations applied.  
The advantage of `bare` is that it commits the schema as part of the initialisation process only; then it won't have any potential runtime implications but with some restrictions!  

#### Restrictions
Bare does provide performance improvements over `wrap`; however it has a main restriction: it needs to access the bare schema. Here are some reasons why this might not work:
- Your data source is already in GraphQL format.  
In this case `bare` won't work as it cannot update a native GraphQL schema. This is not the same as updating a "translated" GraphQL schema (e.g. from JSON-schema, OpenApi, SOAP, etc.).
The suggestion in this case is to apply `wrap` transforms to your GraphQL data source and `bare` transforms to sources "translated" into GraphQL.

- You are applying rename transform at all-sources (root) level.  
This means that `bare` would be dealing with a stitched schema and not a bare schema anymore. If you do want to use `bare` at the root level your only choice is to opt into [merger-bare](https://graphql-mesh.com/docs/api/modules/merger-bare/), which lets transforms access the bare schemas; because it merges sources without wrapping them. This works when you don't have (or you take care of) conflicts between your sources.

- You are mixing transforms that supports `bare` with transforms that don't.  
Again, `bare` always need to access the bare schema. If you define other transforms that don't support `bare` mode, you will most likely have troubles, since those transforms will apply a wrapping layer which won't let `bare` transforms access the bare schema.
In order to take advantage of `bare` performance improvement, the suggestion here is to apply `wrap` transforms at the all-sources (root) level and `bare` transforms within the data sources level.

Example:
```yaml
sources:
  - name: Countries
    handler:
      soap:
        wsdl: http://webservices.../wso?WSDL
  - name: Users
    handler:
      openapi:
        source: https://api.../swagger.yaml
    transforms:
      rename:
          mode: bare # bare is a great choice here, at the data source level
          renames:
            - from:
                type: User
                field: lastName
              to:
                type: User
                field: surname
merger: bare # this lets transforms access the bare schemas
transforms:
  rename:
      mode: bare # bare will work here, at all-sources (root) level, because you're using merger-bare
      renames:
        - from:
            type: Country
            field: ISO-3166_Code
          to:
            type: Country
            field: code
```

## Config API Reference

{@import ../generated-markdown/RenameTransformObject.generated.md}
