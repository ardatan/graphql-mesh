import { createHash } from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import ADMZip from 'adm-zip';
import { defineConfig, rollup } from 'rollup';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import { nodeResolve } from '@rollup/plugin-node-resolve';

const seaConfig = JSON.parse(fs.readFileSync('sea-config.json', 'utf8'));

console.log(`Bundling binary to ${seaConfig.main}...`);

export default defineConfig({
  input: 'bundle/dist/bin.mjs',
  output: {
    file: seaConfig.main,
    format: 'cjs',
    inlineDynamicImports: true,
  },
  external: [
    'node-libcurl',
    '@parcel/watcher',
    'uWebSockets.js', // will be installed
    /node_modules\/graphql/, // will be packed as dep
    /node_modules\\graphql/, // will be packed as dep
  ],
  plugins: [
    nodeResolve({ preferBuiltins: true }), // resolve node_modules and bundle them too
    packDeps(),
  ],
});

/**
 * @type {import('rollup').PluginImpl}
 */
function packDeps() {
  const assetName = 'node_modules.zip';
  const destPath = seaConfig.assets[assetName];
  if (!destPath) {
    throw new Error(`Asset "${assetName}" not defined in sea-config.json`);
  }

  const zip = new ADMZip();
  let uwsAddonAdded = false;
  const uwsAddonForThisSystem = `uws_${process.platform}_${process.arch}_${process.versions.modules}.node`;
  const uWSDir = path.join('..', '..', 'node_modules', 'uWebSockets.js');
  const packedFiles = [
    uwsAddonForThisSystem,
    'package.json',
    'uws.js', // cjs
    'ESM_wrapper.mjs', // esm
    'index.d.ts', // types (unused, but why not)
  ];
  zip.addLocalFolder(uWSDir, './uWebSockets.js', filename => {
    filename = filename.replace('uWebSockets.js' + path.sep, '');
    if (packedFiles.includes(filename)) {
      console.log(`Packing ${filename}`);
    }
    if (filename === uwsAddonForThisSystem) uwsAddonAdded = true;
    return packedFiles.includes(filename);
  });
  if (!uwsAddonAdded) {
    console.warn(`uWebSockets.js doesnt have the "${uwsAddonForThisSystem}" addon for this system`);
  }
  const tsLibPath = path.join('..', '..', 'node_modules', 'tslib');
  zip.addLocalFolder(tsLibPath, './tslib'); // tslib is zero-dep (necessary for node-libcurl)
  const nodeLibcurlPath = path.join('..', '..', 'node_modules', 'node-libcurl');
  zip.addLocalFolder(nodeLibcurlPath, './node-libcurl'); // node-libcurl is zero-dep (aside from tslib, the other dependencies in package.json are just for building)
  const graphqlPath = path.join('..', '..', 'node_modules', 'graphql');
  zip.addLocalFolder(graphqlPath, './graphql'); // graphql is zero-dep
  zip.addLocalFolder('bundle/node_modules');
  const zipBuf = zip.toBuffer();
  const nodeVersionBuf = Buffer.from(process.version);
  const fullBuf = Buffer.concat([nodeVersionBuf, zipBuf]);
  const __MODULES_HASH__ = createHash('sha256').update(fullBuf).digest('hex');

  return {
    name: 'packDeps',
    async renderChunk(code) {
      // inject the sea packed deps install script on the second line, skipping the hashbang and 'use strict' declaration
      const [hashbang, usestrict, ...rest] = code.split('\n');
      code = [
        hashbang,
        usestrict,
        fs.readFileSync('scripts/install-sea-packed-deps.cjs', 'utf8'),
        ...rest,
      ].join('\n');

      // bundle adm-zip and inject it to the script
      const admZipPath = path.join('..', '..', 'node_modules', 'adm-zip', 'adm-zip.js');
      const bundle = await rollup({
        input: admZipPath,
        plugins: [nodeResolve(), commonjs(), json()],
      });
      const { output: outputs } = await bundle.generate({
        format: 'cjs',
        inlineDynamicImports: true,
      });
      code = code.replace(
        "require('adm-zip')",
        () => `/* require('adm-zip') */(function(){
const module = {};
${outputs[0].code}
return module.exports;
})()`,
      );
      await bundle.close();

      // inject the modules hash
      code = code.replaceAll('__MODULES_HASH__', JSON.stringify(__MODULES_HASH__));

      // replace all "graphql*" requires to use the packed deps (the new require will invoke @graphql-mesh/include/hooks)
      for (const [match, path] of code.matchAll(/require\('(graphql.*)'\)/g)) {
        code = code.replace(
          match,
          () => `require('node:module').createRequire(__filename)(${JSON.stringify(path)})`,
        );
      }

      /**
       * replace commonjsRequire generated by rollup's commonjs plugin
       * for dynamic requires to try using the packed dependencies
       *
       * dynamic requires are require calls that cannot be resolved statically and look like this:
       * ```js
       * const pkg = 'node-libcurl';
       * const libcurl = require(pkg);
       * ```
       *
       * fyi, the example is also the case in @whatwg-node/fetch for node-libcurl so this replacement makes it work too
       */
      const dynamicRequireReturnLocation = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')`;
      if (code.includes(dynamicRequireReturnLocation)) {
        code = code.replaceAll(
          dynamicRequireReturnLocation,
          "return require('node:module').createRequire(__filename)(path)",
        );
      } else {
        // if this is expected (and node-libcurl is bundled differently), simply remove this block
        throw new Error('Bundle does not have any dynamic commonjs requires');
      }

      // replace the @graphql-mesh/include/hooks register to use the absolute path of the packed deps
      const includeHooksRegisterDest = /register\(\s*'@graphql-mesh\/include\/hooks'/g; // intentionally no closing bracked because there's more arguments
      if (includeHooksRegisterDest.test(code)) {
        code = code.replaceAll(
          includeHooksRegisterDest,
          `register(require('node:url').pathToFileURL(require('node:path').join(globalThis.__PACKED_DEPS_PATH__, '@graphql-mesh', 'include', 'hooks.mjs'))`,
        );
      } else {
        throw new Error(
          `Include hooks path cannot be fixed, does "${includeHooksRegisterDest}" exist in the source code?`,
        );
      }

      return code;
    },
    async generateBundle() {
      this.emitFile({
        type: 'asset',
        fileName: assetName,
        source: zipBuf,
      });
    },
  };
}
