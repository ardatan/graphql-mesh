// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Cloudflare should generate the correct schema: cloudflare 1`] = `
"schema {
  query: Query
  mutation: Mutation
}

directive @oneOf on OBJECT | INTERFACE

directive @resolveRoot on FIELD_DEFINITION

directive @statusCodeTypeName(typeName: String, statusCode: ID) repeatable on UNION

directive @length(min: Int, max: Int) on SCALAR

directive @enum(value: String) on ENUM_VALUE

directive @typescript(type: String) on SCALAR | ENUM

directive @example(value: ObjMap) repeatable on FIELD_DEFINITION | OBJECT | INPUT_OBJECT | ENUM | SCALAR

directive @resolveRootField(field: String) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @regexp(pattern: String) on SCALAR

directive @globalOptions(sourceName: String, endpoint: String, operationHeaders: ObjMap, queryStringOptions: ObjMap, queryParams: ObjMap) on OBJECT

directive @httpOperation(path: String, operationSpecificHeaders: ObjMap, httpMethod: HTTPMethod, isBinary: Boolean, requestBaseBody: ObjMap, queryParamArgMap: ObjMap, queryStringOptionsByParam: ObjMap) on FIELD_DEFINITION

type Query @globalOptions(sourceName: "cloudflare", endpoint: "https://api.cloudflare.com/client/v4") {
  "List all accounts you have ownership or verified access to."
  accounts_list_accounts: accounts_list_accounts_response @httpOperation(path: "/accounts", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all address maps owned by the account."
  ip_address_management_address_maps_list_address_maps(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_list_address_maps_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Show a particular address map owned by the account."
  ip_address_management_address_maps_address_map_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_address_map_details_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Download specified LOA document under the account."
  ip_address_management_prefixes_download_loa_document(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier for the uploaded LOA document."
    loa_document_identifier: loa_document_identifier
  ): ip_address_management_prefixes_download_loa_document_4xx_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/loa_documents/{args.loa_document_identifier}/download", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all prefixes owned by the account."
  ip_address_management_prefixes_list_prefixes(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_address_management_prefixes_list_prefixes_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List a particular prefix owned by the account."
  ip_address_management_prefixes_prefix_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
  ): ip_address_management_prefixes_prefix_details_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List the current advertisement state for a prefix."
  ip_address_management_dynamic_advertisement_get_advertisement_status(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
  ): ip_address_management_dynamic_advertisement_get_advertisement_status_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}/bgp/status", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all delegations for a given account IP prefix."
  ip_address_management_prefix_delegation_list_prefix_delegations(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
  ): ip_address_management_prefix_delegation_list_prefix_delegations_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}/delegations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of audit logs for an account. The list can be filtered by who made the change, which zone was the change made on, and the timeframe of the change."
  audit_logs_get_account_audit_logs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): audit_logs_get_account_audit_logs_response @httpOperation(path: "/accounts/{args.account_identifier}/audit_logs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the current billing profile for the account."
  account_billing_profile_billing_profile_details(account_identifier: JSON!): account_billing_profile_billing_profile_details_response @httpOperation(path: "/accounts/{args.account_identifier}/billing/profile", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search and filter an account's Cloudflare Tunnels."
  cloudflare_tunnel_list_cloudflare_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): cloudflare_tunnel_list_cloudflare_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the details of a Cloudflare Tunnel from an account."
  cloudflare_tunnel_get_cloudflare_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
  ): cloudflare_tunnel_get_cloudflare_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the configuration of a specific Cloudflare Tunnel."
  cloudflare_tunnel_configuration_get_configuration(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
  ): cloudflare_tunnel_configuration_get_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}/configurations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all of the connection resources for a Cloudflare Tunnel."
  cloudflare_tunnel_list_cloudflare_tunnel_connections(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
  ): cloudflare_tunnel_list_cloudflare_tunnel_connections_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}/connections", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the Tunnel for a previously created Cloudflare Tunnel."
  cloudflare_tunnel_get_cloudflare_tunnel_token(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
  ): cloudflare_tunnel_get_cloudflare_tunnel_token_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}/token", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all the custom pages at the account level."
  custom_pages_for_an_account_list_custom_pages(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): custom_pages_for_an_account_list_custom_pages_response @httpOperation(path: "/accounts/{args.account_identifier}/custom_pages", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a custom page."
  custom_pages_for_an_account_get_a_custom_page(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: custom_pages_components_schemas_identifier_2
  ): custom_pages_for_an_account_get_a_custom_page_response @httpOperation(path: "/accounts/{args.account_identifier}/custom_pages/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all DLP profiles in an account."
  dlp_profiles_list_all_profiles(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): dlp_profiles_list_all_profiles_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a custom DLP profile."
  dlp_profiles_get_custom_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
  ): dlp_profiles_get_custom_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/custom/{args.profile_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a predefined DLP profile."
  dlp_profiles_get_predefined_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
  ): dlp_profiles_get_predefined_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/predefined/{args.profile_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a DLP profile by ID. Supports both predefined and custom profiles"
  dlp_profiles_get_dlp_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
  ): dlp_profiles_get_dlp_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/{args.profile_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured DNS Firewall clusters for an account."
  dns_firewall_list_dns_firewall_clusters(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): dns_firewall_list_dns_firewall_clusters_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Show a single configured DNS Firewall cluster for an account."
  dns_firewall_dns_firewall_cluster_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_dns_firewall_cluster_details_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of summarised aggregate metrics over a given time period."
  dns_firewall_analytics_table(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_analytics_table_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall/{args.identifier}/dns_analytics/report", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of aggregate metrics grouped by time interval."
  dns_firewall_analytics_by_time(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_analytics_by_time_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall/{args.identifier}/dns_analytics/report/bytime", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists existing destination addresses."
  email_routing_destination_addresses_list_destination_addresses(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): email_routing_destination_addresses_list_destination_addresses_response @httpOperation(path: "/accounts/{args.account_identifier}/email/routing/addresses", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets information for a specific destination email already created."
  email_routing_destination_addresses_get_a_destination_address(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Destination address identifier."
    destination_address_identifier: destination_address_identifier
  ): email_routing_destination_addresses_get_a_destination_address_response @httpOperation(path: "/accounts/{args.account_identifier}/email/routing/addresses/{args.destination_address_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches IP Access rules of an account. These rules apply to all the zones in the account. You can filter the results using several optional parameters."
  ip_access_rules_for_an_account_list_ip_access_rules(account_identifier: JSON!): ip_access_rules_for_an_account_list_ip_access_rules_response @httpOperation(path: "/accounts/{args.account_identifier}/firewall/access_rules/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of an IP Access rule defined at the account level."
  ip_access_rules_for_an_account_get_an_ip_access_rule(account_identifier: JSON!, identifier: JSON!): ip_access_rules_for_an_account_get_an_ip_access_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List up to 100 images with one request. Use the optional parameters below to get a specific range of images."
  cloudflare_images_list_images(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
  ): cloudflare_images_list_images_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists your signing keys. These can be found on your Cloudflare Images dashboard."
  cloudflare_images_keys_list_signing_keys(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): cloudflare_images_keys_list_signing_keys_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/keys", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch usage statistics details for Cloudflare Images."
  cloudflare_images_images_usage_statistics(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
  ): cloudflare_images_images_usage_statistics_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/stats", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists existing variants."
  cloudflare_images_variants_list_variants(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): cloudflare_images_variants_list_variants_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/variants", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch details for a single variant."
  cloudflare_images_variants_variant_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: variants_components_schemas_identifier!
  ): cloudflare_images_variants_variant_details_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/variants/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch details for a single image."
  cloudflare_images_image_details(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    "Image unique identifier."
    identifier: images_components_schemas_identifier
  ): cloudflare_images_image_details_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original."
  cloudflare_images_base_image(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    "Image unique identifier."
    identifier: images_components_schemas_identifier
  ): cloudflare_images_base_image_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/{args.identifier}/blob", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Scan suspicious url"
  phishing_url_scanner_scan_suspicious_url(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): phishing_url_scanner_scan_suspicious_url_response @httpOperation(path: "/accounts/{args.account_identifier}/intel-phishing/predict", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get ASN Overview"
  asn_intelligence_get_asn_overview(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    asn: asn_components_schemas_asn_Input!
  ): asn_intelligence_get_asn_overview_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/asn/{args.asn}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get ASN Subnets"
  asn_intelligence_get_asn_subnets(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    asn: asn_components_schemas_asn_Input!
  ): asn_intelligence_get_asn_subnets_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/asn/{args.asn}/subnets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Passive DNS by IP"
  passive_dns_by_ip_get_passive_dns_by_ip(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): passive_dns_by_ip_get_passive_dns_by_ip_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/dns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Domain Details"
  domain_intelligence_get_domain_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): domain_intelligence_get_domain_details_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/domain", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Domain History"
  domain_history_get_domain_history(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): domain_history_get_domain_history_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/domain-history", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Multiple Domain Details"
  domain_intelligence_get_multiple_domain_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): domain_intelligence_get_multiple_domain_details_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/domain/bulk", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get IP Overview"
  ip_intelligence_get_ip_overview(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_intelligence_get_ip_overview_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/ip", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get IP Lists"
  ip_list_get_ip_lists(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_list_get_ip_lists_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/ip-list", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get WHOIS Record"
  whois_record_get_whois_record(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): whois_record_get_whois_record_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/whois", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured monitors for an account."
  account_load_balancer_monitors_list_monitors(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): account_load_balancer_monitors_list_monitors_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List a single configured monitor for an account."
  account_load_balancer_monitors_monitor_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_monitors_monitor_details_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of resources that reference the provided monitor."
  account_load_balancer_monitors_list_monitor_references(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_monitors_list_monitor_references_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}/references", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured pools."
  account_load_balancer_pools_list_pools(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): account_load_balancer_pools_list_pools_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single configured pool."
  account_load_balancer_pools_pool_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_pools_pool_details_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch the latest pool health status for a single pool."
  account_load_balancer_pools_pool_health_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_pools_pool_health_details_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}/health", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of resources that reference the provided pool."
  account_load_balancer_pools_list_pool_references(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_pools_list_pool_references_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}/references", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the result of a previous preview operation using the provided preview_id."
  account_load_balancer_monitors_preview_result(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    preview_id: String!
  ): account_load_balancer_monitors_preview_result_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/preview/{args.preview_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all region mappings."
  load_balancer_regions_list_regions(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): load_balancer_regions_list_regions_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/regions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a single region mapping."
  load_balancer_regions_get_region(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    region_code: region_code!
  ): load_balancer_regions_get_region_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/regions/{args.region_code}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Search for Load Balancing resources."
  account_load_balancer_search_search_resources(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): account_load_balancer_search_search_resources_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/search", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists interconnects associated with an account."
  magic_interconnects_list_interconnects(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_interconnects_list_interconnects_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/cf_interconnects", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists details for a specific interconnect."
  magic_interconnects_list_interconnect_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_interconnects_list_interconnect_details_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/cf_interconnects/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists GRE tunnels associated with an account."
  magic_gre_tunnels_list_gre_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_gre_tunnels_list_gre_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists informtion for a specific GRE tunnel."
  magic_gre_tunnels_list_gre_tunnel_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_gre_tunnels_list_gre_tunnel_details_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists IPsec tunnels associated with an account."
  magic_i_psec_tunnels_list_i_psec_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_i_psec_tunnels_list_i_psec_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists details for a specific IPsec tunnel."
  magic_i_psec_tunnels_list_i_psec_tunnel_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_i_psec_tunnels_list_i_psec_tunnel_details_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all Magic static routes."
  magic_static_routes_list_routes(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_static_routes_list_routes_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a specific Magic static route."
  magic_static_routes_route_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    route_identifier: common_components_schemas_identifier
  ): magic_static_routes_route_details_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes/{args.route_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all members of an account."
  account_members_list_members(account_identifier: JSON!): account_members_list_members_response @httpOperation(path: "/accounts/{args.account_identifier}/members", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific member of an account."
  account_members_member_details(account_identifier: JSON!, identifier: JSON!): account_members_member_details_response @httpOperation(path: "/accounts/{args.account_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists default sampling and router IPs for account."
  magic_network_monitoring_configuration_list_account_configuration(account_identifier: String!): magic_network_monitoring_configuration_list_account_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists default sampling, router IPs, and rules for account."
  magic_network_monitoring_configuration_list_rules_and_account_configuration(account_identifier: String!): magic_network_monitoring_configuration_list_rules_and_account_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config/full", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists network monitoring rules for account."
  magic_network_monitoring_rules_list_rules(account_identifier: String!): [magic_network_monitoring_rules_list_rules_response] @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List a single network monitoring rule for account."
  magic_network_monitoring_rules_get_rule(account_identifier: String!, rule_identifier: String!): magic_network_monitoring_rules_get_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a list of all user projects."
  pages_project_get_projects(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): pages_project_get_projects_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a project by name."
  pages_project_get_project(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
  ): pages_project_get_project_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a list of deployments from a project."
  pages_deployment_get_deployments(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
  ): pages_deployment_get_deployments_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a deployment."
  pages_deployment_get_deployment_info(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
  ): pages_deployment_get_deployment_info_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch deploy logs."
  pages_deployment_get_deployment_logs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
  ): pages_deployment_get_deployment_logs_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}/history/logs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch deploy logs."
  pages_deployment_get_deployment_stage_logs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
    deployment_stage_name: deployment_stage_name!
  ): pages_deployment_get_deployment_stage_logs_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}/history/{args.deployment_stage_name}/logs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a list of all domains."
  pages_domains_get_domains(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
  ): pages_domains_get_domains_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/domains", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single domain."
  pages_domains_get_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    domain_name: domain_name!
  ): pages_domains_get_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/domains/{args.domain_name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all packet capture requests for an account."
  magic_pcap_collection_list_packet_capture_requests(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_pcap_collection_list_packet_capture_requests_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all buckets configured for use with PCAPs API."
  magic_pcap_collection_list_pca_ps_bucket_ownership(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): magic_pcap_collection_list_pca_ps_bucket_ownership_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/ownership", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information for a PCAP request by id."
  magic_pcap_collection_get_pcap_request(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): magic_pcap_collection_get_pcap_request_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Download PCAP information into a file. Response is a binary PCAP file."
  magic_pcap_collection_download_simple_pcap(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/{args.identifier}/download", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, sort and filter your Railguns."
  account_railguns_list_railguns(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): account_railguns_list_railguns_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Railgun details"
  account_railguns_railgun_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): account_railguns_railgun_details_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List connections associated with the Railgun."
  railgun_connections_list_connections(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    railgun_identifier: railgun_components_schemas_identifier
  ): railgun_connections_list_connections_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.railgun_identifier}/connections", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a connection by ID."
  railgun_connections_connection_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    railgun_identifier: railgun_components_schemas_identifier
    "Connection identifier tag."
    identifier: connection_components_schemas_identifier
  ): railgun_connections_connection_details_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.railgun_identifier}/connections/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Show individual domain."
  registrar_domains_get_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Domain name."
    domain_name: String!
  ): registrar_domains_get_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/registrar/domains/{args.domain_name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get all available roles for an account."
  account_roles_list_roles(account_identifier: JSON!): account_roles_list_roles_response @httpOperation(path: "/accounts/{args.account_identifier}/roles", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific role for an account."
  account_roles_role_details(account_identifier: JSON!, identifier: JSON!): account_roles_role_details_response @httpOperation(path: "/accounts/{args.account_identifier}/roles/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all lists in the account."
  lists_get_lists(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): lists_get_lists_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the current status of an asynchronous operation on a list.\\n\\nThe \`status\` property can have one of the following values: \`pending\`, \`running\`, \`completed\`, or \`failed\`. If the status is \`failed\`, the \`error\` property will contain a message describing the error."
  lists_get_bulk_operation_status(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique operation ID of the asynchronous action."
    operation_id: String
  ): lists_get_bulk_operation_status_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/bulk_operations/{args.operation_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a list."
  lists_get_a_list(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
  ): lists_get_a_list_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all the items in the list."
  lists_get_list_items(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
  ): lists_get_list_items_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}/items", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a list item in the list."
  lists_get_a_list_item(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
    "The unique ID of the item in the List."
    item_id: String!
  ): lists_get_a_list_item_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}/items/{args.item_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List ACLs."
  secondary_dns__acl_list_ac_ls(account_identifier: String!): secondary_dns__acl_list_ac_ls_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/acls", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get ACL."
  secondary_dns__acl_acl_details(account_identifier: String!, identifier: String!): secondary_dns__acl_acl_details_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/acls/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Peers."
  secondary_dns__peer_list_peers(account_identifier: String!): secondary_dns__peer_list_peers_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/peers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Peer."
  secondary_dns__peer_peer_details(account_identifier: String!, identifier: String!): secondary_dns__peer_peer_details_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/peers/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List TSIGs."
  secondary_dns__tsig_list_tsi_gs(account_identifier: String!): secondary_dns__tsig_list_tsi_gs_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/tsigs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get TSIG."
  secondary_dns__tsig_tsig_details(account_identifier: String!, identifier: String!): secondary_dns__tsig_tsig_details_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/tsigs/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves Workers KV request metrics for the given account."
  workers_kv_request_analytics_query_request_analytics(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): workers_kv_request_analytics_query_request_analytics_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/analytics", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves Workers KV stored data metrics for the given account."
  workers_kv_stored_data_analytics_query_stored_data_analytics(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): workers_kv_stored_data_analytics_query_stored_data_analytics_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/analytics/stored", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the namespaces owned by an account."
  workers_kv_namespace_list_namespaces(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): workers_kv_namespace_list_namespaces_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists a namespace's keys."
  workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
  ): workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/keys", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (e.g. :, !, %) in the key name."
  workers_kv_namespace_read_the_metadata_for_a_key(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
    key_name: key_name!
  ): workers_kv_namespace_read_the_metadata_for_a_key_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/metadata/{args.key_name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (e.g. :, !, %) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the \\"Expiration\\" response header."
  workers_kv_namespace_read_key_value_pair(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
    key_name: key_name!
  ): workers_kv_namespace_read_key_value_pair_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/values/{args.key_name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists up to 1000 videos from a single request. For a specific range, refer to the optional parameters."
  stream_videos_list_videos(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
  ): stream_videos_list_videos_response @httpOperation(path: "/accounts/{args.account_identifier}/stream", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the video ID and creation date and time when a signing key was created."
  stream_signing_keys_list_signing_keys(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): stream_signing_keys_list_signing_keys_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/keys", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input."
  stream_live_inputs_list_live_inputs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): stream_live_inputs_list_live_inputs_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves details of an existing live input."
  stream_live_inputs_retrieve_a_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
  ): stream_live_inputs_retrieve_a_live_input_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves all outputs associated with a specified live input."
  stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
  ): stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}/outputs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all watermark profiles for an account."
  stream_watermark_profile_list_watermark_profiles(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
  ): stream_watermark_profile_list_watermark_profiles_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/watermarks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves details for a single watermark profile."
  stream_watermark_profile_watermark_profile_details(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "The unique identifier for a watermark profile."
    identifier: watermarks_components_schemas_identifier
  ): stream_watermark_profile_watermark_profile_details_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/watermarks/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of webhooks."
  stream_webhook_view_webhooks(
    "Account identifier tag."
    account_identifier: webhook_components_schemas_account_identifier
  ): stream_webhook_view_webhooks_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/webhook", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches details for a single video."
  stream_videos_retrieve_video_details(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "A Cloudflare-generated unique identifier for a media item."
    identifier: videos_components_schemas_identifier
  ): stream_videos_retrieve_video_details_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches an HTML code snippet to embed a video in a web page delivered through Cloudflare. On success, returns an HTML fragment for use on web pages to display a video. On failure, returns a JSON response body."
  stream_videos_retreieve_embed_code_html(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "A Cloudflare-generated unique identifier for a media item."
    identifier: videos_components_schemas_identifier
  ): stream_videos_retreieve_embed_code_html_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.identifier}/embed", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the available captions or subtitles for a specific video."
  stream_subtitles__captions_list_captions_or_subtitles(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for the media file."
    video_identifier: schemas_video_identifier
  ): stream_subtitles__captions_list_captions_or_subtitles_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.video_identifier}/captions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the downloads created for a video."
  stream_m_p_4_downloads_list_downloads(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for the MP4 file."
    video_identifier: video_identifier
  ): stream_m_p_4_downloads_list_downloads_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.video_identifier}/downloads", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all of an account's subscriptions."
  account_subscriptions_list_subscriptions(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): account_subscriptions_list_subscriptions_response @httpOperation(path: "/accounts/{args.account_identifier}/subscriptions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search and filter an account's tunnel routes."
  tunnel_route_list_tunnel_routes(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): tunnel_route_list_tunnel_routes_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/routes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Find the Tunnel Route that encompasses the given IP."
  tunnel_route_get_tunnel_route_by_ip(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    ip: String!
  ): tunnel_route_get_tunnel_route_by_ip_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/routes/ip/{args.ip}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search and filter an account's virtual networks."
  tunnel_virtual_network_list_virtual_networks(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): tunnel_virtual_network_list_virtual_networks_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/virtual_networks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search and filter an account's Argo Tunnels."
  argo_tunnel_list_argo_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): argo_tunnel_list_argo_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/tunnels", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the details of an Argo Tunnel from an account."
  argo_tunnel_get_argo_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
  ): argo_tunnel_get_argo_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/tunnels/{args.tunnel_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured DNS Firewall clusters for an account."
  dns_firewall__legacy_list_dns_firewall_clusters(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): dns_firewall__legacy_list_dns_firewall_clusters_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Show a single configured DNS Firewall cluster for an account."
  dns_firewall__legacy_dns_firewall_cluster_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall__legacy_dns_firewall_cluster_details_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of summarised aggregate metrics over a given time period."
  dns_firewall_analytics__legacy_table(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_analytics__legacy_table_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns/{args.identifier}/dns_analytics/report", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of aggregate metrics grouped by time interval."
  dns_firewall_analytics__legacy_by_time(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_analytics__legacy_by_time_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns/{args.identifier}/dns_analytics/report/bytime", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches Worker Account Settings for an account."
  worker_account_settings_fetch_worker_account_settings(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): worker_account_settings_fetch_worker_account_settings_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/account-settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all Worker Domains."
  worker_domain_list_domains(account_identifier: String!): worker_domain_list_domains_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/domains", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a Worker Domain."
  worker_domain_get_a_domain(
    account_identifier: String!
    "Identifer of the Worker Domain."
    domain_identifier: String!
  ): worker_domain_get_a_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/domains/{args.domain_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the namespaces owned by an account."
  durable_objects_namespace_list_namespaces(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): durable_objects_namespace_list_namespaces_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/durable_objects/namespaces", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the Durable Objects in a given namespace."
  durable_objects_namespace_list_objects(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "ID of the namespace."
    id: String!
  ): durable_objects_namespace_list_objects_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/durable_objects/namespaces/{args.id}/objects", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the queues owned by an account."
  queue_list_queues(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): queue_list_queues_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific queue."
  queue_queue_details(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
  ): queue_queue_details_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the consumers for a queue."
  queue_list_queue_consumers(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
  ): queue_list_queue_consumers_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}/consumers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a list of uploaded workers."
  worker_script_list_workers(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): worker_script_list_workers_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch raw script content for your worker. Note this is the original script content, not JSON encoded."
  worker_script_download_worker(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): String_container @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}", operationSpecificHeaders: "{\\"accept\\":\\"undefined\\"}", httpMethod: GET)
  "Fetches Cron Triggers for a Worker."
  worker_cron_trigger_get_cron_triggers(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): worker_cron_trigger_get_cron_triggers_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/schedules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get list of tails currently deployed on a worker."
  worker_tail_logs_list_tails(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): worker_tail_logs_list_tails_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/tails", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the Usage Model for a given Worker."
  worker_script_fetch_usage_model(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): worker_script_fetch_usage_model_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/usage-model", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns a Workers subdomain for an account."
  worker_subdomain_get_subdomain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): worker_subdomain_get_subdomain_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/subdomain", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all Categories."
  zero_trust_gateway_categories_list_categories(
    "Identifier"
    account_id: common_components_schemas_identifier
  ): zero_trust_gateway_categories_list_categories_response @httpOperation(path: "/accounts/{args.account_id}/gateway/categories", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all rulesets at the account level."
  account_rulesets_list_account_rulesets(
    "Identifier"
    account_id: common_components_schemas_identifier
  ): account_rulesets_list_account_rulesets_response @httpOperation(path: "/accounts/{args.account_id}/rulesets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the latest version of the account entry point ruleset for a given phase."
  account_rulesets_get_an_account_entry_point_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_phase: phase!
  ): account_rulesets_get_an_account_entry_point_ruleset_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/phases/{args.ruleset_phase}/entrypoint", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the versions of an account entry point ruleset."
  account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_phase: phase!
  ): account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/phases/{args.ruleset_phase}/versions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a specific version of an account entry point ruleset."
  account_rulesets_get_an_account_entry_point_ruleset_version(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_phase: phase!
    ruleset_version: version!
  ): account_rulesets_get_an_account_entry_point_ruleset_version_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/phases/{args.ruleset_phase}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the latest version of an account ruleset."
  account_rulesets_get_an_account_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): account_rulesets_get_an_account_ruleset_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the versions of an account ruleset."
  account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/versions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a specific version of an account ruleset."
  account_rulesets_get_an_account_ruleset_version(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    ruleset_version: version!
  ): account_rulesets_get_an_account_ruleset_version_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the rules of a managed account ruleset version for a given tag."
  account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    ruleset_version: version!
    "A category of the rule."
    rule_tag: String!
  ): account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/versions/{args.ruleset_version}/by_tag/{args.rule_tag}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific account that you are a member of."
  accounts_account_details(identifier: JSON!): accounts_account_details_response @httpOperation(path: "/accounts/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all Access applications in an account."
  access_applications_list_access_applications(identifier: String!): access_applications_list_access_applications_response @httpOperation(path: "/accounts/{args.identifier}/access/apps", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists short-lived certificate CAs and their public keys."
  access_short_lived_certificate_c_as_list_short_lived_certificate_c_as(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/ca", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches information about an Access application."
  access_applications_get_an_access_application(identifier: String!, app_id: String!): access_applications_get_an_access_application_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Tests if a specific user has permission to access an application."
  access_applications_test_access_policies(identifier: String!, app_id: String!): access_applications_test_access_policies_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.app_id}/user_policy_checks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single Access policy."
  access_policies_get_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): access_policies_get_an_access_policy_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a short-lived certificate CA and its public key."
  access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists Access policies configured for an application."
  access_policies_list_access_policies(
    identifier: String!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): access_policies_list_access_policies_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid}/policies", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists Bookmark applications."
  access_bookmark_applications__deprecated_list_bookmark_applications(identifier: String!): access_bookmark_applications__deprecated_list_bookmark_applications_response @httpOperation(path: "/accounts/{args.identifier}/access/bookmarks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single Bookmark application."
  access_bookmark_applications__deprecated_get_a_bookmark_application(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_bookmark_applications__deprecated_get_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/bookmarks/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all mTLS certificates."
  access_m_tls_authentication_list_m_tls_certificates(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): access_m_tls_authentication_list_m_tls_certificates_response @httpOperation(path: "/accounts/{args.identifier}/access/certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single mTLS certificate."
  access_m_tls_authentication_get_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_m_tls_authentication_get_an_m_tls_certificate_response @httpOperation(path: "/accounts/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all Access groups."
  access_groups_list_access_groups(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): access_groups_list_access_groups_response @httpOperation(path: "/accounts/{args.identifier}/access/groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single Access group."
  access_groups_get_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
  ): access_groups_get_an_access_group_response @httpOperation(path: "/accounts/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all configured identity providers."
  access_identity_providers_list_access_identity_providers(identifier: String!): access_identity_providers_list_access_identity_providers_response @httpOperation(path: "/accounts/{args.identifier}/access/identity_providers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a configured identity provider."
  access_identity_providers_get_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_identity_providers_get_an_access_identity_provider_response @httpOperation(path: "/accounts/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the Access key rotation settings for an account."
  access_key_configuration_get_the_access_key_configuration(identifier: String!): access_key_configuration_get_the_access_key_configuration_response @httpOperation(path: "/accounts/{args.identifier}/access/keys", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of Access authentication audit logs for an account."
  access_authentication_logs_get_access_authentication_logs(identifier: String!): access_authentication_logs_get_access_authentication_logs_response @httpOperation(path: "/accounts/{args.identifier}/access/logs/access_requests", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the configuration for your Zero Trust organization."
  zero_trust_organization_get_your_zero_trust_organization(identifier: String!): zero_trust_organization_get_your_zero_trust_organization_response @httpOperation(path: "/accounts/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all service tokens."
  access_service_tokens_list_service_tokens(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): access_service_tokens_list_service_tokens_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of users for an account."
  zero_trust_users_get_users(identifier: String!): zero_trust_users_get_users_response @httpOperation(path: "/accounts/{args.identifier}/access/users", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get all failed login attempts for a single user."
  zero_trust_users_get_failed_logins(
    identifier: String!
    "The ID of the user."
    id: String!
  ): zero_trust_users_get_failed_logins_response @httpOperation(path: "/accounts/{args.identifier}/access/users/{args.id}/failed_logins", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of all alert types for which an account is eligible."
  notification_alert_types_get_alert_types(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_alert_types_get_alert_types_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/available_alerts", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of all delivery mechanism types for which an account is eligible."
  notification_mechanism_eligibility_get_delivery_mechanism_eligibility(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_mechanism_eligibility_get_delivery_mechanism_eligibility_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/eligible", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of all configured PagerDuty services."
  notification_destinations_with_pager_duty_list_pager_duty_services(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_destinations_with_pager_duty_list_pager_duty_services_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/pagerduty", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of all configured webhook destinations."
  notification_webhooks_list_webhooks(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_webhooks_list_webhooks_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/webhooks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get details for a single webhooks destination."
  notification_webhooks_get_a_webhook(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): notification_webhooks_get_a_webhook_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/webhooks/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of history records for notifications sent to an account. The records are displayed for last \`x\` number of days based on the zone plan (free = 30, pro = 30, biz = 30, ent = 90)."
  notification_history_list_history(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_history_list_history_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/history", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of all Notification policies."
  notification_policies_list_notification_policies(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): notification_policies_list_notification_policies_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/policies", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get details for a single policy."
  notification_policies_get_a_notification_policy(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): notification_policies_get_a_notification_policy_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/policies/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List an account's custom nameservers."
  account_level_custom_nameservers_list_account_custom_nameservers(
    "Account identifier tag."
    identifier: custom_ns_components_schemas_identifier
  ): account_level_custom_nameservers_list_account_custom_nameservers_response @httpOperation(path: "/accounts/{args.identifier}/custom_ns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Eligible Zones for Account Custom Nameservers"
  account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers(
    "Account identifier tag."
    identifier: custom_ns_components_schemas_identifier
  ): account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers_response @httpOperation(path: "/accounts/{args.identifier}/custom_ns/availability", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Enrolled Devices."
  devices_list_devices(identifier: String!): devices_list_devices_response @httpOperation(path: "/accounts/{args.identifier}/devices", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the device settings policies for an account."
  devices_list_device_settings_policies(identifier: String!): devices_list_device_settings_policies_response @httpOperation(path: "/accounts/{args.identifier}/devices/policies", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the default device settings policy for an account."
  devices_get_default_device_settings_policy(identifier: String!): devices_get_default_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of routes excluded from the WARP client's tunnel."
  devices_get_split_tunnel_exclude_list(identifier: String!): devices_get_split_tunnel_exclude_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/exclude", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of domains to bypass Gateway for DNS resolution and instead use the specified server."
  devices_get_local_domain_fallback_list(identifier: String!): devices_get_local_domain_fallback_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/fallback_domains", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of routes included in the WARP client's tunnel."
  devices_get_split_tunnel_include_list(identifier: String!): devices_get_split_tunnel_include_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/include", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the device settings policy by ID."
  devices_get_device_settings_policy_by_id(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_get_device_settings_policy_by_id_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of routes excluded from the WARP client's tunnel for one specific device settings policy."
  devices_get_split_tunnel_exclude_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_get_split_tunnel_exclude_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/exclude", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of domains to bypass Gateway for DNS resolution and instead use the specified server."
  devices_get_local_domain_fallback_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_get_local_domain_fallback_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/fallback_domains", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of routes included in the WARP client's tunnel for one specific device settings policy."
  devices_get_split_tunnel_include_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_get_split_tunnel_include_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/include", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Device Posture Rules for an account."
  device_posture_rules_list_device_posture_rules(identifier: String!): device_posture_rules_list_device_posture_rules_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Device Posture Integrations for an account."
  device_posture_integrations_list_device_posture_integrations(identifier: String!): device_posture_integrations_list_device_posture_integrations_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/integration", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Device Posture Integration."
  device_posture_integrations_device_posture_integration_details(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_integrations_components_schemas_uuid!
  ): device_posture_integrations_device_posture_integration_details_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/integration/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Device Posture Rule."
  device_posture_rules_device_posture_rules_details(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_rules_components_schemas_uuid!
  ): device_posture_rules_device_posture_rules_details_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Describes the current device settings Zero Trust account."
  zero_trust_accounts_get_device_settings_for_zero_trust_account(identifier: String!): zero_trust_accounts_get_device_settings_for_zero_trust_account_response @httpOperation(path: "/accounts/{args.identifier}/devices/settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Device."
  devices_device_details(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_device_details_response @httpOperation(path: "/accounts/{args.identifier}/devices/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch one-time use admin override code for a device. This relies on the Admin Override setting being enabled in your device configuration."
  devices_list_admin_override_code_for_device(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_list_admin_override_code_for_device_response @httpOperation(path: "/accounts/{args.identifier}/devices/{args.uuid}/override_codes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Zero Trust account information."
  zero_trust_accounts_get_zero_trust_account_information(identifier: String!): zero_trust_accounts_get_zero_trust_account_information_response @httpOperation(path: "/accounts/{args.identifier}/gateway", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all Application and Application Type mappings."
  zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings_response @httpOperation(path: "/accounts/{args.identifier}/gateway/app_types", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Describes current Zero Trust account configuration."
  zero_trust_accounts_get_zero_trust_account_configuration(identifier: String!): zero_trust_accounts_get_zero_trust_account_configuration_response @httpOperation(path: "/accounts/{args.identifier}/gateway/configuration", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Zero Trust Lists for an account."
  zero_trust_lists_list_zero_trust_lists(identifier: String!): zero_trust_lists_list_zero_trust_lists_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Zero Trust List."
  zero_trust_lists_zero_trust_list_details(
    identifier: String!
    "API Resource UUID tag."
    uuid: lists_components_schemas_uuid!
  ): zero_trust_lists_zero_trust_list_details_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch all items of a single Zero Trust List."
  zero_trust_lists_zero_trust_list_items(
    identifier: String!
    "API Resource UUID tag."
    uuid: lists_components_schemas_uuid!
  ): zero_trust_lists_zero_trust_list_items_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists/{args.uuid}/items", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Zero Trust Gateway Locations for an account."
  zero_trust_gateway_locations_list_zero_trust_gateway_locations(identifier: String!): zero_trust_gateway_locations_list_zero_trust_gateway_locations_response @httpOperation(path: "/accounts/{args.identifier}/gateway/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Zero Trust Gateway Location."
  zero_trust_gateway_locations_zero_trust_gateway_location_details(identifier: String!, uuid: String!): zero_trust_gateway_locations_zero_trust_gateway_location_details_response @httpOperation(path: "/accounts/{args.identifier}/gateway/locations/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Describes the current logging settings for Zero Trust account."
  zero_trust_accounts_get_logging_settings_for_the_zero_trust_account(identifier: String!): zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_response @httpOperation(path: "/accounts/{args.identifier}/gateway/logging", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Zero Trust Gateway Proxy Endpoint."
  zero_trust_gateway_proxy_endpoints_list_proxy_endpoints(identifier: String!): zero_trust_gateway_proxy_endpoints_list_proxy_endpoints_response @httpOperation(path: "/accounts/{args.identifier}/gateway/proxy_endpoints", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Zero Trust Gateway Proxy Endpoints for an account."
  zero_trust_gateway_proxy_endpoints_proxy_endpoint_details(identifier: String!, uuid: String!): zero_trust_gateway_proxy_endpoints_proxy_endpoint_details_response @httpOperation(path: "/accounts/{args.identifier}/gateway/proxy_endpoints/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Zero Trust Gateway Rules for an account."
  zero_trust_gateway_rules_list_zero_trust_gateway_rules(identifier: String!): zero_trust_gateway_rules_list_zero_trust_gateway_rules_response @httpOperation(path: "/accounts/{args.identifier}/gateway/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single Zero Trust Gateway Rule."
  zero_trust_gateway_rules_zero_trust_gateway_rule_details(
    identifier: String!
    "API Resource UUID tag."
    uuid: rules_components_schemas_uuid!
  ): zero_trust_gateway_rules_zero_trust_gateway_rule_details_response @httpOperation(path: "/accounts/{args.identifier}/gateway/rules/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all existing Origin CA certificates for a given zone. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests))."
  origin_ca_list_certificates: origin_ca_list_certificates_response @httpOperation(path: "/certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests))."
  origin_ca_get_certificate(
    "The x509 serial number of the Origin CA certificate."
    identifier: String
  ): origin_ca_get_certificate_response @httpOperation(path: "/certificates/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Cloudflare IPs."
  cloudflare_i_ps_cloudflare_ip_details: cloudflare_i_ps_cloudflare_ip_details_response @httpOperation(path: "/ips", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List memberships of accounts the user can access."
  user_SINGLE_QUOTE__s_account_memberships_list_memberships: user_SINGLE_QUOTE__s_account_memberships_list_memberships_response @httpOperation(path: "/memberships", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a specific membership."
  user_SINGLE_QUOTE__s_account_memberships_membership_details(
    "Membership identifier tag."
    identifier: membership_components_schemas_identifier
  ): user_SINGLE_QUOTE__s_account_memberships_membership_details_response @httpOperation(path: "/memberships/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific organization that you are a member of."
  organizations__deprecated_organization_details(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): organizations__deprecated_organization_details_response @httpOperation(path: "/organizations/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of audit logs for an organization. The list can be filtered by who made the change, which zone was the change made on, and the timeframe of the change."
  audit_logs_get_organization_audit_logs(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
  ): audit_logs_get_organization_audit_logs_response @httpOperation(path: "/organizations/{args.organization_identifier}/audit_logs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all invitations associated with an organization."
  organization_invites_list_invitations(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
  ): organization_invites_list_invitations_response @httpOperation(path: "/organizations/{args.organization_identifier}/invites", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the details of an invitation."
  organization_invites_invitation_details(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Invite identifier tag."
    identifier: invite_components_schemas_identifier
  ): organization_invites_invitation_details_response @httpOperation(path: "/organizations/{args.organization_identifier}/invites/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all members of a organization."
  organization_members_list_members(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
  ): organization_members_list_members_response @httpOperation(path: "/organizations/{args.organization_identifier}/members", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific member of an organization."
  organization_members_member_details(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): organization_members_member_details_response @httpOperation(path: "/organizations/{args.organization_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, sort and filter your Railguns."
  organization_railgun_list_railguns(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
  ): organization_railgun_list_railguns_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Railgun details"
  organization_railgun_railgun_details(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): organization_railgun_railgun_details_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists the zones that are currently using this Railgun."
  organization_railgun_get_railgun_zones(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): organization_railgun_get_railgun_zones_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns/{args.identifier}/zones", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get all available roles for an organization."
  organization_roles_list_roles(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
  ): organization_roles_list_roles_response @httpOperation(path: "/organizations/{args.organization_identifier}/roles", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific role for an organization."
  organization_roles_role_details(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
    "Role identifier tag."
    identifier: role_components_schemas_identifier
  ): organization_roles_role_details_response @httpOperation(path: "/organizations/{args.organization_identifier}/roles/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get outages annotations"
  radar_annotations_get_outages_annotations: radar_annotations_get_outages_annotations_response @httpOperation(path: "/radar/annotations/outages", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get top outages annotations"
  radar_annotations_get_top_outages_annotations: radar_annotations_get_top_outages_annotations_response @httpOperation(path: "/radar/annotations/outages/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of network protocols in layer 3/4 attacks."
  radar_attacks_get_a_summary_of_layer_3_attacks: radar_attacks_get_a_summary_of_layer_3_attacks_response @httpOperation(path: "/radar/attacks/layer3/summary", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get layer 3/4 attacks change over time. Values are normalized using min-max by default, with the minimum set to 0. When asking for multiple time series, you can also get the percentual relative change of the 1st/main series, with respect to the 2nd/control series - for example, to get the relative change of this week from the previous week, the 1st series would have a date range of 7d, the 2nd, a date range of 7dControl, and the normalization would be set to PERCENTAGE_CHANGE."
  radar_attacks_get_layer_3_attacks_time_series: radar_attacks_get_layer_3_attacks_time_series_response @httpOperation(path: "/radar/attacks/layer3/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get percentage of what type of network protocols are used in layer 3/4 attacks, over time."
  radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time: radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_response @httpOperation(path: "/radar/attacks/layer3/timeseries_groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of mitigation techniques in layer 7 attacks."
  radar_attacks_get_a_summary_of_layer_7_attacks: radar_attacks_get_a_summary_of_layer_7_attacks_response @httpOperation(path: "/radar/attacks/layer7/summary", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get layer 7 attacks change over time. Values are normalized using min-max by default, with the minimum set to 0. When asking for multiple time series, you can also get the percentage relative change of the first/main series, with respect to the second/control series - for example, to get the relative change of this week from the previous week, the first series would have a date range of \`7d\`, the second, a date range of \`7dControl\`, and the normalization would be set to \`PERCENTAGE_CHANGE\`."
  radar_attacks_get_attacks_layer_7_time_series: radar_attacks_get_attacks_layer_7_time_series_response @httpOperation(path: "/radar/attacks/layer7/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get percentage of what type of mitigation techniques are used to block layer 7 attacks, over time."
  radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time: radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_response @httpOperation(path: "/radar/attacks/layer7/timeseries_groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top origin ASes by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP."
  radar_attacks_get_layer_7_top_origin_a_ses: radar_attacks_get_layer_7_top_origin_a_ses_response @httpOperation(path: "/radar/attacks/layer7/top/ases/origin", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location)."
  radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations: radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_response @httpOperation(path: "/radar/attacks/layer7/top/attacks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP."
  radar_attacks_get_layer_7_top_origin_locations: radar_attacks_get_layer_7_top_origin_locations_response @httpOperation(path: "/radar/attacks/layer7/top/locations/origin", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available."
  radar_attacks_get_layer_7_top_target_locations: radar_attacks_get_layer_7_top_target_locations_response @httpOperation(path: "/radar/attacks/layer7/top/locations/target", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned."
  radar_bgp_get_bgp_time_series: radar_bgp_get_bgp_time_series_response @httpOperation(path: "/radar/bgp/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates."
  radar_bgp_get_top_autonomous_systems: radar_bgp_get_top_autonomous_systems_response @httpOperation(path: "/radar/bgp/top/ases", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates."
  radar_bgp_get_top_prefixes: radar_bgp_get_top_prefixes_response @httpOperation(path: "/radar/bgp/top/prefixes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of datasets."
  radar_datasets_get_datasets: radar_datasets_get_datasets_response @httpOperation(path: "/radar/datasets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET) @httpOperation(path: "/radar/reports/datasets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get DNS queries change over time."
  radar_dns_get_dns_time_series: radar_dns_get_dns_time_series_response @httpOperation(path: "/radar/dns/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get top autonomous systems by DNS queries made to Cloudflare's public DNS resolver."
  radar_dns_get_top_autonomous_systems_by_dns_queries_: radar_dns_get_top_autonomous_systems_by_dns_queries__response @httpOperation(path: "/radar/dns/top/ases", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get top locations by DNS queries made to Cloudflare's public DNS resolver."
  radar_dns_get_top_locations_by_dns_queries: radar_dns_get_top_locations_by_dns_queries_response @httpOperation(path: "/radar/dns/top/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of autonomous systems (AS)."
  radar_entities_get_autonomous_systems: radar_entities_get_autonomous_systems_response @httpOperation(path: "/radar/entities/asns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get autonomous system information by IP address"
  radar_entities_get_autonomous_system_information_by_ip_address: radar_entities_get_autonomous_system_information_by_ip_address_response @httpOperation(path: "/radar/entities/asns/ip", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the requested autonomous system information. A confidence level below \`5\` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this AS)."
  radar_entities_get_autonomous_system__as_by_id(
    "Autonomous System Number (ASN)."
    asn: Int!
  ): radar_entities_get_autonomous_system__as_by_id_response @httpOperation(path: "/radar/entities/asns/{args.asn}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of locations."
  radar_entities_get_locations: radar_entities_get_locations_response @httpOperation(path: "/radar/entities/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the requested location information. A confidence level below \`5\` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this location)."
  radar_entities_get_location(
    "Alpha-2 country code."
    location: String!
  ): radar_entities_get_location_response @httpOperation(path: "/radar/entities/locations/{args.location}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic classified as automated or human."
  radar_http_get_a_summary_of_bot_classes: radar_http_get_a_summary_of_bot_classes_response @httpOperation(path: "/radar/http/summary/bot_class", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per device type."
  radar_http_get_a_summary_of_device_types: radar_http_get_a_summary_of_device_types_response @httpOperation(path: "/radar/http/summary/device_type", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per HTTP protocol."
  radar_http_get_a_summary_of_http_protocols: radar_http_get_a_summary_of_http_protocols_response @httpOperation(path: "/radar/http/summary/http_protocol", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per HTTP protocol version."
  radar_http_get_a_summary_of_http_versions: radar_http_get_a_summary_of_http_versions_response @httpOperation(path: "/radar/http/summary/http_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per IP protocol version."
  radar_http_get_a_summary_of_ip_versions: radar_http_get_a_summary_of_ip_versions_response @httpOperation(path: "/radar/http/summary/ip_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per TLS protocol version."
  radar_http_get_a_summary_of_tls_versions: radar_http_get_a_summary_of_tls_versions_response @httpOperation(path: "/radar/http/summary/tls_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic classified as automated or human over time."
  radar_http_get_time_series_of_bot_classes: radar_http_get_time_series_of_bot_classes_response @httpOperation(path: "/radar/http/timeseries/bot_class", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic of the top user agents in the selected time range, over time."
  radar_http_get_time_series_of_user_agents: radar_http_get_time_series_of_user_agents_response @httpOperation(path: "/radar/http/timeseries/browser", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic of the top user agents aggregated in families in the selected time range, over time."
  radar_http_get_time_series_of_user_agents_aggregated_in_families: radar_http_get_time_series_of_user_agents_aggregated_in_families_response @httpOperation(path: "/radar/http/timeseries/browser_family", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per device type over time."
  radar_http_get_time_series_of_device_types: radar_http_get_time_series_of_device_types_response @httpOperation(path: "/radar/http/timeseries/device_type", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per HTTP protocol over time."
  radar_http_get_time_series_of_http_protocols: radar_http_get_time_series_of_http_protocols_response @httpOperation(path: "/radar/http/timeseries/http_protocol", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per HTTP protocol version over time."
  radar_http_get_time_series_of_http_versions: radar_http_get_time_series_of_http_versions_response @httpOperation(path: "/radar/http/timeseries/http_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per IP protocol version over time."
  radar_http_get_time_series_of_ip_versions: radar_http_get_time_series_of_ip_versions_response @httpOperation(path: "/radar/http/timeseries/ip_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Percentage distribution of traffic per TLS protocol version over time."
  radar_http_get_time_series_of_tls_versions: radar_http_get_time_series_of_tls_versions_response @httpOperation(path: "/radar/http/timeseries/tls_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS) by HTTP traffic. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_http_requests: radar_http_get_top_autonomous_systems_by_http_requests_response @httpOperation(path: "/radar/http/top/ases", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_bot_class(bot_class: bot_class! = LIKELY_AUTOMATED): radar_http_get_top_autonomous_systems_by_bot_class_response @httpOperation(path: "/radar/http/top/ases/bot_class/{args.bot_class}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_device_type(device_type: device_type! = DESKTOP): radar_http_get_top_autonomous_systems_by_device_type_response @httpOperation(path: "/radar/http/top/ases/device_type/{args.device_type}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_http_protocol(http_protocol: http_protocol! = HTTP): radar_http_get_top_autonomous_systems_by_http_protocol_response @httpOperation(path: "/radar/http/top/ases/http_protocol/{args.http_protocol}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_http_version(http_version: http_version! = HTTPv1): radar_http_get_top_autonomous_systems_by_http_version_response @httpOperation(path: "/radar/http/top/ases/http_version/{args.http_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_ip_version(ip_version: ip_version! = IPv4): radar_http_get_top_autonomous_systems_by_ip_version_response @httpOperation(path: "/radar/http/top/ases/ip_version/{args.ip_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic."
  radar_http_get_top_autonomous_systems_by_tls_version(tls_version: tls_version! = TLSv1_0): radar_http_get_top_autonomous_systems_by_tls_version_response @httpOperation(path: "/radar/http/top/ases/tls_version/{args.tls_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic."
  radar_http_get_top_user_agents_aggregated_in_families_by_http_requests: radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_response @httpOperation(path: "/radar/http/top/browser_families", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic."
  radar_http_get_top_user_agents_by_http_requests: radar_http_get_top_user_agents_by_http_requests_response @httpOperation(path: "/radar/http/top/browsers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations by HTTP traffic. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_http_requests: radar_http_get_top_locations_by_http_requests_response @httpOperation(path: "/radar/http/top/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_bot_class(bot_class: bot_class! = LIKELY_AUTOMATED): radar_http_get_top_locations_by_bot_class_response @httpOperation(path: "/radar/http/top/locations/bot_class/{args.bot_class}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_device_type(device_type: device_type! = DESKTOP): radar_http_get_top_locations_by_device_type_response @httpOperation(path: "/radar/http/top/locations/device_type/{args.device_type}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_http_protocol(http_protocol: http_protocol! = HTTP): radar_http_get_top_locations_by_http_protocol_response @httpOperation(path: "/radar/http/top/locations/http_protocol/{args.http_protocol}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_http_version(http_version: http_version! = HTTPv1): radar_http_get_top_locations_by_http_version_response @httpOperation(path: "/radar/http/top/locations/http_version/{args.http_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_ip_version(ip_version: ip_version! = IPv4): radar_http_get_top_locations_by_ip_version_response @httpOperation(path: "/radar/http/top/locations/ip_version/{args.ip_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic."
  radar_http_get_top_locations_by_tls_version(tls_version: tls_version! = TLSv1_0): radar_http_get_top_locations_by_tls_version_response @httpOperation(path: "/radar/http/top/locations/tls_version/{args.tls_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get network traffic change over time. Values are normalized using min-max by default, with the minimum set to 0. When asking for multiple time series, you can also get the percentage relative change of the first/main series, with respect to the second/control series - for example, to get the relative change of this week from the previous week, the first series would have a date range of \`7d\`, the second, a date range of \`7dControl\`, and the normalization would be set to \`PERCENTAGE_CHANGE\`."
  radar_net_flows_get_net_flow_time_series: radar_net_flows_get_net_flow_time_series_response @httpOperation(path: "/radar/netflows/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top autonomous systems (AS) by network traffic. Values are a percentage out of the total network traffic."
  radar_net_flows_get_top_autonomous_systems: radar_net_flows_get_top_autonomous_systems_response @httpOperation(path: "/radar/netflows/top/ases", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the top locations by network traffic. Values are a percentage out of the total network traffic."
  radar_net_flows_get_top_locations: radar_net_flows_get_top_locations_response @httpOperation(path: "/radar/netflows/top/locations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets Domains Rank updates change over time. Raw values are returned."
  radar_ranking_get_domains_rank_time_series: radar_ranking_get_domains_rank_time_series_response @httpOperation(path: "/radar/ranking/timeseries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets Top Domains Rank globally or by country."
  radar_ranking_get_domains_rank_top: radar_ranking_get_domains_rank_top_response @httpOperation(path: "/radar/ranking/top", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lets you search for locations, autonomous systems (AS) and reports."
  radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports: radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_response @httpOperation(path: "/radar/search/global", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a list of Special Events."
  radar_specialevents_list_special_events: radar_specialevents_list_special_events_response @httpOperation(path: "/radar/specialevents", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get a single Special Event."
  radar_specialevents_get_a_single_special_events(
    "Special Event alias"
    eventAlias: String!
  ): radar_specialevents_get_a_single_special_events_response @httpOperation(path: "/radar/specialevents/{args.eventAlias}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Special Events time series"
  radar_specialevents_get_special_events_time_series(
    "Special Event alias"
    eventAlias: String!
    "Special Event Category alias"
    categoryAlias: String!
  ): radar_specialevents_get_special_events_time_series_response @httpOperation(path: "/radar/specialevents/{args.eventAlias}/{args.categoryAlias}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get top verified bots by HTTP requests, with owner and category."
  radar_verified_bots_get_top_verified_bots_by_http_requests: radar_verified_bots_get_top_verified_bots_by_http_requests_response @httpOperation(path: "/radar/verified_bots/top/bots", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get top verified bot categories by HTTP requests, along with their corresponding percentage, over the total verified bot HTTP requests."
  radar_verified_bots_get_top_verified_bot_categories_by_http_requests: radar_verified_bots_get_top_verified_bot_categories_by_http_requests_response @httpOperation(path: "/radar/verified_bots/top/categories", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, sort and filter your Railguns."
  railgun_list_railguns: railgun_list_railguns_response @httpOperation(path: "/railguns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Railgun details"
  railgun_railgun_details(
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): railgun_railgun_details_response @httpOperation(path: "/railguns/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List the zones that are currently using this Railgun."
  railgun_list_railgun_zones(
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): railgun_list_railgun_zones_response @httpOperation(path: "/railguns/{args.identifier}/zones", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "User Details"
  user_user_details: user_user_details_response @httpOperation(path: "/user", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a list of audit logs for a user account. The list can be filtered by who made the change, which zone was the change made on, and the timeframe of the change."
  audit_logs_get_user_audit_logs: audit_logs_get_user_audit_logs_response @httpOperation(path: "/user/audit_logs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Accesses your billing history object."
  user_billing_history_billing_history_details: user_billing_history_billing_history_details_response @httpOperation(path: "/user/billing/history", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Accesses your billing profile object."
  user_billing_profile_billing_profile_details: user_billing_profile_billing_profile_details_response @httpOperation(path: "/user/billing/profile", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches IP Access rules of the user. You can filter the results using several optional parameters."
  ip_access_rules_for_a_user_list_ip_access_rules: ip_access_rules_for_a_user_list_ip_access_rules_response @httpOperation(path: "/user/firewall/access_rules/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all invitations associated with my user."
  user_SINGLE_QUOTE__s_invites_list_invitations: user_SINGLE_QUOTE__s_invites_list_invitations_response @httpOperation(path: "/user/invites", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the details of an invitation."
  user_SINGLE_QUOTE__s_invites_invitation_details(
    "Invite identifier tag."
    identifier: invite_components_schemas_identifier
  ): user_SINGLE_QUOTE__s_invites_invitation_details_response @httpOperation(path: "/user/invites/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured monitors for a user."
  load_balancer_monitors_list_monitors: load_balancer_monitors_list_monitors_response @httpOperation(path: "/user/load_balancers/monitors", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List a single configured monitor for a user."
  load_balancer_monitors_monitor_details(identifier: String!): load_balancer_monitors_monitor_details_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of resources that reference the provided monitor."
  load_balancer_monitors_list_monitor_references(identifier: String!): load_balancer_monitors_list_monitor_references_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}/references", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured pools."
  load_balancer_pools_list_pools: load_balancer_pools_list_pools_response @httpOperation(path: "/user/load_balancers/pools", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single configured pool."
  load_balancer_pools_pool_details(identifier: String!): load_balancer_pools_pool_details_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch the latest pool health status for a single pool."
  load_balancer_pools_pool_health_details(identifier: String!): load_balancer_pools_pool_health_details_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}/health", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the list of resources that reference the provided pool."
  load_balancer_pools_list_pool_references(identifier: String!): load_balancer_pools_list_pool_references_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}/references", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the result of a previous preview operation using the provided preview_id."
  load_balancer_monitors_preview_result(preview_id: String!): load_balancer_monitors_preview_result_response @httpOperation(path: "/user/load_balancers/preview/{args.preview_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List origin health changes."
  load_balancer_healthcheck_events_list_healthcheck_events: load_balancer_healthcheck_events_list_healthcheck_events_response @httpOperation(path: "/user/load_balancing_analytics/events", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists organizations the user is associated with."
  user_SINGLE_QUOTE__s_organizations_list_organizations: user_SINGLE_QUOTE__s_organizations_list_organizations_response @httpOperation(path: "/user/organizations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets a specific organization the user is associated with."
  user_SINGLE_QUOTE__s_organizations_organization_details(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): user_SINGLE_QUOTE__s_organizations_organization_details_response @httpOperation(path: "/user/organizations/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all of a user's subscriptions."
  user_subscription_get_user_subscriptions: user_subscription_get_user_subscriptions_response @httpOperation(path: "/user/subscriptions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all access tokens you created."
  user_api_tokens_list_tokens: user_api_tokens_list_tokens_response @httpOperation(path: "/user/tokens", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Find all available permission groups."
  permission_groups_list_permission_groups: permission_groups_list_permission_groups_response @httpOperation(path: "/user/tokens/permission_groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Test whether a token works."
  user_api_tokens_verify_token: user_api_tokens_verify_token_response @httpOperation(path: "/user/tokens/verify", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about a specific token."
  user_api_tokens_token_details(identifier: JSON!): user_api_tokens_token_details_response @httpOperation(path: "/user/tokens/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists, searches, sorts, and filters your zones."
  zone_list_zones: zone_list_zones_response @httpOperation(path: "/zones", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single configured load balancer."
  load_balancers_load_balancer_details(identifier1: String!, identifier: String!): load_balancers_load_balancer_details_response @httpOperation(path: "/zones/{args.identifier1}/load_balancers/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Zone Details"
  zone_zone_details(identifier: JSON!): zone_zone_details_response @httpOperation(path: "/zones/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all Access Applications in a zone."
  zone_level_access_applications_list_access_applications(identifier: String!): zone_level_access_applications_list_access_applications_response @httpOperation(path: "/zones/{args.identifier}/access/apps", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists short-lived certificate CAs and their public keys."
  zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_response @httpOperation(path: "/zones/{args.identifier}/access/apps/ca", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches information about an Access application."
  zone_level_access_applications_get_an_access_application(identifier: String!, app_id: String!): zone_level_access_applications_get_an_access_application_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Tests if a specific user has permission to access an application."
  zone_level_access_applications_test_access_policies(identifier: String!, app_id: String!): zone_level_access_applications_test_access_policies_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.app_id}/user_policy_checks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single Access policy."
  zone_level_access_policies_get_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): zone_level_access_policies_get_an_access_policy_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a short-lived certificate CA and its public key."
  zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists Access policies configured for an application."
  zone_level_access_policies_list_access_policies(
    identifier: String!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): zone_level_access_policies_list_access_policies_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid}/policies", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all mTLS certificates."
  zone_level_access_m_tls_authentication_list_m_tls_certificates(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): zone_level_access_m_tls_authentication_list_m_tls_certificates_response @httpOperation(path: "/zones/{args.identifier}/access/certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single mTLS certificate."
  zone_level_access_m_tls_authentication_get_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_m_tls_authentication_get_an_m_tls_certificate_response @httpOperation(path: "/zones/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all Access groups."
  zone_level_access_groups_list_access_groups(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): zone_level_access_groups_list_access_groups_response @httpOperation(path: "/zones/{args.identifier}/access/groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single Access group."
  zone_level_access_groups_get_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
  ): zone_level_access_groups_get_an_access_group_response @httpOperation(path: "/zones/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all configured identity providers."
  zone_level_access_identity_providers_list_access_identity_providers(identifier: String!): zone_level_access_identity_providers_list_access_identity_providers_response @httpOperation(path: "/zones/{args.identifier}/access/identity_providers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a configured identity provider."
  zone_level_access_identity_providers_get_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
  ): zone_level_access_identity_providers_get_an_access_identity_provider_response @httpOperation(path: "/zones/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns the configuration for your Zero Trust organization."
  zone_level_zero_trust_organization_get_your_zero_trust_organization(identifier: String!): zone_level_zero_trust_organization_get_your_zero_trust_organization_response @httpOperation(path: "/zones/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all service tokens."
  zone_level_access_service_tokens_list_service_tokens(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): zone_level_access_service_tokens_list_service_tokens_response @httpOperation(path: "/zones/{args.identifier}/access/service_tokens", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of summarised aggregate metrics over a given time period."
  dns_analytics_table(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_analytics_table_response @httpOperation(path: "/zones/{args.identifier}/dns_analytics/report", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of aggregate metrics grouped by time interval."
  dns_analytics_by_time(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_analytics_by_time_response @httpOperation(path: "/zones/{args.identifier}/dns_analytics/report/bytime", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured load balancers."
  load_balancers_list_load_balancers(identifier: String!): load_balancers_list_load_balancers_response @httpOperation(path: "/zones/{args.identifier}/load_balancers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get secondary zone configuration for incoming zone transfers."
  secondary_dns__secondary_zone_secondary_zone_configuration_details(identifier: String!): secondary_dns__secondary_zone_secondary_zone_configuration_details_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/incoming", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get primary zone configuration for outgoing zone transfers."
  secondary_dns__primary_zone_primary_zone_configuration_details(identifier: String!): secondary_dns__primary_zone_primary_zone_configuration_details_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get primary zone transfer status."
  secondary_dns__primary_zone_get_outgoing_zone_transfer_status(identifier: String!): secondary_dns__primary_zone_get_outgoing_zone_transfer_status_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing/status", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists zone subscription details."
  zone_subscription_zone_subscription_details(
    "Subscription identifier tag."
    identifier: subscription_v2_components_schemas_identifier
  ): zone_subscription_zone_subscription_details_response @httpOperation(path: "/zones/{args.identifier}/subscription", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Total TLS Settings for a Zone."
  total_tls_total_tls_settings_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): total_tls_total_tls_settings_details_response @httpOperation(path: "/zones/{args.zone_identifier}/acm/total_tls", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "This view provides a breakdown of analytics data by datacenter. Note: This is available to Enterprise customers only."
  zone_analytics__deprecated_get_analytics_by_co_locations(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_analytics__deprecated_get_analytics_by_co_locations_response @httpOperation(path: "/zones/{args.zone_identifier}/analytics/colos", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "The dashboard view provides both totals and timeseries data for the given zone and time period across the entire Cloudflare network."
  zone_analytics__deprecated_get_dashboard(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_analytics__deprecated_get_dashboard_response @httpOperation(path: "/zones/{args.zone_identifier}/analytics/dashboard", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Argo Analytics for a zone"
  argo_analytics_for_zone_argo_analytics_for_a_zone(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): argo_analytics_for_zone_argo_analytics_for_a_zone_response @httpOperation(path: "/zones/{args.zone_identifier}/analytics/latency", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Argo Analytics for a zone at different PoPs"
  argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps_response @httpOperation(path: "/zones/{args.zone_identifier}/analytics/latency/colos", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Argo Smart Routing setting"
  argo_smart_routing_get_argo_smart_routing_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): argo_smart_routing_get_argo_smart_routing_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/argo/smart_routing", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists available plans the zone can subscribe to."
  zone_rate_plan_list_available_plans(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_rate_plan_list_available_plans_response @httpOperation(path: "/zones/{args.zone_identifier}/available_plans", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Details of the available plan that the zone can subscribe to."
  zone_rate_plan_available_plan_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    plan_identifier: common_components_schemas_identifier
  ): zone_rate_plan_available_plan_details_response @httpOperation(path: "/zones/{args.zone_identifier}/available_plans/{args.plan_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all rate plans the zone can subscribe to."
  zone_rate_plan_list_available_rate_plans(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_rate_plan_list_available_rate_plans_response @httpOperation(path: "/zones/{args.zone_identifier}/available_rate_plans", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information."
  zone_cache_settings_get_cache_reserve_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_cache_settings_get_cache_reserve_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/cache/cache_reserve", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers."
  zone_cache_settings_get_variants_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_cache_settings_get_variants_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/cache/variants", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates."
  custom_ssl_for_a_zone_list_ssl_configurations(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): custom_ssl_for_a_zone_list_ssl_configurations_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "SSL Configuration Details"
  custom_ssl_for_a_zone_ssl_configuration_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom certificate identifier tag."
    identifier: custom_certificate_components_schemas_identifier
  ): custom_ssl_for_a_zone_ssl_configuration_details_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, sort, and filter all of your custom hostnames."
  custom_hostname_for_a_zone_list_custom_hostnames(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): custom_hostname_for_a_zone_list_custom_hostnames_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Fallback Origin for Custom Hostnames"
  custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/fallback_origin", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Custom Hostname Details"
  custom_hostname_for_a_zone_custom_hostname_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom hostname identifier tag."
    identifier: custom_hostname_components_schemas_identifier
  ): custom_hostname_for_a_zone_custom_hostname_details_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Account Custom Nameserver Related Zone Metadata"
  account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_ns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all the custom pages at the zone level."
  custom_pages_for_a_zone_list_custom_pages(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): custom_pages_for_a_zone_list_custom_pages_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_pages", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a custom page."
  custom_pages_for_a_zone_get_a_custom_page(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: custom_pages_components_schemas_identifier
  ): custom_pages_for_a_zone_get_a_custom_page_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_pages/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List, search, sort, and filter a zones' DNS records."
  dns_records_for_a_zone_list_dns_records(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): dns_records_for_a_zone_list_dns_records_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file \\"Zone file\\") through this endpoint."
  dns_records_for_a_zone_export_dns_records(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): dns_records_for_a_zone_export_dns_records_4xx_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/export", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "DNS Record Details"
  dns_records_for_a_zone_dns_record_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "DNS record identifier tag."
    identifier: dns_record_components_schemas_identifier
  ): dns_records_for_a_zone_dns_record_details_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Details about DNSSEC status and configuration."
  dnssec_dnssec_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): dnssec_dnssec_details_response @httpOperation(path: "/zones/{args.zone_identifier}/dnssec", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information about the settings for your Email Routing zone."
  email_routing_settings_get_email_routing_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_settings_get_email_routing_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Show the DNS records needed to configure your Email Routing zone."
  email_routing_settings_email_routing_dns_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_settings_email_routing_dns_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/dns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists existing routing rules."
  email_routing_routing_rules_list_routing_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_routing_rules_list_routing_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information on the default catch-all routing rule."
  email_routing_routing_rules_get_catch_all_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_routing_rules_get_catch_all_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules/catch_all", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get information for a specific routing rule already created."
  email_routing_routing_rules_get_routing_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Routing rule identifier."
    rule_identifier: rule_identifier
  ): email_routing_routing_rules_get_routing_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches filters in a zone. You can filter the results using several optional parameters."
  filters_list_filters(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): filters_list_filters_response @httpOperation(path: "/zones/{args.zone_identifier}/filters", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a filter."
  filters_get_a_filter(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the filter."
    id: filters_components_schemas_id
  ): filters_get_a_filter_response @httpOperation(path: "/zones/{args.zone_identifier}/filters/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches Zone Lockdown rules. You can filter the results using several optional parameters."
  zone_lockdown_list_zone_lockdown_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_lockdown_list_zone_lockdown_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/lockdowns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a Zone Lockdown rule."
  zone_lockdown_get_a_zone_lockdown_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the Zone Lockdown rule."
    id: lockdowns_components_schemas_id
  ): zone_lockdown_get_a_zone_lockdown_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/lockdowns/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches firewall rules in a zone. You can filter the results using several optional parameters."
  firewall_rules_list_firewall_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): firewall_rules_list_firewall_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a firewall rule."
  firewall_rules_get_a_firewall_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the firewall rule."
    id: firewall_rules_components_schemas_id
  ): firewall_rules_get_a_firewall_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches User Agent Blocking rules in a zone. You can filter the results using several optional parameters."
  user_agent_blocking_rules_list_user_agent_blocking_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): user_agent_blocking_rules_list_user_agent_blocking_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/ua_rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a User Agent Blocking rule."
  user_agent_blocking_rules_get_a_user_agent_blocking_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the User Agent Blocking rule."
    id: ua_rules_components_schemas_id
  ): user_agent_blocking_rules_get_a_user_agent_blocking_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/ua_rules/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the URI-based WAF overrides in a zone."
  waf_overrides_list_waf_overrides(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): waf_overrides_list_waf_overrides_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/overrides", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a URI-based WAF override."
  waf_overrides_get_a_waf_override(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the WAF override."
    id: overrides_components_schemas_id
  ): waf_overrides_get_a_waf_override_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/overrides/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches WAF packages for a zone."
  waf_packages_list_waf_packages(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): waf_packages_list_waf_packages_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a WAF package."
  waf_packages_get_a_waf_package(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    identifier: package_components_schemas_identifier
  ): waf_packages_get_a_waf_package_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the WAF rule groups in a WAF package."
  waf_rule_groups_list_waf_rule_groups(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_identifier: package_components_schemas_identifier
  ): waf_rule_groups_list_waf_rule_groups_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages/{args.package_identifier}/groups", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a WAF rule group."
  waf_rule_groups_get_a_waf_rule_group(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_identifier: package_components_schemas_identifier
    "The unique identifier of the rule group."
    identifier: group_components_schemas_identifier
  ): waf_rule_groups_get_a_waf_rule_group_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages/{args.package_identifier}/groups/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List configured health checks."
  health_checks_list_health_checks(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): health_checks_list_health_checks_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single configured health check preview."
  health_checks_health_check_preview_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
  ): health_checks_health_check_preview_details_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/preview/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch a single configured health check."
  health_checks_health_check_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
  ): health_checks_health_check_details_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List all Keyless SSL configurations for a given zone."
  keyless_ssl_for_a_zone_list_keyless_ssl_configurations(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): keyless_ssl_for_a_zone_list_keyless_ssl_configurations_response @httpOperation(path: "/zones/{args.zone_identifier}/keyless_certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get details for one Keyless SSL configuration."
  keyless_ssl_for_a_zone_get_keyless_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Keyless certificate identifier tag."
    identifier: keyless_certificate_components_schemas_identifier
  ): keyless_ssl_for_a_zone_get_keyless_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/keyless_certificates/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions."
  logpush_jobs_list_fields(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    dataset: dataset!
  ): logpush_jobs_list_fields_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/datasets/{args.dataset}/fields", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists Logpush jobs for a zone for a dataset."
  logpush_jobs_list_logpush_jobs_for_a_dataset(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    dataset: dataset!
  ): logpush_jobs_list_logpush_jobs_for_a_dataset_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/datasets/{args.dataset}/jobs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists Logpush jobs for a zone."
  logpush_jobs_list_logpush_jobs(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): logpush_jobs_list_logpush_jobs_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/jobs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the details of a Logpush job."
  logpush_jobs_get_logpush_job_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Unique id of the job."
    job_identifier: PositiveInt!
  ): logpush_jobs_get_logpush_job_details_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/jobs/{args.job_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets log retention flag for Logpull API."
  logs_received_get_log_retention_flag(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): logs_received_get_log_retention_flag_response @httpOperation(path: "/zones/{args.zone_identifier}/logs/control/retention/flag", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "The \`/rayids\` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique)."
  logs_received_get_logs_ray_i_ds(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Ray identifier."
    ray_identifier: ray_identifier
  ): logs_received_get_logs_ray_i_ds_response @httpOperation(path: "/zones/{args.zone_identifier}/logs/rayids/{args.ray_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "The \`/received\` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is \\"give me all the logs for zone Z for minute M\\", where the minute M refers to the time records were received at Cloudflare's central data center. \`start\` is inclusive, and \`end\` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: \`start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z\`, then \`start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z\` and so on; the overlap will be handled properly."
  logs_received_get_logs_received(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): logs_received_get_logs_received_response @httpOperation(path: "/zones/{args.zone_identifier}/logs/received", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions."
  logs_received_list_fields(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): logs_received_list_fields_response @httpOperation(path: "/zones/{args.zone_identifier}/logs/received/fields", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Certificates"
  zone_level_authenticated_origin_pulls_list_certificates(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_level_authenticated_origin_pulls_list_certificates_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Certificates"
  per_hostname_authenticated_origin_pull_list_certificates(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): per_hostname_authenticated_origin_pull_list_certificates_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames/certificates", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the certificate by ID to be used for client authentication on a hostname."
  per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Certificate identifier tag."
    identifier: hostname_authenticated_origin_pull_components_schemas_identifier
  ): per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames/certificates/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get the Hostname Status for Client Authentication"
  per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The hostname on the origin for which the client certificate uploaded will be used."
    hostname: schemas_hostname!
  ): per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames/{args.hostname}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get whether zone-level authenticated origin pulls is enabled or not. It is false by default."
  zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Certificate Details"
  zone_level_authenticated_origin_pulls_get_certificate_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Certificate identifier tag."
    identifier: zone_authenticated_origin_pull_components_schemas_identifier
  ): zone_level_authenticated_origin_pulls_get_certificate_details_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches Page Rules in a zone."
  page_rules_list_page_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): page_rules_list_page_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Returns a list of settings (and their details) that Page Rules can apply to matching requests."
  available_page_rules_settings_list_available_page_rules_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): available_page_rules_settings_list_available_page_rules_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules/settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a Page Rule."
  page_rules_get_a_page_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): page_rules_get_a_page_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "A list of available Railguns the zone can use."
  railgun_connections_for_a_zone_list_available_railguns(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): railgun_connections_for_a_zone_list_available_railguns_response @httpOperation(path: "/zones/{args.zone_identifier}/railguns", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists details about a specific Railgun."
  railgun_connections_for_a_zone_railgun_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Railgun connection identifier tag."
    identifier: railgun_components_schemas_identifier_2
  ): railgun_connections_for_a_zone_railgun_details_response @httpOperation(path: "/zones/{args.zone_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Tests the Railgun connection to the zone."
  railgun_connections_for_a_zone_test_railgun_connection(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Railgun connection identifier tag."
    identifier: railgun_components_schemas_identifier_2
  ): railgun_connections_for_a_zone_test_railgun_connection_response @httpOperation(path: "/zones/{args.zone_identifier}/railguns/{args.identifier}/diagnose", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the rate limits for a zone."
  rate_limits_for_a_zone_list_rate_limits(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): rate_limits_for_a_zone_list_rate_limits_response @httpOperation(path: "/zones/{args.zone_identifier}/rate_limits", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a rate limit."
  rate_limits_for_a_zone_get_a_rate_limit(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the rate limit."
    id: rate_limits_components_schemas_id
  ): rate_limits_for_a_zone_get_a_rate_limit_response @httpOperation(path: "/zones/{args.zone_identifier}/rate_limits/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Available settings for your user in relation to a zone."
  zone_settings_get_all_zone_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_all_zone_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets 0-RTT session resumption setting."
  zone_settings_get_0_rtt_session_resumption_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_0_rtt_session_resumption_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/0rtt", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones."
  zone_settings_get_advanced_ddos_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_advanced_ddos_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/advanced_ddos", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
  zone_settings_get_always_online_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_always_online_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/always_online", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
  zone_settings_get_always_use_https_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_always_use_https_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/always_use_https", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enable the Automatic HTTPS Rewrites feature for this zone."
  zone_settings_get_automatic_https_rewrites_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_automatic_https_rewrites_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/automatic_https_rewrites", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts."
  zone_settings_get_automatic_platform_optimization_for_word_press_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_automatic_platform_optimization_for_word_press_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/automatic_platform_optimization", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
  zone_settings_get_brotli_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_brotli_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/brotli", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
  zone_settings_get_browser_cache_ttl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_browser_cache_ttl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/browser_cache_ttl", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
  zone_settings_get_browser_check_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_browser_check_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/browser_check", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
  zone_settings_get_cache_level_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_cache_level_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/cache_level", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
  zone_settings_get_challenge_ttl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_challenge_ttl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/challenge_ttl", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets ciphers setting."
  zone_settings_get_ciphers_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_ciphers_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ciphers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
  zone_settings_get_development_mode_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_development_mode_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/development_mode", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
  zone_settings_get_early_hints_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_early_hints_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/early_hints", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
  zone_settings_get_email_obfuscation_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_email_obfuscation_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/email_obfuscation", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets HTTP/2 Edge Prioritization setting."
  zone_settings_get_http__2_edge_prioritization_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_http__2_edge_prioritization_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/h2_prioritization", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
  zone_settings_get_hotlink_protection_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_hotlink_protection_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/hotlink_protection", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Value of the HTTP2 setting."
  zone_settings_get_h_t_t_p_2_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_h_t_t_p_2_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/http2", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Value of the HTTP3 setting."
  zone_settings_get_h_t_t_p_3_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_h_t_t_p_3_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/http3", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
  zone_settings_get_image_resizing_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_image_resizing_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/image_resizing", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
  zone_settings_get_ip_geolocation_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_ip_geolocation_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ip_geolocation", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
  zone_settings_get_i_pv6_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_i_pv6_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ipv6", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets Minimum TLS Version setting."
  zone_settings_get_minimum_tls_version_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_minimum_tls_version_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/min_tls_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
  zone_settings_get_minify_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_minify_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/minify", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
  zone_settings_get_mirage_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_mirage_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/mirage", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
  zone_settings_get_mobile_redirect_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_mobile_redirect_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/mobile_redirect", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enable Network Error Logging reporting on your zone. (Beta) "
  zone_settings_get_network_error_logging_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_network_error_logging_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/nel", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets Opportunistic Encryption setting."
  zone_settings_get_opportunistic_encryption_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_opportunistic_encryption_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/opportunistic_encryption", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
  zone_settings_get_opportunistic_onion_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_opportunistic_onion_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/opportunistic_onion", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
  zone_settings_get_orange_to_orange__o_2_o(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_orange_to_orange__o_2_o_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/orange_to_orange", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
  zone_settings_get_enable_error_pages_on_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_enable_error_pages_on_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/origin_error_page_pass_thru", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Value of the Origin Max HTTP version setting (Note that the default value for Enterprise is \\"1\\")."
  zone_settings_get_origin_max_http_version_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_origin_max_http_version_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/origin_max_http_version", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
  zone_settings_get_polish_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_polish_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/polish", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
  zone_settings_get_prefetch_preload_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_prefetch_preload_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/prefetch_preload", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
  zone_settings_get_privacy_pass_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_privacy_pass_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/privacy_pass", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Maximum time between two read operations from origin."
  zone_settings_get_proxy_read_timeout_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_proxy_read_timeout_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/proxy_read_timeout", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Value of the Pseudo IPv4 setting."
  zone_settings_get_pseudo_i_pv4_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_pseudo_i_pv4_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/pseudo_ipv4", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
  zone_settings_get_response_buffering_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_response_buffering_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/response_buffering", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
  zone_settings_get_rocket_loader_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_rocket_loader_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/rocket_loader", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Cloudflare security header for a zone."
  zone_settings_get_security_header__hsts_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_security_header__hsts_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/security_header", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
  zone_settings_get_security_level_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_security_level_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/security_level", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
  zone_settings_get_server_side_exclude_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_server_side_exclude_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/server_side_exclude", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
  zone_settings_get_enable_query_string_sort_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_enable_query_string_sort_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/sort_query_string_for_cache", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
  zone_settings_get_ssl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_ssl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ssl", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
  zone_settings_get_ssl__tls_recommender_enrollment(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_ssl__tls_recommender_enrollment_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ssl_recommender", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets TLS 1.3 setting enabled for a zone."
  zone_settings_get_tls_1__3_setting_enabled_for_a_zone(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_tls_1__3_setting_enabled_for_a_zone_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/tls_1_3", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
  zone_settings_get_tls_client_auth_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_tls_client_auth_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/tls_client_auth", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
  zone_settings_get_true_client_ip_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_true_client_ip_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/true_client_ip_header", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
  zone_settings_get_web_application_firewall__waf_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_web_application_firewall__waf_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/waf", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
  zone_settings_get_web_p_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_web_p_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/webp", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets)."
  zone_settings_get_web_sockets_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_settings_get_web_sockets_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/websockets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "For a given zone, list all active certificate packs."
  certificate_packs_list_certificate_packs(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): certificate_packs_list_certificate_packs_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "For a given zone, list certificate pack quotas."
  certificate_packs_get_certificate_pack_quotas(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): certificate_packs_get_certificate_pack_quotas_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs/quota", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "For a given zone, get a certificate pack."
  certificate_packs_get_certificate_pack(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier for a certificate_pack."
    identifier: String
  ): certificate_packs_get_certificate_pack_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve the SSL/TLS Recommender's recommendation for a zone."
  ssl__tls_mode_recommendation_ssl__tls_recommendation(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): ssl__tls_mode_recommendation_ssl__tls_recommendation_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/recommendation", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Universal SSL Settings for a Zone."
  universal_ssl_settings_for_a_zone_universal_ssl_settings_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): universal_ssl_settings_for_a_zone_universal_ssl_settings_details_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/universal/settings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get SSL Verification Info for a Zone."
  ssl_verification_ssl_verification_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): ssl_verification_ssl_verification_details_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/verification", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists waiting rooms."
  waiting_room_list_waiting_rooms(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): waiting_room_list_waiting_rooms_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single configured waiting room."
  waiting_room_waiting_room_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
  ): waiting_room_waiting_room_details_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists events for a waiting room."
  waiting_room_list_events(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
  ): waiting_room_list_events_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a single configured event for a waiting room."
  waiting_room_event_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    event_id: String!
  ): waiting_room_event_details_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events/{args.event_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values."
  waiting_room_preview_active_event_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    event_id: String!
  ): waiting_room_preview_active_event_details_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events/{args.event_id}/details", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists rules for a waiting room."
  waiting_room_list_waiting_room_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
  ): waiting_room_list_waiting_room_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the status of a configured waiting room. Response fields include:\\n1. \`status\`: String indicating the status of the waiting room. The possible status are:\\n\\t- **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.\\n\\t- **queueing** indicates that the thresholds have been met and some users are held in the waiting room.\\n\\t- **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts.\\n2. \`event_id\`: String of the current event's \`id\` if an event is active, otherwise an empty string.\\n3. \`estimated_queued_users\`: Integer of the estimated number of users currently waiting in the queue.\\n4. \`estimated_total_active_users\`: Integer of the estimated number of users currently active on the origin.\\n5. \`max_estimated_time_minutes\`: Integer of the maximum estimated time currently presented to the users."
  waiting_room_get_waiting_room_status(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
  ): waiting_room_get_waiting_room_status_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/status", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Web3 Hostnames"
  web3_hostname_list_web3_hostnames(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): web3_hostname_list_web3_hostnames_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Web3 Hostname Details"
  web3_hostname_web3_hostname_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): web3_hostname_web3_hostname_details_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "IPFS Universal Path Gateway Content List Details"
  web3_hostname_ipfs_universal_path_gateway_content_list_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): web3_hostname_ipfs_universal_path_gateway_content_list_details_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List IPFS Universal Path Gateway Content List Entries"
  web3_hostname_list_ipfs_universal_path_gateway_content_list_entries(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list/entries", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "IPFS Universal Path Gateway Content List Entry Details"
  web3_hostname_ipfs_universal_path_gateway_content_list_entry_details(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    "Identifier"
    content_list_entry_identifier: common_components_schemas_identifier
  ): web3_hostname_ipfs_universal_path_gateway_content_list_entry_details_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list/entries/{args.content_list_entry_identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetch raw script content for your worker. Note this is the original script content, not JSON encoded."
  worker_script__deprecated_download_worker(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): String_container @httpOperation(path: "/zones/{args.zone_identifier}/workers/script", operationSpecificHeaders: "{\\"accept\\":\\"undefined\\"}", httpMethod: GET)
  "List the bindings for a Workers script."
  worker_binding__deprecated_list_bindings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): worker_binding__deprecated_list_bindings_response @httpOperation(path: "/zones/{args.zone_identifier}/workers/script/bindings", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve information about specific configuration properties"
  api_shield_settings_retrieve_information_about_specific_configuration_properties(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): api_shield_settings_retrieve_information_about_specific_configuration_properties_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/configuration", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve the most up to date view of API Discovery on a zone."
  api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/discovery", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve information about all operations on a zone"
  api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/operations", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve information about an operation"
  api_shield_endpoint_management_retrieve_information_about_an_operation(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The ID that identifies the API operation."
    operation_id: JSON!
  ): api_shield_endpoint_management_retrieve_information_about_an_operation_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/operations/{args.operation_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieve operations and features as OpenAPI schemas"
  api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/schemas", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches IP Access rules of a zone. You can filter the results using several optional parameters."
  ip_access_rules_for_a_zone_list_ip_access_rules(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): ip_access_rules_for_a_zone_list_ip_access_rules_response @httpOperation(path: "/zones/{args.zone_id}/firewall/access_rules/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches WAF rules in a WAF package."
  waf_rules_list_waf_rules(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_id: package_components_schemas_identifier
  ): waf_rules_list_waf_rules_response @httpOperation(path: "/zones/{args.zone_id}/firewall/waf/packages/{args.package_id}/rules", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the details of a WAF rule in a WAF package."
  waf_rules_get_a_waf_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_id: package_components_schemas_identifier
    "The unique identifier of the WAF rule."
    identifier: rule_components_schemas_identifier_2
  ): waf_rules_get_a_waf_rule_response @httpOperation(path: "/zones/{args.zone_id}/firewall/waf/packages/{args.package_id}/rules/{args.identifier}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a list of all Managed Transforms."
  managed_transforms_list_managed_transforms(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): managed_transforms_list_managed_transforms_response @httpOperation(path: "/zones/{args.zone_id}/managed_headers", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the Page Shield settings."
  page_shield_get_page_shield_settings(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): page_shield_get_page_shield_settings_response @httpOperation(path: "/zones/{args.zone_id}/page_shield", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all connections detected by Page Shield."
  page_shield_list_page_shield_connections(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): page_shield_list_page_shield_connections_response @httpOperation(path: "/zones/{args.zone_id}/page_shield/connections", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a connection detected by Page Shield by connection ID."
  page_shield_get_a_page_shield_connection(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The ID of the resource."
    id: script_monitor_components_schemas_id!
  ): page_shield_get_a_page_shield_connection_response @httpOperation(path: "/zones/{args.zone_id}/page_shield/connections/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Lists all scripts detected by Page Shield."
  page_shield_list_page_shield_scripts(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): page_shield_list_page_shield_scripts_response @httpOperation(path: "/zones/{args.zone_id}/page_shield/scripts", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a script detected by Page Shield by script ID."
  page_shield_get_a_page_shield_script(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The ID of the resource."
    id: script_monitor_components_schemas_id!
  ): page_shield_get_a_page_shield_script_response @httpOperation(path: "/zones/{args.zone_id}/page_shield/scripts/{args.id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all rulesets at the zone level."
  zone_rulesets_list_zone_rulesets(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): zone_rulesets_list_zone_rulesets_response @httpOperation(path: "/zones/{args.zone_id}/rulesets", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all Custom Error Responses in a zone."
  custom_error_responses_get_custom_error_responses(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): custom_error_responses_get_custom_error_responses_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/http_custom_errors/entrypoint", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches all Transform Rules in a zone."
  transform_rules_list_transform_rules(
    "Identifier"
    zone_id: common_components_schemas_identifier
    phase: schemas_phase!
  ): transform_rules_list_transform_rules_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.phase}/entrypoint", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the latest version of the zone entry point ruleset for a given phase."
  zone_rulesets_get_a_zone_entry_point_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_phase: phase!
  ): zone_rulesets_get_a_zone_entry_point_ruleset_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.ruleset_phase}/entrypoint", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the versions of a zone entry point ruleset."
  zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_phase: phase!
  ): zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.ruleset_phase}/versions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a specific version of a zone entry point ruleset."
  zone_rulesets_get_a_zone_entry_point_ruleset_version(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_phase: phase!
    ruleset_version: version!
  ): zone_rulesets_get_a_zone_entry_point_ruleset_version_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.ruleset_phase}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the latest version of a zone ruleset."
  zone_rulesets_get_a_zone_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): zone_rulesets_get_a_zone_ruleset_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the versions of a zone ruleset."
  zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/versions", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches a specific version of a zone ruleset."
  zone_rulesets_get_a_zone_ruleset_version(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    ruleset_version: version!
  ): zone_rulesets_get_a_zone_ruleset_version_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Fetches the current URL normalization settings."
  url_normalization_get_url_normalization_settings(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): url_normalization_get_url_normalization_settings_response @httpOperation(path: "/zones/{args.zone_id}/url_normalization", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Filters"
  worker_filters__deprecated_list_filters(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): worker_filters__deprecated_list_filters_response @httpOperation(path: "/zones/{args.zone_id}/workers/filters", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "List Routes"
  worker_routes_list_routes(
    "Identifier"
    zone_id: common_components_schemas_identifier
  ): worker_routes_list_routes_response @httpOperation(path: "/zones/{args.zone_id}/workers/routes", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Get Route"
  worker_routes_get_route(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "Identifier"
    route_id: common_components_schemas_identifier
  ): worker_routes_get_route_response @httpOperation(path: "/zones/{args.zone_id}/workers/routes/{args.route_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves analytics aggregated from the last minute of usage on Spectrum applications underneath a given zone."
  spectrum_aggregate_analytics_get_current_aggregated_analytics(
    "Identifier"
    zone: common_components_schemas_identifier
  ): spectrum_aggregate_analytics_get_current_aggregated_analytics_response @httpOperation(path: "/zones/{args.zone}/spectrum/analytics/aggregate/current", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of aggregate metrics grouped by time interval."
  spectrum_analytics__by_time_get_analytics_by_time(
    "Identifier"
    zone: common_components_schemas_identifier
  ): spectrum_analytics__by_time_get_analytics_by_time_response @httpOperation(path: "/zones/{args.zone}/spectrum/analytics/events/bytime", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of summarised aggregate metrics over a given time period."
  spectrum_analytics__summary_get_analytics_summary(
    "Identifier"
    zone: common_components_schemas_identifier
  ): spectrum_analytics__summary_get_analytics_summary_response @httpOperation(path: "/zones/{args.zone}/spectrum/analytics/events/summary", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Retrieves a list of currently existing Spectrum applications inside a zone."
  spectrum_applications_list_spectrum_applications(
    "Identifier"
    zone: common_components_schemas_identifier
  ): spectrum_applications_list_spectrum_applications_response @httpOperation(path: "/zones/{args.zone}/spectrum/apps", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
  "Gets the application configuration of a specific application inside a zone."
  spectrum_applications_get_spectrum_application_configuration(
    "Identifier"
    zone: common_components_schemas_identifier
    "Application identifier."
    app_id: app_id
  ): spectrum_applications_get_spectrum_application_configuration_response @httpOperation(path: "/zones/{args.zone}/spectrum/apps/{args.app_id}", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: GET)
}

union accounts_list_accounts_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "accounts_list_accounts_4xx_response") = api_response_collection | accounts_list_accounts_4xx_response

type api_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items {
  code: PositiveInt!
  message: String!
}

"Integers that will have a value greater than 0."
scalar PositiveInt

"The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type result_info {
  "Total number of results for the requested service"
  count: Float
  "Current page within paginated list of results"
  page: Float
  "Number of results per page of results"
  per_page: Float
  "Total results available without any search parameters"
  total_count: Float
}

type accounts_list_accounts_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Represents empty values"
scalar Void

union ip_address_management_address_maps_list_address_maps_response @statusCodeTypeName(statusCode: 200, typeName: "address_maps_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_list_address_maps_4xx_response") = address_maps_components_schemas_response_collection | ip_address_management_address_maps_list_address_maps_4xx_response

type address_maps_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [address_maps]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type address_maps {
  "If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps."
  can_delete: Boolean
  "If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps."
  can_modify_ips: Boolean
  created_at: DateTime
  "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account."
  default_sni: String
  "An optional description field which may be used to describe the types of IPs or zones on the map."
  description: String
  "Identifier"
  id: common_components_schemas_identifier!
  modified_at: DateTime
}

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the \`date-time\` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar."
scalar DateTime

"Identifier"
scalar common_components_schemas_identifier @length(min: null, max: 32)

type ip_address_management_address_maps_list_address_maps_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_address_map_details_response @statusCodeTypeName(statusCode: 200, typeName: "full_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_address_map_details_4xx_response") = full_response | ip_address_management_address_maps_address_map_details_4xx_response

type full_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_1_result {
  "If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps."
  can_delete: Boolean
  "If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps."
  can_modify_ips: Boolean
  created_at: DateTime
  "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account."
  default_sni: String
  "An optional description field which may be used to describe the types of IPs or zones on the map."
  description: String
  "Identifier"
  id: common_components_schemas_identifier!
  modified_at: DateTime
  "The set of IPs on the Address Map."
  ips: [address_maps_ip]
  "Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership."
  memberships: [address_maps_membership]
}

type address_maps_ip {
  created_at: DateTime
  "An IPv4 or IPv6 address."
  ip: String
}

type address_maps_membership {
  "Controls whether the membership can be deleted via the API or not."
  can_delete: Boolean
  created_at: DateTime
  "Identifier"
  identifier: common_components_schemas_identifier!
  kind: components_schemas_kind
}

"The type of the membership."
enum components_schemas_kind {
  zone
  account
}

type ip_address_management_address_maps_address_map_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

type ip_address_management_prefixes_download_loa_document_4xx_response {
  JSON: JSON @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Identifier for the uploaded LOA document."
scalar loa_document_identifier @length(min: null, max: 32)

union ip_address_management_prefixes_list_prefixes_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_prefixes_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_list_prefixes_4xx_response") = ipam_prefixes_components_schemas_response_collection | ip_address_management_prefixes_list_prefixes_4xx_response

type ipam_prefixes_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ipam_prefixes]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ipam_prefixes {
  "Identifier"
  account_id: common_components_schemas_identifier!
  "Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled."
  advertised: Boolean
  "Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled."
  advertised_modified_at: DateTime
  "Approval state of the prefix (P = pending, V = active)."
  approved: String
  "Autonomous System Number (ASN) the prefix will be advertised under."
  asn: Int
  "IP Prefix in Classless Inter-Domain Routing format."
  cidr: String
  created_at: DateTime
  "Description of the prefix."
  description: ipam_prefixes_components_schemas_description
  "Identifier"
  id: common_components_schemas_identifier!
  "Identifier for the uploaded LOA document."
  loa_document_id: loa_document_identifier!
  modified_at: DateTime
  "Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled."
  on_demand_enabled: Boolean
  "Whether advertisement status of the prefix is locked, meaning it cannot be changed."
  on_demand_locked: Boolean
}

"Description of the prefix."
scalar ipam_prefixes_components_schemas_description @length(min: null, max: 1000)

type ip_address_management_prefixes_list_prefixes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_prefixes_prefix_details_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_prefixes_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_prefix_details_4xx_response") = ipam_prefixes_components_schemas_single_response | ip_address_management_prefixes_prefix_details_4xx_response

type ipam_prefixes_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: ipam_prefixes
  "Whether the API call was successful"
  success: Boolean!
}

type ip_address_management_prefixes_prefix_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_address_management_dynamic_advertisement_get_advertisement_status_response @statusCodeTypeName(statusCode: 200, typeName: "advertised_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_dynamic_advertisement_get_advertisement_status_4xx_response") = advertised_response | ip_address_management_dynamic_advertisement_get_advertisement_status_4xx_response

type advertised_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ip_address_management_dynamic_advertisement_get_advertisement_status_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_ip_address_management_dynamic_advertisement_get_advertisement_status_oneOf_0_allOf_1_result {
  "Enablement of prefix advertisement to the Internet."
  advertised: Boolean
  "Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled."
  advertised_modified_at: DateTime
}

type ip_address_management_dynamic_advertisement_get_advertisement_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_address_management_prefix_delegation_list_prefix_delegations_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_delegations_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefix_delegation_list_prefix_delegations_4xx_response") = ipam_delegations_components_schemas_response_collection | ip_address_management_prefix_delegation_list_prefix_delegations_4xx_response

type ipam_delegations_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ipam_delegations]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ipam_delegations {
  "IP Prefix in Classless Inter-Domain Routing format."
  cidr: String
  created_at: DateTime
  "Account identifier for the account to which prefix is being delegated."
  delegated_account_id: delegated_account_identifier
  "Delegation identifier tag."
  id: delegation_identifier!
  modified_at: DateTime
  "Identifier"
  parent_prefix_id: common_components_schemas_identifier!
}

"Account identifier for the account to which prefix is being delegated."
scalar delegated_account_identifier @length(min: null, max: 32)

"Delegation identifier tag."
scalar delegation_identifier @length(min: null, max: 32)

type ip_address_management_prefix_delegation_list_prefix_delegations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union audit_logs_get_account_audit_logs_response @statusCodeTypeName(statusCode: "4xx", typeName: "audit_logs_get_account_audit_logs_4xx_response") = query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0 | api_response_common | audit_logs_get_account_audit_logs_4xx_response

type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0 {
  errors: JSON
  messages: [JSON]
  result: [audit_logs]
  success: Boolean
}

type audit_logs {
  action: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_action
  actor: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_actor
  "A string that uniquely identifies the audit log."
  id: String
  "The source of the event."
  interface: String
  metadata: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_metadata
  "The new value of the resource that was modified."
  newValue: String
  "The value of the resource before it was modified."
  oldValue: String
  owner: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_owner
  resource: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_resource
  "A UTC RFC3339 timestamp that specifies when the action being logged occured."
  when: DateTime
}

type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_action {
  "A boolean that indicates if the action attempted was successful."
  result: Boolean
  "A short string that describes the action that was performed."
  type: String
}

type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_actor {
  "The email of the user that performed the action."
  email: EmailAddress
  "The ID of the actor that performed the action. If a user performed the action, this will be their User ID."
  id: String
  "The IP address of the request that performed the action."
  ip: String
  type: query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_actor_type
}

"A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address."
scalar EmailAddress @specifiedBy(url: "https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address")

"The type of actor, whether a User, Cloudflare Admin, or an Automated System."
enum query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_actor_type {
  user
  admin
  Cloudflare
}

"An object which can lend more context to the action being logged. This is a flexible value and varies between different actions."
type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_metadata {
  name: String
  type: String
  value: String
  zone_name: String
}

type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_owner {
  "Identifier"
  id: common_components_schemas_identifier!
}

type query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0_result_items_resource {
  "An identifier for the resource that was affected by the action."
  id: String
  "A short string that describes the resource that was affected by the action."
  type: String
}

type api_response_common {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_accounts_list_accounts_oneOf_0_anyOf_0_result!
  "Whether the API call was successful"
  success: Boolean!
}

type query_accounts_list_accounts_oneOf_0_anyOf_0_result {
  JSON: JSON @resolveRoot
  String: String @resolveRoot
}

type audit_logs_get_account_audit_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_billing_profile_billing_profile_details_response @statusCodeTypeName(statusCode: 200, typeName: "billing_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_billing_profile_billing_profile_details_4xx_response") = billing_response_single | account_billing_profile_billing_profile_details_4xx_response

type billing_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type account_billing_profile_billing_profile_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_tunnel_list_cloudflare_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_list_cloudflare_tunnels_4xx_response") = schemas_tunnel_response_collection | cloudflare_tunnel_list_cloudflare_tunnels_4xx_response

type schemas_tunnel_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [tunnel]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Indicates the cloudflared enabled features for this Cloudflare Tunnel connection."
type tunnel {
  "Identifier"
  account_tag: common_components_schemas_identifier!
  "Connections between cloudflared and the Cloudflare edge that are serving this tunnel."
  connections: [cloudflare_tunnel_components_schemas_connection]
  "If present, indicates the timestamp since the tunnel had at least 1 connection active (formatted in RFC 3339). If absent, tunnel is inactive."
  conns_active_at: DateTime
  "If present, indicates since when the tunnel is without any connection established to the edge (formatted in RFC 3339). If absent, tunnel is active."
  conns_inactive_at: DateTime
  "Timestamps when the resource was created, formatted in RFC 3339."
  created_at: DateTime
  "If present, indicates tunnel was deleted at the given date (formatted in RFC 3339). If absent, tunnel has not been deleted."
  deleted_at: DateTime
  "UUID of the tunnel."
  id: tunnel_id!
  "A user-friendly name chosen when the tunnel is created. Cannot be empty."
  name: String
  "If the Cloudflare Tunnel's configuration is configured remotely (true) or locally on the origin machine (false)."
  remote_config: Boolean
  "The status of the tunnel. Could be \\"active\\", \\"inactive\\" or \\"degraded\\" (Active but not all connectors have 4 connections to the edge)."
  status: String
}

type cloudflare_tunnel_components_schemas_connection {
  "UUID of the cloudflared instance."
  client_id: JSON
  "Indicates the cloudflared version used to establish this Cloudflare Tunnel connection."
  client_version: String
  "Short ID for the colo this connection is connected to."
  colo_name: String
  "UUID of the tunnel's connection."
  id: connection_id
  "Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting. If this field is true, the connection has disconnected but is still being tracked for these optimized reconnects. If false, the connection is still actively serving."
  is_pending_reconnect: Boolean
  "Timestamp when the connection was established, formatted in RFC 3339."
  opened_at: DateTime
  "The publicly perceived IP of the host running the cloudflared instance."
  origin_ip: String
}

"UUID of the tunnel's connection."
scalar connection_id @length(min: null, max: 36)

"UUID of the tunnel."
scalar tunnel_id @length(min: null, max: 36)

type cloudflare_tunnel_list_cloudflare_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union cloudflare_tunnel_get_cloudflare_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_get_cloudflare_tunnel_4xx_response") = schemas_tunnel_response_single | cloudflare_tunnel_get_cloudflare_tunnel_4xx_response

type schemas_tunnel_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: tunnel
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_tunnel_get_cloudflare_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_tunnel_configuration_get_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "config_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_configuration_get_configuration_4xx_response") = config_response_single | cloudflare_tunnel_configuration_get_configuration_4xx_response

type config_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_tunnel_configuration_get_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_tunnel_list_cloudflare_tunnel_connections_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_connections_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_list_cloudflare_tunnel_connections_4xx_response") = tunnel_connections_response | cloudflare_tunnel_list_cloudflare_tunnel_connections_4xx_response

type tunnel_connections_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [tunnel_connection]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Indicates the cloudflared enabled features for this Cloudflare Tunnel connection."
type tunnel_connection {
  "Indicates the cloudflared OS architecture used to establish this Cloudflare Tunnel connection."
  arch: String
  "Connections between cloudflared and the Cloudflare edge that are serving this tunnel."
  conns: [cloudflare_tunnel_components_schemas_connection]
  "Contents of a Cloudflare Tunnel."
  features: [String]
  "UUID of the tunnel's connection."
  id: connection_id
  "Indicates when the tunnel connection was started (formatted in RFC 3339)."
  run_at: DateTime
  "Indicates the cloudflared version used to establish this Cloudflare Tunnel connection."
  version: String
}

type cloudflare_tunnel_list_cloudflare_tunnel_connections_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union cloudflare_tunnel_get_cloudflare_tunnel_token_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_response_token") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_get_cloudflare_tunnel_token_4xx_response") = tunnel_response_token | cloudflare_tunnel_get_cloudflare_tunnel_token_4xx_response

type tunnel_response_token {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_tunnel_get_cloudflare_tunnel_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_pages_for_an_account_list_custom_pages_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_an_account_list_custom_pages_4xx_response") = custom_pages_response_collection | custom_pages_for_an_account_list_custom_pages_4xx_response

type custom_pages_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type custom_pages_for_an_account_list_custom_pages_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union custom_pages_for_an_account_get_a_custom_page_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_an_account_get_a_custom_page_4xx_response") = custom_pages_response_single | custom_pages_for_an_account_get_a_custom_page_4xx_response

type custom_pages_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type custom_pages_for_an_account_get_a_custom_page_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"The name of the custom page type."
enum custom_pages_components_schemas_identifier_2 {
  basic_challenge
  managed_challenge
  waf_block
  country_challenge
  ip_block
  under_attack
  ratelimit_block
  _500_errors @enum(value: "\\"500_errors\\"")
  _1000_errors @enum(value: "\\"1000_errors\\"")
}

union dlp_profiles_list_all_profiles_response @statusCodeTypeName(statusCode: 200, typeName: "profiles_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_list_all_profiles_4xx_response") = profiles_components_schemas_response_collection | dlp_profiles_list_all_profiles_4xx_response

type profiles_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [profiles]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type profiles {
  "The entries for this profile."
  entries: JSON
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: JSON
  created_at: DateTime
  "The description of the profile."
  description: String
  updated_at: DateTime
}

type dlp_profiles_list_all_profiles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union dlp_profiles_get_custom_profile_response @statusCodeTypeName(statusCode: 200, typeName: "custom_profile_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_get_custom_profile_4xx_response") = custom_profile_response | dlp_profiles_get_custom_profile_4xx_response

type custom_profile_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Custom_profile
  "Whether the API call was successful"
  success: Boolean!
}

type Custom_profile {
  created_at: DateTime
  "The description of the profile."
  description: String
  "The entries for this profile."
  entries: [custom_entry]
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: custom_const
  updated_at: DateTime
}

"A custom entry that matches a profile"
type custom_entry {
  created_at: DateTime
  "Whether the entry is enabled or not."
  enabled: Boolean
  "The ID for this entry"
  id: String
  "The name of the entry."
  name: String
  pattern: components_schemas_pattern
  "ID of the parent profile"
  profile_id: JSON
  updated_at: DateTime
}

"A pattern that matches an entry"
type components_schemas_pattern {
  "The regex pattern."
  regex: String!
  validation: luhn_const
}

enum luhn_const @typescript(type: "\\"luhn\\"") @example(value: "\\"luhn\\"") {
  luhn @enum(value: "\\"luhn\\"")
}

enum custom_const @typescript(type: "\\"custom\\"") @example(value: "\\"custom\\"") {
  custom @enum(value: "\\"custom\\"")
}

type dlp_profiles_get_custom_profile_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dlp_profiles_get_predefined_profile_response @statusCodeTypeName(statusCode: 200, typeName: "predefined_profile_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_get_predefined_profile_4xx_response") = predefined_profile_response | dlp_profiles_get_predefined_profile_4xx_response

type predefined_profile_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Predefined_profile
  "Whether the API call was successful"
  success: Boolean!
}

type Predefined_profile {
  "The entries for this profile."
  entries: [Predefined_entry]
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: predefined_const
}

"A predefined entry that matches a profile"
type Predefined_entry {
  "Whether the entry is enabled or not."
  enabled: Boolean
  "The ID for this entry"
  id: String
  "The name of the entry."
  name: String
  "ID of the parent profile"
  profile_id: JSON
}

enum predefined_const @typescript(type: "\\"predefined\\"") @example(value: "\\"predefined\\"") {
  predefined @enum(value: "\\"predefined\\"")
}

type dlp_profiles_get_predefined_profile_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dlp_profiles_get_dlp_profile_response @statusCodeTypeName(statusCode: 200, typeName: "either_profile_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_get_dlp_profile_4xx_response") = either_profile_response | dlp_profiles_get_dlp_profile_4xx_response

type either_profile_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_dlp_profiles_get_dlp_profile_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_dlp_profiles_get_dlp_profile_oneOf_0_allOf_1_result {
  "The entries for this profile."
  entries: JSON
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: JSON
  created_at: DateTime
  "The description of the profile."
  description: String
  updated_at: DateTime
}

type dlp_profiles_get_dlp_profile_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_list_dns_firewall_clusters_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_list_dns_firewall_clusters_4xx_response") = dns_firewall_response_collection | dns_firewall_list_dns_firewall_clusters_4xx_response

type dns_firewall_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [dns_firewall]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type dns_firewall {
  attack_mitigation: attack_mitigation
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean!
  dns_firewall_ips: [query_dns_firewall_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_dns_firewall_ips_items]!
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean!
  "Identifier"
  id: common_components_schemas_identifier!
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat!
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat!
  "Last modification of DNS Firewall cluster."
  modified_on: DateTime!
  "DNS Firewall Cluster Name."
  name: dns_firewall_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat
  origin_ips: [query_dns_firewall_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_origin_ips_items]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster)."
  ratelimit: PositiveFloat
}

"Attack mitigation settings."
type attack_mitigation {
  "When enabled, random-prefix attacks are automatically mitigated and the origin DNS servers protected."
  enabled: Boolean
  "Only mitigate attacks when origin servers seem unhealthy."
  only_when_origin_unhealthy: Boolean
}

type query_dns_firewall_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_dns_firewall_ips_items {
  IPv4: IPv4 @resolveRoot
  IPv6: IPv6 @resolveRoot
}

"A field whose value is a IPv4 address: https://en.wikipedia.org/wiki/IPv4."
scalar IPv4

"A field whose value is a IPv6 address: https://en.wikipedia.org/wiki/IPv6."
scalar IPv6

"Floats that will have a value greater than 0."
scalar PositiveFloat

"DNS Firewall Cluster Name."
scalar dns_firewall_components_schemas_name @length(min: null, max: 160)

type query_dns_firewall_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_origin_ips_items {
  IPv4: IPv4 @resolveRoot
  IPv6: IPv6 @resolveRoot
}

type dns_firewall_list_dns_firewall_clusters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union dns_firewall_dns_firewall_cluster_details_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_dns_firewall_cluster_details_4xx_response") = dns_firewall_single_response | dns_firewall_dns_firewall_cluster_details_4xx_response

type dns_firewall_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: dns_firewall
  "Whether the API call was successful"
  success: Boolean!
}

type dns_firewall_dns_firewall_cluster_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_analytics_table_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_analytics_table_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_analytics_table_4xx_response") = dns_firewall_analytics_table_200_response | dns_firewall_analytics_table_4xx_response

type dns_firewall_analytics_table_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type result {
  data: [query_dns_firewall_analytics_table_oneOf_0_allOf_1_result_data_items]
  "Number of seconds between current time and last processed event, in another words how many seconds of data could be missing."
  data_lag: NonNegativeFloat
  "Maximum results for each metric."
  max: JSON
  "Minimum results for each metric."
  min: JSON
  "Total number of rows in the result."
  rows: NonNegativeFloat!
  "Total results for metrics across all data."
  totals: JSON!
}

type query_dns_firewall_analytics_table_oneOf_0_allOf_1_result_data_items {
  "Array of dimension values for this row."
  dimensions: [dimension_value]!
  metrics: [JSON]!
}

type dimension_value {
  "Dimension value identifier that can be used for drill down."
  id: String
  "Dimension value."
  name: String!
  String: String @resolveRoot
}

"Floats that will have a value of 0 or more."
scalar NonNegativeFloat

type dns_firewall_analytics_table_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_analytics_by_time_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_analytics_by_time_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_analytics_by_time_4xx_response") = dns_firewall_analytics_by_time_200_response | dns_firewall_analytics_by_time_4xx_response

type dns_firewall_analytics_by_time_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type dns_firewall_analytics_by_time_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_destination_addresses_list_destination_addresses_response @statusCodeTypeName(statusCode: 200, typeName: "destination_addresses_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_destination_addresses_list_destination_addresses_4xx_response") = destination_addresses_response_collection | email_routing_destination_addresses_list_destination_addresses_4xx_response

type destination_addresses_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [addresses]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_email_routing_destination_addresses_list_destination_addresses_oneOf_0_allOf_1_result_info
}

type addresses {
  "The date and time the destination address has been created."
  created: DateTime
  "The contact email address of the user."
  email: EmailAddress
  "The date and time the destination address was last modified."
  modified: DateTime
  "Destination address identifier."
  tag: destination_address_identifier!
  "The date and time the destination address has been verified. Null means not verified yet."
  verified: DateTime
}

"Destination address identifier."
scalar destination_address_identifier @length(min: null, max: 32)

type query_email_routing_destination_addresses_list_destination_addresses_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type email_routing_destination_addresses_list_destination_addresses_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_email_routing_destination_addresses_list_destination_addresses_oneOf_0_allOf_1_result_info
}

union email_routing_destination_addresses_get_a_destination_address_response @statusCodeTypeName(statusCode: 200, typeName: "destination_address_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_destination_addresses_get_a_destination_address_4xx_response") = destination_address_response_single | email_routing_destination_addresses_get_a_destination_address_4xx_response

type destination_address_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type email_routing_destination_addresses_get_a_destination_address_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_an_account_list_ip_access_rules_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_an_account_list_ip_access_rules_4xx_response") = api_response_collection | ip_access_rules_for_an_account_list_ip_access_rules_4xx_response

type ip_access_rules_for_an_account_list_ip_access_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_access_rules_for_an_account_get_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_an_account_get_an_ip_access_rule_4xx_response") = response_single | ip_access_rules_for_an_account_get_an_ip_access_rule_4xx_response

type response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type ip_access_rules_for_an_account_get_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_images_list_images_response @statusCodeTypeName(statusCode: 200, typeName: "image_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_list_images_4xx_response") = image_response_collection | cloudflare_images_list_images_4xx_response

type image_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [images]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type images {
  "Image file name."
  filename: filename
  "Image unique identifier."
  id: images_components_schemas_identifier!
  metadata: metadata
  "Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image."
  requireSignedURLs: Boolean
  "When the media item was uploaded."
  uploaded: DateTime
  "Object specifying available variants for an image."
  variants: [query_cloudflare_images_list_images_oneOf_0_allOf_1_result_items_variants_items]
}

"Image file name."
scalar filename @length(min: null, max: 32)

"Image unique identifier."
scalar images_components_schemas_identifier @length(min: null, max: 32)

"User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes."
type metadata {
  key: String
}

type query_cloudflare_images_list_images_oneOf_0_allOf_1_result_items_variants_items {
  URL: URL @resolveRoot
}

"A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt."
scalar URL

type cloudflare_images_list_images_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Account identifier tag."
scalar images_components_schemas_account_identifier @length(min: null, max: 32)

union cloudflare_images_keys_list_signing_keys_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_key_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_keys_list_signing_keys_4xx_response") = schemas_key_response_collection | cloudflare_images_keys_list_signing_keys_4xx_response

type schemas_key_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: keys_response
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type keys_response {
  keys: [schemas_keys]
}

type schemas_keys {
  "Key name."
  name: String
  "Key value."
  value: String
}

type cloudflare_images_keys_list_signing_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union cloudflare_images_images_usage_statistics_response @statusCodeTypeName(statusCode: 200, typeName: "images_stats") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_images_usage_statistics_4xx_response") = images_stats | cloudflare_images_images_usage_statistics_4xx_response

type images_stats {
  count: images_count
}

type images_count {
  "Cloudflare Images allowed usage."
  allowed: Float
  "Cloudflare Images current usage."
  current: Float
}

type cloudflare_images_images_usage_statistics_4xx_response {
  count: images_count
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_images_variants_list_variants_response @statusCodeTypeName(statusCode: 200, typeName: "variant_list_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_variants_list_variants_4xx_response") = variant_list_response | cloudflare_images_variants_list_variants_4xx_response

type variant_list_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: variants_response
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type variants_response {
  variants: variant_public_request
}

type variant_public_request {
  hero: JSON
}

type cloudflare_images_variants_list_variants_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union cloudflare_images_variants_variant_details_response @statusCodeTypeName(statusCode: 200, typeName: "variant_simple_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_variants_variant_details_4xx_response") = variant_simple_response | cloudflare_images_variants_variant_details_4xx_response

type variant_simple_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: variant_response
  "Whether the API call was successful"
  success: Boolean!
}

type variant_response {
  variant: JSON
}

type cloudflare_images_variants_variant_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar variants_components_schemas_identifier @regexp(pattern: "^[a-zA-Z0-9]$") @typescript(type: "string")

union cloudflare_images_image_details_response @statusCodeTypeName(statusCode: 200, typeName: "image_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_image_details_4xx_response") = image_response_single | cloudflare_images_image_details_4xx_response

type image_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_images_image_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_images_base_image_response @statusCodeTypeName(statusCode: 200, typeName: "String_container") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_base_image_4xx_response") = String_container | cloudflare_images_base_image_4xx_response

type String_container {
  String: String
}

type cloudflare_images_base_image_4xx_response {
  String: String @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union phishing_url_scanner_scan_suspicious_url_response @statusCodeTypeName(statusCode: 200, typeName: "phishing_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "phishing_url_scanner_scan_suspicious_url_4xx_response") = phishing_components_schemas_single_response | phishing_url_scanner_scan_suspicious_url_4xx_response

type phishing_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: phishing
  "Whether the API call was successful"
  success: Boolean!
}

type phishing {
  "Type of classifier that labelled this URL."
  classifier: String
  "Whether the URL has been classified as phishing."
  phishing: Boolean
  "Score reported from the classifer for the given URL."
  score: Float
  "URL that was scanned."
  url: URL
  "Whether the URL has been hand verified."
  verified: Boolean
}

type phishing_url_scanner_scan_suspicious_url_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union asn_intelligence_get_asn_overview_response @statusCodeTypeName(statusCode: 200, typeName: "asn_components_schemas_response") @statusCodeTypeName(statusCode: "4xx", typeName: "asn_intelligence_get_asn_overview_4xx_response") = asn_components_schemas_response | asn_intelligence_get_asn_overview_4xx_response

type asn_components_schemas_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [asn_components_schemas_asn]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type asn_components_schemas_asn {
  asn: Int
  country: String
  description: String
  domain_count: Int
  top_domains: [String]
  type: asn_type
}

"Infrastructure type of this ASN."
enum asn_type {
  hosting_provider
  isp
  organization
}

type asn_intelligence_get_asn_overview_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input asn_components_schemas_asn_Input {
  asn: Int
  country: String
  description: String
  domain_count: Int
  top_domains: [String]
  type: asn_type
}

union asn_intelligence_get_asn_subnets_response @statusCodeTypeName(statusCode: 200, typeName: "asn_intelligence_get_asn_subnets_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "asn_intelligence_get_asn_subnets_4xx_response") = asn_intelligence_get_asn_subnets_200_response | asn_intelligence_get_asn_subnets_4xx_response

type asn_intelligence_get_asn_subnets_200_response {
  asn: Int
  "Total results returned based on your search parameters."
  count: Float
  ip_count_total: Int
  "Current page within paginated list of results."
  page: Float
  "Number of results per page of results."
  per_page: Float
  subnets: [String]
}

type asn_intelligence_get_asn_subnets_4xx_response {
  asn: Int
  "Total results returned based on your search parameters."
  count: Float
  ip_count_total: Int
  "Current page within paginated list of results."
  page: Float
  "Number of results per page of results."
  per_page: Float
  subnets: [String]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union passive_dns_by_ip_get_passive_dns_by_ip_response @statusCodeTypeName(statusCode: 200, typeName: "passive_dns_by_ip_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "passive_dns_by_ip_get_passive_dns_by_ip_4xx_response") = passive_dns_by_ip_components_schemas_single_response | passive_dns_by_ip_get_passive_dns_by_ip_4xx_response

type passive_dns_by_ip_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: passive_dns_by_ip
  "Whether the API call was successful"
  success: Boolean!
}

type passive_dns_by_ip {
  "Total results returned based on your search parameters."
  count: Float
  "Current page within paginated list of results."
  page: Float
  "Number of results per page of results."
  per_page: Float
  "Reverse DNS look-ups observed during the time period."
  reverse_records: [query_passive_dns_by_ip_get_passive_dns_by_ip_oneOf_0_allOf_1_result_reverse_records_items]
}

type query_passive_dns_by_ip_get_passive_dns_by_ip_oneOf_0_allOf_1_result_reverse_records_items {
  "First seen date of the DNS record during the time period."
  first_seen: Date
  "Hostname that the IP was observed resolving to."
  hostname: JSON
  "Last seen date of the DNS record during the time period."
  last_seen: Date
}

"Represents date values"
scalar Date

type passive_dns_by_ip_get_passive_dns_by_ip_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union domain_intelligence_get_domain_details_response @statusCodeTypeName(statusCode: 200, typeName: "domain_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "domain_intelligence_get_domain_details_4xx_response") = domain_components_schemas_single_response | domain_intelligence_get_domain_details_4xx_response

type domain_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: domain_components_schemas_domain
  "Whether the API call was successful"
  success: Boolean!
}

type domain_components_schemas_domain {
  additional_information: additional_information
  application: schemas_application
  "Current content categories."
  content_categories: [query_domain_intelligence_get_domain_details_oneOf_0_allOf_1_result_content_categories_items]
  domain: String
  "Global Cloudflare 100k ranking for the last 30 days, if available for the hostname. The top ranked domain is 1, the lowest ranked domain is 100,000."
  popularity_rank: Int
  "Specifies a list of references to one or more IP addresses or domain names that the domain name currently resolves to."
  resolves_to_refs: [resolves_to_ref]
  "Hostname risk score, which is a value between 0 (lowest risk) to 1 (highest risk)."
  risk_score: Float
  risk_types: [JSON]
}

"Additional information related to the host name."
type additional_information {
  "Suspected DGA malware family."
  suspected_malware_family: String
}

"Application that the hostname belongs to."
type schemas_application {
  id: Int
  name: String
}

type query_domain_intelligence_get_domain_details_oneOf_0_allOf_1_result_content_categories_items {
  id: Int
  name: String
  super_category_id: Int
}

type resolves_to_ref {
  "STIX 2.1 identifier: https://docs.oasis-open.org/cti/stix/v2.1/cs02/stix-v2.1-cs02.html#_64yvzeku5a5c"
  id: String
  "IP address or domain name."
  value: String
}

type domain_intelligence_get_domain_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union domain_history_get_domain_history_response @statusCodeTypeName(statusCode: 200, typeName: "response") @statusCodeTypeName(statusCode: "4xx", typeName: "domain_history_get_domain_history_4xx_response") = response | domain_history_get_domain_history_4xx_response

type response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [domain_history]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type domain_history {
  categorizations: [query_domain_history_get_domain_history_oneOf_0_allOf_1_result_items_categorizations_items]
  domain: String
}

type query_domain_history_get_domain_history_oneOf_0_allOf_1_result_items_categorizations_items {
  categories: [query_domain_history_get_domain_history_oneOf_0_allOf_1_result_items_categorizations_items_categories_items]
  end: Date
  start: Date
}

type query_domain_history_get_domain_history_oneOf_0_allOf_1_result_items_categorizations_items_categories_items {
  id: Int
  name: String
}

type domain_history_get_domain_history_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union domain_intelligence_get_multiple_domain_details_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "domain_intelligence_get_multiple_domain_details_4xx_response") = schemas_collection_response | domain_intelligence_get_multiple_domain_details_4xx_response

type schemas_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_domain_intelligence_get_multiple_domain_details_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_domain_intelligence_get_multiple_domain_details_oneOf_0_allOf_1_result_items {
  additional_information: additional_information
  application: schemas_application
  "Current content categories."
  content_categories: [query_domain_intelligence_get_domain_details_oneOf_0_allOf_1_result_content_categories_items]
  domain: String
  "Global Cloudflare 100k ranking for the last 30 days, if available for the hostname. The top ranked domain is 1, the lowest ranked domain is 100,000."
  popularity_rank: Int
  "Hostname risk score, which is a value between 0 (lowest risk) to 1 (highest risk)."
  risk_score: Float
  risk_types: [JSON]
}

type domain_intelligence_get_multiple_domain_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_intelligence_get_ip_overview_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_intelligence_get_ip_overview_4xx_response") = schemas_response | ip_intelligence_get_ip_overview_4xx_response

type schemas_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ip_components_schemas_ip]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ip_components_schemas_ip {
  belongs_to_ref: query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_belongs_to_ref
  ip: common_components_schemas_ip
  risk_types: [query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_risk_types_items]
}

"Specifies a reference to the autonomous systems (AS) that the IP address belongs to."
type query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_belongs_to_ref {
  country: String
  description: String
  id: String
  type: query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_belongs_to_ref_type
  value: String
}

"Infrastructure type of this ASN."
enum query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_belongs_to_ref_type {
  hosting_provider
  isp
  organization
}

type common_components_schemas_ip {
  IPv4: IPv4 @resolveRoot
  IPv6: IPv6 @resolveRoot
}

type query_ip_intelligence_get_ip_overview_oneOf_0_allOf_1_result_items_risk_types_items {
  id: Int
  name: String
  super_category_id: Int
}

type ip_intelligence_get_ip_overview_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_list_get_ip_lists_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_list_get_ip_lists_4xx_response") = components_schemas_response | ip_list_get_ip_lists_4xx_response

type components_schemas_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ip_list]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ip_list {
  description: String
  id: Int
  name: String
}

type ip_list_get_ip_lists_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union whois_record_get_whois_record_response @statusCodeTypeName(statusCode: 200, typeName: "whois_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "whois_record_get_whois_record_4xx_response") = whois_components_schemas_single_response | whois_record_get_whois_record_4xx_response

type whois_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: whois
  "Whether the API call was successful"
  success: Boolean!
}

type whois {
  created_date: Date
  domain: String
  nameservers: [String]
  registrant: String
  registrant_country: String
  registrant_email: URL
  registrant_org: String
  registrar: String
  updated_date: Date
}

type whois_record_get_whois_record_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_monitors_list_monitors_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_response_collection_2") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_list_monitors_4xx_response") = monitor_components_schemas_response_collection_2 | account_load_balancer_monitors_list_monitors_4xx_response

type monitor_components_schemas_response_collection_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_monitor]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type components_schemas_monitor {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times."
  consecutive_down: Int
  "To be marked healthy the monitored origin must pass this healthcheck N consecutive times."
  consecutive_up: Int
  created_on: DateTime
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header
  id: String!
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String
  modified_on: DateTime
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int
  type: monitor_components_schemas_type
}

"The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors."
type header {
  Host: [String]
  X_App_ID: [String] @resolveRootField(field: "X-App-ID")
}

"The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'."
enum monitor_components_schemas_type {
  http
  https
  tcp
  udp_icmp
  icmp_ping
  smtp
}

type account_load_balancer_monitors_list_monitors_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_load_balancer_monitors_monitor_details_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_monitor_details_4xx_response") = monitor_components_schemas_single_response_2 | account_load_balancer_monitors_monitor_details_4xx_response

type monitor_components_schemas_single_response_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: components_schemas_monitor
  "Whether the API call was successful"
  success: Boolean!
}

type account_load_balancer_monitors_monitor_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_monitors_list_monitor_references_response @statusCodeTypeName(statusCode: 200, typeName: "references_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_list_monitor_references_4xx_response") = references_response | account_load_balancer_monitors_list_monitor_references_4xx_response

type references_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "List of resources that reference a given monitor."
  result: [query_account_load_balancer_monitors_list_monitor_references_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_account_load_balancer_monitors_list_monitor_references_oneOf_0_allOf_1_result_items {
  reference_type: query_account_load_balancer_monitors_list_monitor_references_oneOf_0_allOf_1_result_items_reference_type
  resource_id: String
  resource_name: String
  resource_type: String
}

enum query_account_load_balancer_monitors_list_monitor_references_oneOf_0_allOf_1_result_items_reference_type {
  _STAR_ @enum(value: "\\"*\\"")
  referral
  referrer
}

type account_load_balancer_monitors_list_monitor_references_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_load_balancer_pools_list_pools_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_list_pools_4xx_response") = pool_components_schemas_response_collection | account_load_balancer_pools_list_pools_4xx_response

type pool_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [pool]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type pool {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  created_on: DateTime
  "A human-readable description of the pool."
  description: String
  "This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at."
  disabled_at: DateTime
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean
  id: String!
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int
  modified_on: DateTime
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter
  origin_steering: origin_steering
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin]
}

"WNAM: Western North America, ENAM: Eastern North America, WEU: Western Europe, EEU: Eastern Europe, NSAM: Northern South America, SSAM: Southern South America, OC: Oceania, ME: Middle East, NAF: North Africa, SAF: South Africa, SAS: Southern Asia, SEAS: South East Asia, NEAS: North East Asia, ALL_REGIONS: all regions (ENTERPRISE customers only)."
enum query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items {
  WNAM
  ENAM
  WEU
  EEU
  NSAM
  SSAM
  OC
  ME
  NAF
  SAF
  SAS
  SEAS
  NEAS
  ALL_REGIONS
}

"Configures load shedding policies and percentages for the pool."
type load_shedding {
  "The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity."
  default_percent: NonNegativeFloat
  default_policy: query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_load_shedding_default_policy
  "The percent of existing sessions to shed from the pool, according to the session policy."
  session_percent: NonNegativeFloat
  session_policy: hash_const
}

"The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs."
enum query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_load_shedding_default_policy {
  random
  hash
}

enum hash_const @typescript(type: "\\"hash\\"") @example(value: "\\"hash\\"") {
  hash @enum(value: "\\"hash\\"")
}

"Filter pool and origin health notifications by resource type or health status. Use null to reset."
type notification_filter {
  origin: filter_options
  pool: filter_options
}

"Filter options for a particular resource type (pool or origin). Use null to reset."
type filter_options {
  "If set true, disable notifications for this type of resource (pool or origin)."
  disable: Boolean
  "If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events)."
  healthy: Boolean
}

"Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity."
type origin_steering {
  policy: query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_origin_steering_policy
}

"The type of origin steering policy to use, either \\"random\\" or \\"hash\\" (based on CF-Connecting-IP)."
enum query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_origin_steering_policy {
  random
  hash
}

type schemas_origin {
  "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare."
  address: String
  "This field shows up only if the origin is disabled. This field is set with the time the origin was disabled."
  disabled_at: DateTime
  "Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool."
  enabled: Boolean
  header: schemas_header
  "A human-identifiable name for the origin."
  name: String
  "The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool."
  weight: NonNegativeFloat
}

"The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'."
type schemas_header {
  "The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin."
  Host: [String]
}

type account_load_balancer_pools_list_pools_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_load_balancer_pools_pool_details_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_pool_details_4xx_response") = pool_components_schemas_single_response | account_load_balancer_pools_pool_details_4xx_response

type pool_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: pool
  "Whether the API call was successful"
  success: Boolean!
}

type account_load_balancer_pools_pool_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_pools_pool_health_details_response @statusCodeTypeName(statusCode: 200, typeName: "health_details") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_pool_health_details_4xx_response") = health_details | account_load_balancer_pools_pool_health_details_4xx_response

type health_details {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

"A list of regions from which to run health checks. Null means every Cloudflare data center."
type query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result {
  pool_id: String
  pop_health: query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health
}

type query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health {
  Amsterdam_COMMA__NL: query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL @resolveRootField(field: "Amsterdam, NL")
}

type query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL {
  healthy: Boolean
  origins: [query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL_origins_items]
}

type query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL_origins_items {
  _2001_DB8__5: query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL_origins_items_2001_DB8__5 @resolveRootField(field: "2001:DB8::5")
}

type query_account_load_balancer_pools_pool_health_details_oneOf_0_allOf_1_result_pop_health_Amsterdam_COMMA__NL_origins_items_2001_DB8__5 {
  failure_reason: String
  healthy: Boolean
  response_code: Int
  rtt: String
}

type account_load_balancer_pools_pool_health_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_pools_list_pool_references_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_references_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_list_pool_references_4xx_response") = schemas_references_response | account_load_balancer_pools_list_pool_references_4xx_response

type schemas_references_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "List of resources that reference a given pool."
  result: [query_account_load_balancer_pools_list_pool_references_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_account_load_balancer_pools_list_pool_references_oneOf_0_allOf_1_result_items {
  reference_type: query_account_load_balancer_pools_list_pool_references_oneOf_0_allOf_1_result_items_reference_type
  resource_id: String
  resource_name: String
  resource_type: String
}

enum query_account_load_balancer_pools_list_pool_references_oneOf_0_allOf_1_result_items_reference_type {
  _STAR_ @enum(value: "\\"*\\"")
  referral
  referrer
}

type account_load_balancer_pools_list_pool_references_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_load_balancer_monitors_preview_result_response @statusCodeTypeName(statusCode: 200, typeName: "preview_result_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_preview_result_4xx_response") = preview_result_response | account_load_balancer_monitors_preview_result_4xx_response

type preview_result_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  abwlnp5jbqn45ecgxd03erbgtxtqai0d: query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d
  additionalProperties: JSON @resolveRoot
}

type query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_0_allOf_1_result {
  JSON: JSON @resolveRoot
  String: String @resolveRoot
}

type query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d {
  healthy: Boolean
  origins: [query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d_origins_items]
}

type query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d_origins_items {
  originone_example_com_: query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d_origins_items_originone_example_com_ @resolveRootField(field: "originone.example.com.")
}

type query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d_origins_items_originone_example_com_ {
  _DOLLAR_ref: String @resolveRootField(field: "$ref")
}

type account_load_balancer_monitors_preview_result_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  abwlnp5jbqn45ecgxd03erbgtxtqai0d: query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d
  additionalProperties: JSON @resolveRoot
}

union load_balancer_regions_list_regions_response @statusCodeTypeName(statusCode: 200, typeName: "region_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_regions_list_regions_4xx_response") = region_components_schemas_response_collection | load_balancer_regions_list_regions_4xx_response

type region_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type load_balancer_regions_list_regions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_regions_get_region_response @statusCodeTypeName(statusCode: 200, typeName: "region_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_regions_get_region_4xx_response") = region_components_schemas_single_response | load_balancer_regions_get_region_4xx_response

type region_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_load_balancer_regions_get_region_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

"A list of countries and subdivisions mapped to a region."
type query_load_balancer_regions_get_region_oneOf_0_allOf_1_result {
  iso_standard: String
  regions: [query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items]
}

type query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items {
  countries: [query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items_countries_items]
  region_code: String
}

type query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items_countries_items {
  country_code_a2: String
  country_name: String
  country_subdivisions: [query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items_countries_items_country_subdivisions_items]
}

type query_load_balancer_regions_get_region_oneOf_0_allOf_1_result_regions_items_countries_items_country_subdivisions_items {
  subdivision_code_a2: String
  subdivision_name: String
}

type load_balancer_regions_get_region_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A list of Cloudflare regions. WNAM: Western North America, ENAM: Eastern North America, WEU: Western Europe, EEU: Eastern Europe, NSAM: Northern South America, SSAM: Southern South America, OC: Oceania, ME: Middle East, NAF: North Africa, SAF: South Africa, SAS: Southern Asia, SEAS: South East Asia, NEAS: North East Asia)."
enum region_code {
  WNAM
  ENAM
  WEU
  EEU
  NSAM
  SSAM
  OC
  ME
  NAF
  SAF
  SAS
  SEAS
  NEAS
}

union account_load_balancer_search_search_resources_response @statusCodeTypeName(statusCode: 200, typeName: "account_load_balancer_search_search_resources_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_search_search_resources_4xx_response") = account_load_balancer_search_search_resources_200_response | account_load_balancer_search_search_resources_4xx_response

type account_load_balancer_search_search_resources_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: search
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type search {
  "A list of resources matching the search query."
  resources: [resource_reference]
}

"A reference to a load balancer resource."
type resource_reference {
  reference_type: query_account_load_balancer_search_search_resources_oneOf_0_allOf_1_result_resources_items_reference_type
  "A list of references to (referrer) or from (referral) this resource."
  references: [JSON]
  resource_id: String
  "The human-identifiable name of the resource."
  resource_name: String
  resource_type: query_account_load_balancer_search_search_resources_oneOf_0_allOf_1_result_resources_items_resource_type
}

"When listed as a reference, the type (direction) of the reference."
enum query_account_load_balancer_search_search_resources_oneOf_0_allOf_1_result_resources_items_reference_type {
  referral
  referrer
}

"The type of the resource."
enum query_account_load_balancer_search_search_resources_oneOf_0_allOf_1_result_resources_items_resource_type {
  load_balancer
  monitor
  pool
}

type account_load_balancer_search_search_resources_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union magic_interconnects_list_interconnects_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_interconnects_list_interconnects_4xx_response") = components_schemas_tunnels_collection_response | magic_interconnects_list_interconnects_4xx_response

type components_schemas_tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_interconnects_list_interconnects_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_interconnects_list_interconnects_oneOf_0_allOf_1_result {
  interconnects: [interconnect]
}

type interconnect {
  "The name of the interconnect. The name cannot share a name with other tunnels."
  colo_name: String
  "The date and time the tunnel was created."
  created_on: DateTime
  "An optional description of the interconnect."
  description: String
  gre: gre
  health_check: schemas_health_check
  "Tunnel identifier tag."
  id: common_components_schemas_identifier_2
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String
  "The date and time the tunnel was last modified."
  modified_on: DateTime
  "The Maximum Transmission Unit (MTU) in bytes for the interconnect. The minimum value is 576."
  mtu: Int
  "The name of the interconnect. The name cannot share a name with other tunnels."
  name: String
}

"The configuration specific to GRE interconnects."
type gre {
  "The IP address assigned to the Cloudflare side of the GRE tunnel created as part of the Interconnect."
  cloudflare_endpoint: String
  "The IP address assigned to the customer side of the GRE tunnel created as part of the Interconnect."
  customer_endpoint: String
}

type schemas_health_check {
  "Determines whether to run healthchecks for a tunnel."
  enabled: Boolean
  "The address used to run healthchecks for a tunnel."
  target: String
  type: query_magic_interconnects_list_interconnects_oneOf_0_allOf_1_result_interconnects_items_health_check_type
}

"The type of healthcheck to run, reply or request. The default value is \`reply\`."
enum query_magic_interconnects_list_interconnects_oneOf_0_allOf_1_result_interconnects_items_health_check_type {
  reply
  request
}

"Tunnel identifier tag."
scalar common_components_schemas_identifier_2 @length(min: null, max: 32)

type magic_interconnects_list_interconnects_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_interconnects_list_interconnect_details_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_tunnel_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_interconnects_list_interconnect_details_4xx_response") = components_schemas_tunnel_single_response | magic_interconnects_list_interconnect_details_4xx_response

type components_schemas_tunnel_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_interconnects_list_interconnect_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_interconnects_list_interconnect_details_oneOf_0_allOf_1_result {
  interconnect: JSON
}

type magic_interconnects_list_interconnect_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_gre_tunnels_list_gre_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_list_gre_tunnels_4xx_response") = tunnels_collection_response | magic_gre_tunnels_list_gre_tunnels_4xx_response

type tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_gre_tunnels_list_gre_tunnels_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_gre_tunnels_list_gre_tunnels_oneOf_0_allOf_1_result {
  gre_tunnels: [gre_tunnel]
}

type gre_tunnel {
  "The IP address assigned to the Cloudflare side of the GRE tunnel."
  cloudflare_gre_endpoint: String!
  "The date and time the tunnel was created."
  created_on: DateTime
  "The IP address assigned to the customer side of the GRE tunnel."
  customer_gre_endpoint: String!
  "An optional description of the GRE tunnel."
  description: String
  health_check: health_check
  "Tunnel identifier tag."
  id: common_components_schemas_identifier_2
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String!
  "The date and time the tunnel was last modified."
  modified_on: DateTime
  "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576."
  mtu: Int
  "The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel."
  name: String!
  "Time To Live (TTL) in number of hops of the GRE tunnel."
  ttl: Int
}

type health_check {
  "Determines whether to run healthchecks for a tunnel."
  enabled: Boolean
  "The address used to run healthchecks for a tunnel. This field defaults to \`customer_gre_endpoint address\`."
  target: String
  type: query_magic_gre_tunnels_list_gre_tunnels_oneOf_0_allOf_1_result_gre_tunnels_items_health_check_type
}

"The type of healthcheck to run, reply or request. The default value is \`reply\`."
enum query_magic_gre_tunnels_list_gre_tunnels_oneOf_0_allOf_1_result_gre_tunnels_items_health_check_type {
  reply
  request
}

type magic_gre_tunnels_list_gre_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_gre_tunnels_list_gre_tunnel_details_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_list_gre_tunnel_details_4xx_response") = tunnel_single_response | magic_gre_tunnels_list_gre_tunnel_details_4xx_response

type tunnel_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_gre_tunnels_list_gre_tunnel_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_gre_tunnels_list_gre_tunnel_details_oneOf_0_allOf_1_result {
  gre_tunnel: JSON
}

type magic_gre_tunnels_list_gre_tunnel_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_i_psec_tunnels_list_i_psec_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_list_i_psec_tunnels_4xx_response") = schemas_tunnels_collection_response | magic_i_psec_tunnels_list_i_psec_tunnels_4xx_response

type schemas_tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_i_psec_tunnels_list_i_psec_tunnels_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_i_psec_tunnels_list_i_psec_tunnels_oneOf_0_allOf_1_result {
  ipsec_tunnels: [ipsec_tunnel]
}

type ipsec_tunnel {
  "When \`true\`, the tunnel can use a null-cipher (\`ENCR_NULL\`) in the ESP tunnel (Phase 2)."
  allow_null_cipher: Boolean
  "The IP address assigned to the Cloudflare side of the IPsec tunnel."
  cloudflare_endpoint: String!
  "The date and time the tunnel was created."
  created_on: DateTime
  "The IP address assigned to the customer side of the IPsec tunnel."
  customer_endpoint: String
  "An optional description forthe IPsec tunnel."
  description: String
  "Tunnel identifier tag."
  id: common_components_schemas_identifier_2
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String!
  "The date and time the tunnel was last modified."
  modified_on: DateTime
  "The name of the IPsec tunnel. The name cannot share a name with other tunnels."
  name: String!
  psk_metadata: psk_metadata
  tunnel_health_check: tunnel_health_check
}

"The PSK metadata that includes when the PSK was generated."
type psk_metadata {
  "The date and time the tunnel was last modified."
  last_generated_on: DateTime
}

type tunnel_health_check {
  "Determines whether to run healthchecks for a tunnel."
  enabled: Boolean
  "The address used to run healthchecks for a tunnel. This field defaults to \`customer_gre_endpoint address\`."
  target: String
  type: query_magic_i_psec_tunnels_list_i_psec_tunnels_oneOf_0_allOf_1_result_ipsec_tunnels_items_tunnel_health_check_type
}

"The type of healthcheck to run, reply or request. The default value is \`reply\`."
enum query_magic_i_psec_tunnels_list_i_psec_tunnels_oneOf_0_allOf_1_result_ipsec_tunnels_items_tunnel_health_check_type {
  reply
  request
}

type magic_i_psec_tunnels_list_i_psec_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_i_psec_tunnels_list_i_psec_tunnel_details_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_list_i_psec_tunnel_details_4xx_response") = schemas_tunnel_single_response | magic_i_psec_tunnels_list_i_psec_tunnel_details_4xx_response

type schemas_tunnel_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_i_psec_tunnels_list_i_psec_tunnel_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_i_psec_tunnels_list_i_psec_tunnel_details_oneOf_0_allOf_1_result {
  ipsec_tunnel: JSON
}

type magic_i_psec_tunnels_list_i_psec_tunnel_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_static_routes_list_routes_response @statusCodeTypeName(statusCode: 200, typeName: "routes_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_list_routes_4xx_response") = routes_collection_response | magic_static_routes_list_routes_4xx_response

type routes_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_static_routes_list_routes_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_static_routes_list_routes_oneOf_0_allOf_1_result {
  routes: [schemas_route]
}

type schemas_route {
  "When the route was created."
  created_on: DateTime
  "An optional human provided description of the static route."
  description: String
  "Route identifier tag."
  id: route_components_schemas_identifier
  "When the route was last modified."
  modified_on: DateTime
  "The next-hop IP Address for the static route."
  nexthop: String!
  "IP Prefix in Classless Inter-Domain Routing format."
  prefix: String!
  "Priority of the static route."
  priority: Int!
  scope: schemas_scope
  "Optional weight of the ECMP scope - if provided."
  weight: Int
}

"Route identifier tag."
scalar route_components_schemas_identifier @length(min: null, max: 32)

"Used only for ECMP routes."
type schemas_scope {
  "List of colo names for the ECMP scope."
  colo_names: [String]
  "List of colo regions for the ECMP scope."
  colo_regions: [String]
}

type magic_static_routes_list_routes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_static_routes_route_details_response @statusCodeTypeName(statusCode: 200, typeName: "route_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_route_details_4xx_response") = route_single_response | magic_static_routes_route_details_4xx_response

type route_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_static_routes_route_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_static_routes_route_details_oneOf_0_allOf_1_result {
  route: JSON
}

type magic_static_routes_route_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_members_list_members_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_members_list_members_4xx_response") = api_response_collection | account_members_list_members_4xx_response

type account_members_list_members_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_members_member_details_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_members_member_details_4xx_response") = response_single | account_members_member_details_4xx_response

type account_members_member_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_configuration_list_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_list_account_configuration_4xx_response") = mnm_config | magic_network_monitoring_configuration_list_account_configuration_4xx_response

type mnm_config {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
}

type magic_network_monitoring_configuration_list_account_configuration_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_configuration_list_rules_and_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_list_rules_and_account_configuration_4xx_response") = mnm_config | magic_network_monitoring_configuration_list_rules_and_account_configuration_4xx_response

type magic_network_monitoring_configuration_list_rules_and_account_configuration_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_list_rules_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_list_rules_4xx_response") = mnm_rule | magic_network_monitoring_rules_list_rules_4xx_response

type mnm_rule {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
}

type magic_network_monitoring_rules_list_rules_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_get_rule_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_get_rule_4xx_response") = mnm_rule | magic_network_monitoring_rules_get_rule_4xx_response

type magic_network_monitoring_rules_get_rule_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_project_get_projects_response @statusCodeTypeName(statusCode: 200, typeName: "projects_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_project_get_projects_4xx_response") = projects_response | pages_project_get_projects_4xx_response

type projects_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_project_get_projects_oneOf_0_allOf_1_result_info
}

type query_pages_project_get_projects_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type pages_project_get_projects_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_project_get_projects_oneOf_0_allOf_1_result_info
}

union pages_project_get_project_response @statusCodeTypeName(statusCode: 200, typeName: "project_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_project_get_project_4xx_response") = project_response | pages_project_get_project_4xx_response

type project_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type pages_project_get_project_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar project_name @regexp(pattern: "^[a-z0-9][a-z0-9-]*$") @typescript(type: "string")

union pages_deployment_get_deployments_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_list_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_get_deployments_4xx_response") = deployment_list_response | pages_deployment_get_deployments_4xx_response

type deployment_list_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_deployment_get_deployments_oneOf_0_allOf_1_result_info
}

type query_pages_deployment_get_deployments_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type pages_deployment_get_deployments_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_deployment_get_deployments_oneOf_0_allOf_1_result_info
}

union pages_deployment_get_deployment_info_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_response_details") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_get_deployment_info_4xx_response") = deployment_response_details | pages_deployment_get_deployment_info_4xx_response

type deployment_response_details {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: deployments
  "Whether the API call was successful"
  success: Boolean!
}

type deployments {
  "A list of alias URLs pointing to this deployment."
  aliases: [JSON]
  build_config: JSON
  "When the deployment was created."
  created_on: DateTime
  deployment_trigger: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger
  env_vars: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars
  environment: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_environment
  "Id of the deployment."
  id: String
  "If the deployment has been skipped."
  is_skipped: Boolean
  latest_stage: JSON
  "When the deployment was last modified."
  modified_on: DateTime
  "Id of the project."
  project_id: String
  "Name of the project."
  project_name: String
  "Short Id (8 character) of the deployment."
  short_id: String
  source: JSON
  "List of past stages."
  stages: [stage]
  "The live URL to view this deployment."
  url: URL
}

"Info about what caused the deployment."
type query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger {
  metadata: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_metadata
  type: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_type
}

"Additional info about the trigger."
type query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_metadata {
  "Where the trigger happened."
  branch: String
  "Hash of the deployment trigger commit."
  commit_hash: String
  "Message of the deployment trigger commit."
  commit_message: String
}

scalar query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_type @regexp(pattern: "push|ad_hoc") @typescript(type: "string")

"A dict of env variables to build this deploy."
type query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars {
  BUILD_VERSION: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_BUILD_VERSION
  ENV: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_ENV
}

type query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_BUILD_VERSION {
  value: String
}

type query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_ENV {
  value: String
}

scalar query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_environment @regexp(pattern: "preview|production") @typescript(type: "string")

"The status of the deployment."
type stage {
  "When the stage ended."
  ended_on: DateTime
  name: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_name
  "When the stage started."
  started_on: DateTime
  status: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_status
}

scalar query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_name @regexp(pattern: "queued|initialize|clone_repo|build|deploy") @typescript(type: "string")

scalar query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_status @regexp(pattern: "success|idle|active|failure|canceled") @typescript(type: "string")

type pages_deployment_get_deployment_info_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_deployment_get_deployment_logs_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_response_logs") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_get_deployment_logs_4xx_response") = deployment_response_logs | pages_deployment_get_deployment_logs_4xx_response

type deployment_response_logs {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_pages_deployment_get_deployment_logs_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_pages_deployment_get_deployment_logs_oneOf_0_allOf_1_result {
  data: [query_pages_deployment_get_deployment_logs_oneOf_0_allOf_1_result_data_items]
  includes_container_logs: Boolean
  total: Int
}

type query_pages_deployment_get_deployment_logs_oneOf_0_allOf_1_result_data_items {
  line: String
  ts: DateTime
}

type pages_deployment_get_deployment_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_deployment_get_deployment_stage_logs_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_response_stage_logs") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_get_deployment_stage_logs_4xx_response") = deployment_response_stage_logs | pages_deployment_get_deployment_stage_logs_4xx_response

type deployment_response_stage_logs {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_pages_deployment_get_deployment_stage_logs_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_pages_deployment_get_deployment_stage_logs_oneOf_0_allOf_1_result {
  data: [query_pages_deployment_get_deployment_stage_logs_oneOf_0_allOf_1_result_data_items]
  end: Int
  ended_on: DateTime
  name: String
  start: Int
  started_on: DateTime
  status: String
  total: Int
}

type query_pages_deployment_get_deployment_stage_logs_oneOf_0_allOf_1_result_data_items {
  id: Int
  message: String
  timestamp: DateTime
}

type pages_deployment_get_deployment_stage_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar deployment_stage_name @regexp(pattern: "queued|initialize|clone_repo|build|deploy") @typescript(type: "string")

union pages_domains_get_domains_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_domains_get_domains_4xx_response") = domain_response_collection | pages_domains_get_domains_4xx_response

type domain_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_domains_get_domains_oneOf_0_allOf_1_result_info
}

type query_pages_domains_get_domains_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type pages_domains_get_domains_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_pages_domains_get_domains_oneOf_0_allOf_1_result_info
}

union pages_domains_get_domain_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_domains_get_domain_4xx_response") = domain_response_single | pages_domains_get_domain_4xx_response

type domain_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type pages_domains_get_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar domain_name @regexp(pattern: "^[a-z0-9][a-z0-9-]*$") @typescript(type: "string")

union magic_pcap_collection_list_packet_capture_requests_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_list_packet_capture_requests_4xx_response") = pcaps_collection_response | magic_pcap_collection_list_packet_capture_requests_4xx_response

type pcaps_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_magic_pcap_collection_list_packet_capture_requests_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_magic_pcap_collection_list_packet_capture_requests_oneOf_0_allOf_1_result_items {
  filter_v1: pcaps_filter_v1
  "The ID for the packet capture."
  id: pcaps_id
  status: pcaps_status
  "The RFC 3339 timestamp when the packet capture was created."
  submitted: DateTime
  system: pcaps_system
  "The packet capture duration in seconds."
  time_limit: PositiveFloat
  type: pcaps_type
  "The maximum number of bytes to capture. This field only applies to \`full\` packet captures."
  byte_limit: PositiveFloat
  "The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to \`full\` packet captures."
  colo_name: String
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL
  "An error message that describes why the packet capture failed. This field only applies to \`full\` packet captures."
  error_message: String
}

"The packet capture filter. When this field is empty, all packets are captured."
type pcaps_filter_v1 {
  "The destination IP address of the packet."
  destination_address: String
  "The destination port of the packet."
  destination_port: Float
  "The protocol number of the packet."
  protocol: Float
  "The source IP address of the packet."
  source_address: String
  "The source port of the packet."
  source_port: Float
}

"The ID for the packet capture."
scalar pcaps_id @length(min: 32, max: 32)

"The status of the packet capture request."
enum pcaps_status {
  unknown
  success
  pending
  running
  conversion_pending
  conversion_running
  complete
  failed
}

enum pcaps_system @typescript(type: "\\"magic-transit\\"") @example(value: "\\"magic-transit\\"") {
  magic_transit @enum(value: "\\"magic-transit\\"")
}

"The type of packet capture. \`Simple\` captures sampled packets, and \`full\` captures entire payloads and non-sampled packets."
enum pcaps_type {
  simple
  full
}

type magic_pcap_collection_list_packet_capture_requests_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union magic_pcap_collection_list_pca_ps_bucket_ownership_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_ownership_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_list_pca_ps_bucket_ownership_4xx_response") = pcaps_ownership_collection | magic_pcap_collection_list_pca_ps_bucket_ownership_4xx_response

type pcaps_ownership_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [pcaps_ownership_response]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type pcaps_ownership_response {
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL!
  "The ownership challenge filename stored in the bucket."
  filename: String!
  "The bucket ID associated with the packet captures API."
  id: query_magic_pcap_collection_list_pca_ps_bucket_ownership_oneOf_0_allOf_1_result_items_id!
  status: query_magic_pcap_collection_list_pca_ps_bucket_ownership_oneOf_0_allOf_1_result_items_status!
  "The RFC 3339 timestamp when the bucket was added to packet captures API."
  submitted: DateTime!
  "The RFC 3339 timestamp when the bucket was validated."
  validated: DateTime
}

"The bucket ID associated with the packet captures API."
scalar query_magic_pcap_collection_list_pca_ps_bucket_ownership_oneOf_0_allOf_1_result_items_id @length(min: 32, max: 32)

"The status of the ownership challenge. Can be pending, success or failed."
enum query_magic_pcap_collection_list_pca_ps_bucket_ownership_oneOf_0_allOf_1_result_items_status {
  pending
  success
  failed
}

type magic_pcap_collection_list_pca_ps_bucket_ownership_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union magic_pcap_collection_get_pcap_request_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_get_pcap_request_4xx_response") = pcaps_single_response | magic_pcap_collection_get_pcap_request_4xx_response

type pcaps_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_magic_pcap_collection_get_pcap_request_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_magic_pcap_collection_get_pcap_request_oneOf_0_allOf_1_result {
  filter_v1: pcaps_filter_v1
  "The ID for the packet capture."
  id: pcaps_id
  status: pcaps_status
  "The RFC 3339 timestamp when the packet capture was created."
  submitted: DateTime
  system: pcaps_system
  "The packet capture duration in seconds."
  time_limit: PositiveFloat
  type: pcaps_type
  "The maximum number of bytes to capture. This field only applies to \`full\` packet captures."
  byte_limit: PositiveFloat
  "The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to \`full\` packet captures."
  colo_name: String
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL
  "An error message that describes why the packet capture failed. This field only applies to \`full\` packet captures."
  error_message: String
}

type magic_pcap_collection_get_pcap_request_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_railguns_list_railguns_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_railguns_list_railguns_4xx_response") = railgun_response_collection | account_railguns_list_railguns_4xx_response

type railgun_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [railgun]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type railgun {
  "When the Railgun was activated."
  activated_on: DateTime!
  activation_key: activation_key!
  "The build identifier for the Railgun receiver."
  build: String!
  "When the Railgun was created."
  created_on: DateTime!
  "Flag to determine if the Railgun is accepting connections."
  enabled: Boolean!
  "Railgun identifier tag."
  id: railgun_components_schemas_identifier!
  "When the Railgun was last modified."
  modified_on: DateTime!
  "Readable identifier of the Railgun."
  name: railgun_components_schemas_name!
  "The revision of the Railgun receiver."
  revision: String!
  status: railgun_components_schemas_status!
  upgrade_info: upgrade_info
  "The version of the Railgun receiver."
  version: String!
  "The number of zones using this Railgun."
  zones_connected: Float!
}

scalar activation_key @length(min: null, max: 32)

"Railgun identifier tag."
scalar railgun_components_schemas_identifier @length(min: null, max: 32)

"Readable identifier of the Railgun."
scalar railgun_components_schemas_name @length(min: null, max: 160)

"Status of the Railgun."
enum railgun_components_schemas_status {
  initializing
  active
}

"Defined when the Railgun version is out of date from the latest release from Cloudflare."
type upgrade_info {
  "An HTTP link to download the latest Railgun binary."
  download_link: URL
  "Latest version of the Railgun receiver available to install."
  latest_version: String
}

type account_railguns_list_railguns_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_railguns_railgun_details_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_railguns_railgun_details_4xx_response") = railgun_response_single | account_railguns_railgun_details_4xx_response

type railgun_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type account_railguns_railgun_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union railgun_connections_list_connections_response @statusCodeTypeName(statusCode: 200, typeName: "connection_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_list_connections_4xx_response") = connection_collection_response | railgun_connections_list_connections_4xx_response

type connection_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_connection]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_connection {
  "When the connection was created."
  created_on: DateTime
  "A value indicating whether the connection is enabled or not."
  enabled: Boolean!
  "Connection identifier tag."
  id: connection_components_schemas_identifier!
  "When the connection was last modified."
  modified_on: DateTime
  zone: connection_components_schemas_zone!
}

"Connection identifier tag."
scalar connection_components_schemas_identifier @length(min: null, max: 32)

type connection_components_schemas_zone {
  "Identifier"
  id: common_components_schemas_identifier!
  name: properties_name
}

scalar properties_name @regexp(pattern: "^([a-zA-Z0-9][\\\\-a-zA-Z0-9]*\\\\.)+[\\\\-a-zA-Z0-9]{2,20}$") @typescript(type: "string")

type railgun_connections_list_connections_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union railgun_connections_connection_details_response @statusCodeTypeName(statusCode: 200, typeName: "connection_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_connection_details_4xx_response") = connection_single_response | railgun_connections_connection_details_4xx_response

type connection_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type railgun_connections_connection_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union registrar_domains_get_domain_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_single2") @statusCodeTypeName(statusCode: "4xx", typeName: "registrar_domains_get_domain_4xx_response") = domain_response_single2 | registrar_domains_get_domain_4xx_response

type domain_response_single2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type registrar_domains_get_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_roles_list_roles_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_roles_list_roles_4xx_response") = api_response_collection | account_roles_list_roles_4xx_response

type account_roles_list_roles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_roles_role_details_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_roles_role_details_4xx_response") = response_single | account_roles_role_details_4xx_response

type account_roles_role_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union lists_get_lists_response @statusCodeTypeName(statusCode: 200, typeName: "lists_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_get_lists_4xx_response") = lists_response_collection | lists_get_lists_4xx_response

type lists_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_lists_get_lists_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_lists_get_lists_oneOf_0_allOf_1_result_items {
  "The RFC 3339 timestamp of when the list was created."
  created_on: DateTime
  "An informative summary of the list."
  description: lists_components_schemas_description
  "The unique ID of the list."
  id: list_id!
  kind: kind
  "The RFC 3339 timestamp of when the list was last modified."
  modified_on: DateTime
  name: lists_components_schemas_name
  "The number of items in the list."
  num_items: Float
  "The number of [filters](#filters) referencing the list."
  num_referencing_filters: Float
  JSON: JSON @resolveRoot
}

"An informative summary of the list."
scalar lists_components_schemas_description @length(min: null, max: 500)

"The unique ID of the list."
scalar list_id @length(min: 32, max: 32)

"The type of the list. Each type supports specific list items (IP addresses or redirects)."
enum kind {
  ip
  redirect
}

scalar lists_components_schemas_name @regexp(pattern: "^[a-zA-Z0-9_]+$") @typescript(type: "string")

type lists_get_lists_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union lists_get_bulk_operation_status_response @statusCodeTypeName(statusCode: 200, typeName: "bulk_operation_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_get_bulk_operation_status_4xx_response") = bulk_operation_response_collection | lists_get_bulk_operation_status_4xx_response

type bulk_operation_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_operation
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_operation {
  "The RFC 3339 timestamp of when the operation was completed."
  completed: DateTime
  "A message describing the error when the status is \`failed\`."
  error: String
  "The unique operation ID of the asynchronous action."
  id: String!
  status: query_lists_get_bulk_operation_status_oneOf_0_allOf_1_result_status!
}

"The current status of the asynchronous operation."
enum query_lists_get_bulk_operation_status_oneOf_0_allOf_1_result_status {
  pending
  running
  completed
  failed
}

type lists_get_bulk_operation_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union lists_get_a_list_response @statusCodeTypeName(statusCode: 200, typeName: "list_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_get_a_list_4xx_response") = list_response_collection | lists_get_a_list_4xx_response

type list_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: list
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type list {
  "The RFC 3339 timestamp of when the list was created."
  created_on: DateTime
  "An informative summary of the list."
  description: lists_components_schemas_description
  "The unique ID of the list."
  id: list_id!
  kind: kind
  "The RFC 3339 timestamp of when the list was last modified."
  modified_on: DateTime
  name: lists_components_schemas_name
  "The number of items in the list."
  num_items: Float
  "The number of [filters](#filters) referencing the list."
  num_referencing_filters: Float
}

type lists_get_a_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union lists_get_list_items_response @statusCodeTypeName(statusCode: 200, typeName: "items_list_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_get_list_items_4xx_response") = items_list_response_collection | lists_get_list_items_4xx_response

type items_list_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [item]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_lists_get_list_items_oneOf_0_allOf_1_result_info
}

type item {
  "An informative summary of the list item."
  comment: String
  "The RFC 3339 timestamp of when the item was created."
  created_on: DateTime
  "The unique ID of the list."
  id: list_id!
  "An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64."
  ip: String
  "The RFC 3339 timestamp of when the item was last modified."
  modified_on: DateTime
  redirect: item_redirect
}

"The definition of the redirect."
type item_redirect {
  include_subdomains: Boolean
  preserve_path_suffix: Boolean
  preserve_query_string: Boolean
  source_url: String!
  status_code: query_lists_get_list_items_oneOf_0_allOf_1_result_items_redirect_status_code
  subpath_matching: Boolean
  target_url: URL!
}

enum query_lists_get_list_items_oneOf_0_allOf_1_result_items_redirect_status_code {
  _301 @enum(value: "301")
  _302 @enum(value: "302")
  _307 @enum(value: "307")
  _308 @enum(value: "308")
}

type query_lists_get_list_items_oneOf_0_allOf_1_result_info {
  cursors: query_lists_get_list_items_oneOf_0_allOf_1_result_info_cursors
}

type query_lists_get_list_items_oneOf_0_allOf_1_result_info_cursors {
  after: String
  before: String
}

type lists_get_list_items_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_lists_get_list_items_oneOf_0_allOf_1_result_info
}

union lists_get_a_list_item_response @statusCodeTypeName(statusCode: 200, typeName: "item_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_get_a_list_item_4xx_response") = item_response_collection | lists_get_a_list_item_4xx_response

type item_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: item
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type lists_get_a_list_item_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__acl_list_ac_ls_response @statusCodeTypeName(statusCode: 200, typeName: "acl_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__acl_list_ac_ls_4xx_response") = acl_components_schemas_response_collection | secondary_dns__acl_list_ac_ls_4xx_response

type acl_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [acl]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type acl {
  id: String!
  "Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively."
  ip_range: String!
  "The name of the acl."
  name: String!
}

type secondary_dns__acl_list_ac_ls_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__acl_acl_details_response @statusCodeTypeName(statusCode: 200, typeName: "acl_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__acl_acl_details_4xx_response") = acl_components_schemas_single_response | secondary_dns__acl_acl_details_4xx_response

type acl_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: acl
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__acl_acl_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__peer_list_peers_response @statusCodeTypeName(statusCode: 200, typeName: "peer_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__peer_list_peers_4xx_response") = peer_components_schemas_response_collection | secondary_dns__peer_list_peers_4xx_response

type peer_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [peer]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type peer {
  id: String!
  "IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to."
  ip: String
  "Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones."
  ixfr_enable: Boolean
  "The name of the peer."
  name: String!
  "DNS port of primary or secondary nameserver, depending on what zone this peer is linked to."
  port: Float
  "TSIG authentication will be used for zone transfer if configured."
  tsig_id: String
}

type secondary_dns__peer_list_peers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__peer_peer_details_response @statusCodeTypeName(statusCode: 200, typeName: "peer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__peer_peer_details_4xx_response") = peer_components_schemas_single_response | secondary_dns__peer_peer_details_4xx_response

type peer_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: peer
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__peer_peer_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__tsig_list_tsi_gs_response @statusCodeTypeName(statusCode: 200, typeName: "tsig_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__tsig_list_tsi_gs_4xx_response") = tsig_components_schemas_response_collection | secondary_dns__tsig_list_tsi_gs_4xx_response

type tsig_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [tsig]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type tsig {
  "TSIG algorithm."
  algo: String!
  id: String!
  "TSIG key name."
  name: String!
  "TSIG secret."
  secret: String!
}

type secondary_dns__tsig_list_tsi_gs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__tsig_tsig_details_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__tsig_tsig_details_4xx_response") = components_schemas_single_response | secondary_dns__tsig_tsig_details_4xx_response

type components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: tsig
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__tsig_tsig_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_request_analytics_query_request_analytics_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_request_analytics_query_request_analytics_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_request_analytics_query_request_analytics_4xx_response") = workers_kv_request_analytics_query_request_analytics_200_response | workers_kv_request_analytics_query_request_analytics_4xx_response

type workers_kv_request_analytics_query_request_analytics_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: components_schemas_result
  "Whether the API call was successful"
  success: Boolean!
}

type components_schemas_result {
  data: [query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_data_items]
  "Number of seconds between current time and last processed event, i.e. how many seconds of data could be missing."
  data_lag: NonNegativeFloat!
  max: query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_max
  min: query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_min
  query: schemas_query
  "Total number of rows in the result."
  rows: NonNegativeFloat!
  totals: query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_totals
}

type query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_data_items {
  metrics: [[Int]]
}

type query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_max {
  readKiB: Int
  requests: Int
}

type query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_min {
  readKiB: Int
  requests: Int
}

type schemas_query {
  dimensions: [query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_dimensions_items]
  filters: String
  "Limit number of returned metrics."
  limit: Int
  metrics: [query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_metrics_items]
  "Start of time interval to query, defaults to 6 hours before request received."
  since: DateTime
  sort: [String]
  "End of time interval to query, defaults to current time."
  until: DateTime
}

enum query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_dimensions_items {
  accountId
  responseCode
  requestType
}

enum query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_metrics_items {
  requests
  writeKiB
  readKiB
}

type query_workers_kv_request_analytics_query_request_analytics_oneOf_0_allOf_1_result_allOf_1_totals {
  readKiB: Int
  requests: Int
}

type workers_kv_request_analytics_query_request_analytics_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_stored_data_analytics_query_stored_data_analytics_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_stored_data_analytics_query_stored_data_analytics_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_stored_data_analytics_query_stored_data_analytics_4xx_response") = workers_kv_stored_data_analytics_query_stored_data_analytics_200_response | workers_kv_stored_data_analytics_query_stored_data_analytics_4xx_response

type workers_kv_stored_data_analytics_query_stored_data_analytics_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: stored_components_schemas_result
  "Whether the API call was successful"
  success: Boolean!
}

type stored_components_schemas_result {
  data: [query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_data_items]
  "Number of seconds between current time and last processed event, i.e. how many seconds of data could be missing."
  data_lag: NonNegativeFloat!
  max: query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_max
  min: query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_min
  query: components_schemas_query
  "Total number of rows in the result."
  rows: NonNegativeFloat!
  totals: query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_totals
}

type query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_data_items {
  metrics: [[Int]]
}

type query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_max {
  storedBytes: Int
  storedKeys: Int
}

type query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_min {
  storedBytes: Int
  storedKeys: Int
}

type components_schemas_query {
  dimensions: [namespaceId_const]
  filters: String
  "Limit number of returned metrics."
  limit: Int
  metrics: [query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_metrics_items]
  "Start of time interval to query, defaults to 6 hours before request received."
  since: DateTime
  sort: [String]
  "End of time interval to query, defaults to current time."
  until: DateTime
}

enum namespaceId_const @typescript(type: "\\"namespaceId\\"") @example(value: "\\"namespaceId\\"") {
  namespaceId @enum(value: "\\"namespaceId\\"")
}

enum query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_query_allOf_1_metrics_items {
  storedBytes
  storedKeys
}

type query_workers_kv_stored_data_analytics_query_stored_data_analytics_oneOf_0_allOf_1_result_allOf_1_totals {
  storedBytes: Int
  storedKeys: Int
}

type workers_kv_stored_data_analytics_query_stored_data_analytics_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_namespace_list_namespaces_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_namespace_list_namespaces_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_list_namespaces_4xx_response") = workers_kv_namespace_list_namespaces_200_response | workers_kv_namespace_list_namespaces_4xx_response

type workers_kv_namespace_list_namespaces_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [namespace]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type namespace {
  "Namespace identifier tag."
  id: namespace_identifier!
  "True if keys written on the URL will be URL-decoded before storing. For example, if set to \\"true\\", a key written on the URL as \\"%3F\\" will be stored as \\"?\\"."
  supports_url_encoding: Boolean
  "A human-readable string name for a Namespace."
  title: String!
}

"Namespace identifier tag."
scalar namespace_identifier @length(min: null, max: 32)

type workers_kv_namespace_list_namespaces_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_4xx_response") = workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_200_response | workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_4xx_response

type workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [key]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_oneOf_0_allOf_1_result_info
}

"A name for a value. A value stored under a given key may be retrieved via the same key."
type key {
  "The time, measured in number of seconds since the UNIX epoch, at which the key will expire. This property is omitted for keys that will not expire."
  expiration: Float
  metadata: list_metadata
  "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
  name: key_name!
}

"Arbitrary JSON that is associated with a key."
type list_metadata {
  someMetadataKey: String
}

"A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
scalar key_name @length(min: null, max: 512)

type query_workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_oneOf_0_allOf_1_result_info {
  "Total results returned based on your list parameters."
  count: Float
  "Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure."
  cursor: String
}

type workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_oneOf_1_allOf_0_allOf_1_result_info
}

type query_workers_kv_namespace_list_a_namespace_SINGLE_QUOTE__s_keys_oneOf_1_allOf_0_allOf_1_result_info {
  "Total results returned based on your list parameters."
  count: Float
  "Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure."
  cursor: String
}

union workers_kv_namespace_read_the_metadata_for_a_key_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_namespace_read_the_metadata_for_a_key_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_read_the_metadata_for_a_key_4xx_response") = workers_kv_namespace_read_the_metadata_for_a_key_200_response | workers_kv_namespace_read_the_metadata_for_a_key_4xx_response

type workers_kv_namespace_read_the_metadata_for_a_key_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: list_metadata
  "Whether the API call was successful"
  success: Boolean!
}

type workers_kv_namespace_read_the_metadata_for_a_key_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_namespace_read_key_value_pair_response @statusCodeTypeName(statusCode: 200, typeName: "String_container") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_read_key_value_pair_4xx_response") = String_container | workers_kv_namespace_read_key_value_pair_4xx_response

type workers_kv_namespace_read_key_value_pair_4xx_response {
  String: String @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_videos_list_videos_response @statusCodeTypeName(statusCode: 200, typeName: "video_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_list_videos_4xx_response") = video_response_collection | stream_videos_list_videos_4xx_response

type video_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [videos]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
  "The total number of remaining videos based on cursor position."
  range: Int
  "The total number of videos that match the provided filters."
  total: Int
}

type videos {
  "Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin."
  allowedOrigins: [String]
  "The date and time the media item was created."
  created: DateTime
  "A user-defined identifier for the media creator."
  creator: creator!
  "The duration of the video in seconds. A value of \`-1\` means the duration is unknown. The duration becomes available after the upload and before the video is ready."
  duration: Int
  input: input
  "The live input ID used to upload a video with Stream Live."
  liveInput: liveInput
  "The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of \`-1\` means the value is unknown."
  maxDurationSeconds: Int
  "A user modifiable key-value store used to reference other systems of record for managing videos."
  meta: JSON
  "The date and time the media item was last modified."
  modified: DateTime
  nft: nft
  playback: playback
  "The video's preview page URI. This field is omitted until encoding is complete."
  preview: URL
  "Indicates whether the video is ready for viewing."
  readyToStream: Boolean
  "Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video."
  requireSignedURLs: Boolean
  "The size of the media item in bytes."
  size: Float
  status: media_status
  "The media item's thumbnail URI. This field is omitted until encoding is complete."
  thumbnail: URL
  "The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video."
  thumbnailTimestampPct: NonNegativeFloat
  "A Cloudflare-generated unique identifier for a media item."
  uid: videos_components_schemas_identifier!
  "The date and time when the video upload URL is no longer valid for direct user uploads."
  uploadExpiry: DateTime
  "The date and time the media item was uploaded."
  uploaded: DateTime
  watermark: watermarks
}

"A user-defined identifier for the media creator."
scalar creator @length(min: null, max: 64)

type input {
  "The video height in pixels. A value of \`-1\` means the height is unknown. The value becomes available after the upload and before the video is ready."
  height: Int
  "The video width in pixels. A value of \`-1\` means the width is unknown. The value becomes available after the upload and before the video is ready."
  width: Int
}

"The live input ID used to upload a video with Stream Live."
scalar liveInput @length(min: null, max: 32)

type nft {
  "The ERC-721 compatible contract address."
  contract: query_stream_videos_list_videos_oneOf_0_allOf_1_result_items_nft_contract
  "The token ID for the NFT."
  token: Int
}

"The ERC-721 compatible contract address."
scalar query_stream_videos_list_videos_oneOf_0_allOf_1_result_items_nft_contract @length(min: 42, max: 42)

type playback {
  "DASH Media Presentation Description for the video."
  dash: URL
  "The HLS manifest for the video."
  hls: URL
}

"Specifies a detailed status for a video. If the \`state\` is \`inprogress\` or \`error\`, the \`step\` field returns \`encoding\` or \`manifest\`. If the \`state\` is \`inprogress\`, \`pctComplete\` returns a number between 0 and 100 to indicate the approximate percent of completion. If the \`state\` is \`error\`, \`errorReasonCode\` and \`errorReasonText\` provide additional details."
type media_status {
  "Specifies why the video failed to encode. This field is empty if the video is not in an \`error\` state. Preferred for programmatic use."
  errorReasonCode: String
  "Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an \`error\` state."
  errorReasonText: String
  "Indicates the size of the entire upload in bytes. The value must be a non-negative integer."
  pctComplete: NonNegativeFloat
  state: media_state
}

"Specifies the processing status of the video."
enum media_state {
  pendingupload
  downloading
  queued
  inprogress
  ready
  error
}

"A Cloudflare-generated unique identifier for a media item."
scalar videos_components_schemas_identifier @length(min: null, max: 32)

type watermarks {
  "The date and a time a watermark profile was created."
  created: DateTime
  "The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null."
  downloadedFrom: URL
  "The height of the image in pixels."
  height: Int
  "A short description of the watermark profile."
  name: String
  "The translucency of the image. A value of \`0.0\` makes the image completely transparent, and \`1.0\` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to \`1.0\` will not make the image completely opaque."
  opacity: NonNegativeFloat
  "The whitespace between the adjacent edges (determined by position) of the video and the image. \`0.0\` indicates no padding, and \`1.0\` indicates a fully padded video width or length, as determined by the algorithm."
  padding: NonNegativeFloat
  "The location of the image. Valid positions are: \`upperRight\`, \`upperLeft\`, \`lowerLeft\`, \`lowerRight\`, and \`center\`. Note that \`center\` ignores the \`padding\` parameter."
  position: String
  "The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. \`0.0\` indicates no scaling (use the size of the image as-is), and \`1.0 \`fills the entire video."
  scale: NonNegativeFloat
  "The size of the image in bytes."
  size: Float
  "The unique identifier for a watermark profile."
  uid: watermarks_components_schemas_identifier!
  "The width of the image in pixels."
  width: Int
}

"The unique identifier for a watermark profile."
scalar watermarks_components_schemas_identifier @length(min: null, max: 32)

type stream_videos_list_videos_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
  "The total number of remaining videos based on cursor position."
  range: Int
  "The total number of videos that match the provided filters."
  total: Int
}

"The account identifier tag."
scalar components_schemas_account_identifier @length(min: null, max: 32)

union stream_signing_keys_list_signing_keys_response @statusCodeTypeName(statusCode: 200, typeName: "key_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_signing_keys_list_signing_keys_4xx_response") = key_response_collection | stream_signing_keys_list_signing_keys_4xx_response

type key_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_stream_signing_keys_list_signing_keys_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_stream_signing_keys_list_signing_keys_oneOf_0_allOf_1_result_items {
  "The date and time a signing key was created."
  created: DateTime
  id: String!
}

type stream_signing_keys_list_signing_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_live_inputs_list_live_inputs_response @statusCodeTypeName(statusCode: 200, typeName: "live_input_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_list_live_inputs_4xx_response") = live_input_response_collection | stream_live_inputs_list_live_inputs_4xx_response

type live_input_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_stream_live_inputs_list_live_inputs_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_stream_live_inputs_list_live_inputs_oneOf_0_allOf_1_result {
  liveInputs: [live_input_object_without_url]
  "The total number of remaining live inputs based on cursor position."
  range: Int
  "The total number of live inputs that match the provided filters."
  total: Int
}

type live_input_object_without_url {
  "The date and time the live input was created."
  created: DateTime
  meta: live_input_metadata
  "The date and time the live input was last modified."
  modified: DateTime
  "A unique identifier for a live input."
  uid: live_input_identifier!
}

"A user modifiable key-value store used to reference other systems of record for managing live inputs."
type live_input_metadata {
  name: String
}

"A unique identifier for a live input."
scalar live_input_identifier @length(min: null, max: 32)

type stream_live_inputs_list_live_inputs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_live_inputs_retrieve_a_live_input_response @statusCodeTypeName(statusCode: 200, typeName: "live_input_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_retrieve_a_live_input_4xx_response") = live_input_response_single | stream_live_inputs_retrieve_a_live_input_4xx_response

type live_input_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_live_inputs_retrieve_a_live_input_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input_response @statusCodeTypeName(statusCode: 200, typeName: "output_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input_4xx_response") = output_response_collection | stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input_4xx_response

type output_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [output]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type output {
  "When enabled, live video streamed to the associated live input will be sent to the output URL. When disabled, live video will not be sent to the output URL, even when streaming to the associated live input. Use this to control precisely when you start and stop simulcasting to specific destinations like YouTube and Twitch."
  enabled: Boolean
  "The streamKey used to authenticate against an output's target."
  streamKey: String
  "A unique identifier for the output."
  uid: output_identifier!
  "The URL an output uses to restream."
  url: URL
}

"A unique identifier for the output."
scalar output_identifier @length(min: null, max: 32)

type stream_live_inputs_list_all_outputs_associated_with_a_specified_live_input_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_watermark_profile_list_watermark_profiles_response @statusCodeTypeName(statusCode: 200, typeName: "watermark_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_watermark_profile_list_watermark_profiles_4xx_response") = watermark_response_collection | stream_watermark_profile_list_watermark_profiles_4xx_response

type watermark_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [watermarks]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type stream_watermark_profile_list_watermark_profiles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_watermark_profile_watermark_profile_details_response @statusCodeTypeName(statusCode: 200, typeName: "watermark_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_watermark_profile_watermark_profile_details_4xx_response") = watermark_response_single | stream_watermark_profile_watermark_profile_details_4xx_response

type watermark_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_watermark_profile_watermark_profile_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_webhook_view_webhooks_response @statusCodeTypeName(statusCode: 200, typeName: "webhook_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_webhook_view_webhooks_4xx_response") = webhook_response_single | stream_webhook_view_webhooks_4xx_response

type webhook_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_webhook_view_webhooks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Account identifier tag."
scalar webhook_components_schemas_account_identifier @length(min: null, max: 32)

union stream_videos_retrieve_video_details_response @statusCodeTypeName(statusCode: 200, typeName: "video_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_retrieve_video_details_4xx_response") = video_response_single | stream_videos_retrieve_video_details_4xx_response

type video_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_videos_retrieve_video_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_videos_retreieve_embed_code_html_response @statusCodeTypeName(statusCode: 200, typeName: "String_container") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_retreieve_embed_code_html_4xx_response") = String_container | stream_videos_retreieve_embed_code_html_4xx_response

type stream_videos_retreieve_embed_code_html_4xx_response {
  String: String @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_subtitles__captions_list_captions_or_subtitles_response @statusCodeTypeName(statusCode: 200, typeName: "language_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_subtitles__captions_list_captions_or_subtitles_4xx_response") = language_response_collection | stream_subtitles__captions_list_captions_or_subtitles_4xx_response

type language_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [captions]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type captions {
  "The language label displayed in the native language to users."
  label: String
  "The language tag in BCP 47 format."
  language: String!
}

type stream_subtitles__captions_list_captions_or_subtitles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"A unique identifier for the media file."
scalar schemas_video_identifier @length(min: null, max: 32)

union stream_m_p_4_downloads_list_downloads_response @statusCodeTypeName(statusCode: 200, typeName: "downloads_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_m_p_4_downloads_list_downloads_4xx_response") = downloads_response | stream_m_p_4_downloads_list_downloads_4xx_response

type downloads_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_m_p_4_downloads_list_downloads_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A unique identifier for the MP4 file."
scalar video_identifier @length(min: null, max: 32)

union account_subscriptions_list_subscriptions_response @statusCodeTypeName(statusCode: 200, typeName: "account_subscription_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_subscriptions_list_subscriptions_4xx_response") = account_subscription_response_collection | account_subscriptions_list_subscriptions_4xx_response

type account_subscription_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [subscription]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type subscription {
  app: query_account_subscriptions_list_subscriptions_oneOf_0_allOf_1_result_items_allOf_0_app
  "The list of add-ons subscribed to."
  component_values: [component_value]
  "The monetary unit in which pricing information is displayed."
  currency: String
  "The end of the current period and also when the next billing is due."
  current_period_end: DateTime
  "When the current billing period started. May match initial_period_start if this is the first period."
  current_period_start: DateTime
  frequency: frequency
  "Subscription identifier tag."
  id: subscription_v2_components_schemas_identifier!
  "The price of the subscription that will be billed, in US dollars."
  price: Float
  rate_plan: rate_plan
  state: state
  zone: zone
}

type query_account_subscriptions_list_subscriptions_oneOf_0_allOf_1_result_items_allOf_0_app {
  "app install id."
  install_id: String
}

"A component value for a subscription."
type component_value {
  "The default amount assigned."
  default: Float
  "The name of the component value."
  name: String
  "The unit price for the component value."
  price: Float
  "The amount of the component value assigned."
  value: Float
}

"How often the subscription is renewed automatically."
enum frequency {
  weekly
  monthly
  quarterly
  yearly
}

"Subscription identifier tag."
scalar subscription_v2_components_schemas_identifier @length(min: null, max: 32)

"The rate plan applied to the subscription."
type rate_plan {
  "The currency applied to the rate plan subscription."
  currency: String
  "Whether this rate plan is managed externally from Cloudflare."
  externally_managed: Boolean
  "The ID of the rate plan."
  id: String
  "Whether a rate plan is enterprise-based (or newly adopted term contract)."
  is_contract: Boolean
  "The full name of the rate plan."
  public_name: String
  "The scope that this rate plan applies to."
  scope: String
  "The list of sets this rate plan applies to."
  sets: [String]
}

"The state that the subscription is in."
enum state {
  Trial
  Provisioned
  Paid
  AwaitingPayment
  Cancelled
  Failed
  Expired
}

"A simple zone object. May have null properties if not a zone subscription."
type zone {
  "Identifier"
  id: common_components_schemas_identifier!
  name: properties_name
}

type account_subscriptions_list_subscriptions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union tunnel_route_list_tunnel_routes_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_route_list_tunnel_routes_4xx_response") = route_response_collection | tunnel_route_list_tunnel_routes_4xx_response

type route_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [teamnet]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type teamnet {
  "Optional remark describing the route. Empty if none."
  comment: String!
  "Timestamps when the route was created, formatted in RFC 3339."
  created_at: JSON!
  "If present, indicates route was deleted at the given date (formatted in RFC 3339). If absent, route has not been deleted."
  deleted_at: DateTime
  "CIDR notation of the IPv4 or IPv6 range of the network the route connects to."
  network: JSON!
  "UUID of the Tunnel the route belongs to."
  tunnel_id: JSON!
  "User-friendly name of the Tunnel the route belongs to."
  tunnel_name: JSON
  "UUID of the virtual network this route belongs to."
  virtual_network_id: JSON
}

type tunnel_route_list_tunnel_routes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union tunnel_route_get_tunnel_route_by_ip_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_route_get_tunnel_route_by_ip_4xx_response") = route_response_single | tunnel_route_get_tunnel_route_by_ip_4xx_response

type route_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type tunnel_route_get_tunnel_route_by_ip_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union tunnel_virtual_network_list_virtual_networks_response @statusCodeTypeName(statusCode: 200, typeName: "vnet_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_virtual_network_list_virtual_networks_4xx_response") = vnet_response_collection | tunnel_virtual_network_list_virtual_networks_4xx_response

type vnet_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [virtual_network]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type virtual_network {
  "Optional remark describing the virtual network. Empty if none."
  comment: String!
  "Timestamp of when the virtual network was created, formatted in RFC 3339."
  created_at: JSON!
  "If present, indicates that the virtual network was deleted at the given date (formatted in RFC 3339). If absent, the virtual network has not been deleted."
  deleted_at: DateTime
  "UUID of the virtual network."
  id: vnet_id!
  "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case."
  is_default_network: Boolean!
  "A user-friendly name chosen when the virtual network is created. Cannot be empty."
  name: String!
}

"UUID of the virtual network."
scalar vnet_id @length(min: null, max: 36)

type tunnel_virtual_network_list_virtual_networks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union argo_tunnel_list_argo_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_tunnel_list_argo_tunnels_4xx_response") = tunnel_response_collection | argo_tunnel_list_argo_tunnels_4xx_response

type tunnel_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [argo_tunnel]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type argo_tunnel {
  "Connections between cloudflared and the Cloudflare edge that are serving this tunnel."
  connections: [argo_tunnel_components_schemas_connection]!
  "Timestamps when the tunnel was created, formatted in RFC 3339."
  created_at: JSON!
  "If present, indicates tunnel was deleted at the given date (formatted in RFC 3339). If absent, tunnel has not been deleted."
  deleted_at: DateTime
  "UUID of the tunnel."
  id: tunnel_id!
  "A user-friendly name chosen when the tunnel is created. Cannot be empty."
  name: String!
}

type argo_tunnel_components_schemas_connection {
  "Short ID for the colo this connection is connected to."
  colo_name: String
  "Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting. If this field is true, the connection has disconnected but is still being tracked for these optimized reconnects. If false, the connection is still actively serving."
  is_pending_reconnect: Boolean
  "UUID"
  uuid: uuid!
}

"UUID"
scalar uuid @length(min: null, max: 36)

type argo_tunnel_list_argo_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union argo_tunnel_get_argo_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_tunnel_get_argo_tunnel_4xx_response") = tunnel_response_single | argo_tunnel_get_argo_tunnel_4xx_response

type tunnel_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type argo_tunnel_get_argo_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall__legacy_list_dns_firewall_clusters_response @statusCodeTypeName(statusCode: 200, typeName: "virtual_dns_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall__legacy_list_dns_firewall_clusters_4xx_response") = virtual_dns_response_collection | dns_firewall__legacy_list_dns_firewall_clusters_4xx_response

type virtual_dns_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [virtual_dns]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type virtual_dns {
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean!
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean!
  "Identifier"
  id: common_components_schemas_identifier!
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat!
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat!
  "Last modification of DNS Firewall cluster."
  modified_on: DateTime!
  "DNS Firewall Cluster Name."
  name: virtual_dns_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat
  origin_ips: [query_dns_firewall_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_origin_ips_items]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster).\\nNotes: A ratelimit of 0 turns off the ratelimit. Otherwise the minimum is 100."
  ratelimit: Float
  virtual_dns_ips: [query_dns_firewall__legacy_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_virtual_dns_ips_items]!
}

"DNS Firewall Cluster Name."
scalar virtual_dns_components_schemas_name @length(min: null, max: 160)

type query_dns_firewall__legacy_list_dns_firewall_clusters_oneOf_0_allOf_1_result_items_virtual_dns_ips_items {
  IPv4: IPv4 @resolveRoot
  IPv6: IPv6 @resolveRoot
}

type dns_firewall__legacy_list_dns_firewall_clusters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union dns_firewall__legacy_dns_firewall_cluster_details_response @statusCodeTypeName(statusCode: 200, typeName: "virtual_dns_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall__legacy_dns_firewall_cluster_details_4xx_response") = virtual_dns_single_response | dns_firewall__legacy_dns_firewall_cluster_details_4xx_response

type virtual_dns_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: virtual_dns
  "Whether the API call was successful"
  success: Boolean!
}

type dns_firewall__legacy_dns_firewall_cluster_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_analytics__legacy_table_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_analytics__legacy_table_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_analytics__legacy_table_4xx_response") = dns_firewall_analytics__legacy_table_200_response | dns_firewall_analytics__legacy_table_4xx_response

type dns_firewall_analytics__legacy_table_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type dns_firewall_analytics__legacy_table_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_analytics__legacy_by_time_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_analytics__legacy_by_time_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_analytics__legacy_by_time_4xx_response") = dns_firewall_analytics__legacy_by_time_200_response | dns_firewall_analytics__legacy_by_time_4xx_response

type dns_firewall_analytics__legacy_by_time_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type dns_firewall_analytics__legacy_by_time_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_account_settings_fetch_worker_account_settings_response @statusCodeTypeName(statusCode: 200, typeName: "account_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_account_settings_fetch_worker_account_settings_4xx_response") = account_settings_response | worker_account_settings_fetch_worker_account_settings_4xx_response

type account_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_worker_account_settings_fetch_worker_account_settings_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_account_settings_fetch_worker_account_settings_oneOf_0_allOf_1_result {
  default_usage_model: JSON
  green_compute: JSON
}

type worker_account_settings_fetch_worker_account_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_domain_list_domains_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_domain_list_domains_4xx_response") = schemas_domain_response_collection | worker_domain_list_domains_4xx_response

type schemas_domain_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [domain]
  "Whether the API call was successful"
  success: Boolean!
}

type domain {
  "Worker environment associated with the zone and hostname."
  environment: String
  "Hostname of the Worker Domain."
  hostname: String
  "Identifer of the Worker Domain."
  id: String!
  "Worker service associated with the zone and hostname."
  service: String
  "Identifier of the zone."
  zone_id: String
  "Name of the zone."
  zone_name: String
}

type worker_domain_list_domains_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_domain_get_a_domain_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_domain_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_domain_get_a_domain_4xx_response") = schemas_domain_response_single | worker_domain_get_a_domain_4xx_response

type schemas_domain_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: domain
  "Whether the API call was successful"
  success: Boolean!
}

type worker_domain_get_a_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union durable_objects_namespace_list_namespaces_response @statusCodeTypeName(statusCode: 200, typeName: "durable_objects_namespace_list_namespaces_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "durable_objects_namespace_list_namespaces_4xx_response") = durable_objects_namespace_list_namespaces_200_response | durable_objects_namespace_list_namespaces_4xx_response

type durable_objects_namespace_list_namespaces_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_namespace]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_namespace {
  class: JSON
  id: JSON
  name: JSON
  script: JSON
}

type durable_objects_namespace_list_namespaces_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union durable_objects_namespace_list_objects_response @statusCodeTypeName(statusCode: 200, typeName: "durable_objects_namespace_list_objects_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "durable_objects_namespace_list_objects_4xx_response") = durable_objects_namespace_list_objects_200_response | durable_objects_namespace_list_objects_4xx_response

type durable_objects_namespace_list_objects_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [object]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_durable_objects_namespace_list_objects_oneOf_0_allOf_1_result_info
}

type object {
  "Whether the Durable Object has stored data."
  hasStoredData: Boolean
  "ID of the Durable Object."
  id: String
}

type query_durable_objects_namespace_list_objects_oneOf_0_allOf_1_result_info {
  "Total results returned based on your list parameters."
  count: Float
  "Opaque token indicating the position from which to continue when requesting the next set of records. A valid value for the cursor can be obtained from the cursors object in the result_info structure."
  cursor: String
}

type durable_objects_namespace_list_objects_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_durable_objects_namespace_list_objects_oneOf_1_allOf_0_allOf_1_result_info
}

type query_durable_objects_namespace_list_objects_oneOf_1_allOf_0_allOf_1_result_info {
  "Total results returned based on your list parameters."
  count: Float
  "Opaque token indicating the position from which to continue when requesting the next set of records. A valid value for the cursor can be obtained from the cursors object in the result_info structure."
  cursor: String
}

union queue_list_queues_response @statusCodeTypeName(statusCode: 200, typeName: "queue_list_queues_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_list_queues_4xx_response") = queue_list_queues_200_response | queue_list_queues_4xx_response

type queue_list_queues_200_response {
  errors: JSON
  messages: JSON
  result: [queue]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_queue_list_queues_oneOf_0_allOf_3_result_info
}

type queue {
  consumers: JSON
  consumers_total_count: JSON
  created_on: JSON
  modified_on: JSON
  producers: JSON
  producers_total_count: JSON
  queue_id: JSON
  queue_name: String!
}

type query_queue_list_queues_oneOf_0_allOf_3_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
  total_pages: Int
}

type queue_list_queues_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_queue_list_queues_oneOf_1_allOf_0_allOf_3_result_info
}

type query_queue_list_queues_oneOf_1_allOf_0_allOf_3_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
  total_pages: Int
}

union queue_queue_details_response @statusCodeTypeName(statusCode: 200, typeName: "queue_queue_details_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_queue_details_4xx_response") = queue_queue_details_200_response | queue_queue_details_4xx_response

type queue_queue_details_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: queue
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type queue_queue_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union queue_list_queue_consumers_response @statusCodeTypeName(statusCode: 200, typeName: "queue_list_queue_consumers_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_list_queue_consumers_4xx_response") = queue_list_queue_consumers_200_response | queue_list_queue_consumers_4xx_response

type queue_list_queue_consumers_200_response {
  errors: JSON
  messages: JSON
  result: [consumer]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_queue_list_queue_consumers_oneOf_0_allOf_3_result_info
}

type consumer {
  created_on: JSON
  environment: JSON
  queue_name: JSON
  service: JSON
  settings: query_queue_list_queue_consumers_oneOf_0_allOf_4_result_items_settings
}

type query_queue_list_queue_consumers_oneOf_0_allOf_4_result_items_settings {
  batch_size: Float
  max_retries: Float
  max_wait_time_ms: Float
}

type query_queue_list_queue_consumers_oneOf_0_allOf_3_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
  total_pages: Int
}

type queue_list_queue_consumers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_queue_list_queue_consumers_oneOf_1_allOf_0_allOf_3_result_info
}

type query_queue_list_queue_consumers_oneOf_1_allOf_0_allOf_3_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
  total_pages: Int
}

union worker_script_list_workers_response @statusCodeTypeName(statusCode: 200, typeName: "script_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_script_list_workers_4xx_response") = script_response_collection | worker_script_list_workers_4xx_response

type script_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_worker_script_list_workers_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_script_list_workers_oneOf_0_allOf_1_result_items {
  created_on: JSON
  etag: JSON
  id: JSON
  modified_on: JSON
  usage_model: JSON
}

type worker_script_list_workers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar script_name @regexp(pattern: "^[a-z0-9_][a-z0-9-_]*$") @typescript(type: "string")

union worker_cron_trigger_get_cron_triggers_response @statusCodeTypeName(statusCode: 200, typeName: "cron_trigger_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_cron_trigger_get_cron_triggers_4xx_response") = cron_trigger_response_collection | worker_cron_trigger_get_cron_triggers_4xx_response

type cron_trigger_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_worker_cron_trigger_get_cron_triggers_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_cron_trigger_get_cron_triggers_oneOf_0_allOf_1_result {
  schedules: [query_worker_cron_trigger_get_cron_triggers_oneOf_0_allOf_1_result_schedules_items]
}

type query_worker_cron_trigger_get_cron_triggers_oneOf_0_allOf_1_result_schedules_items {
  created_on: JSON
  cron: JSON
  modified_on: JSON
}

type worker_cron_trigger_get_cron_triggers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_tail_logs_list_tails_response @statusCodeTypeName(statusCode: 200, typeName: "tail_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_tail_logs_list_tails_4xx_response") = tail_response | worker_tail_logs_list_tails_4xx_response

type tail_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_worker_tail_logs_list_tails_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_tail_logs_list_tails_oneOf_0_allOf_1_result {
  expires_at: JSON
  id: JSON
  url: JSON
}

type worker_tail_logs_list_tails_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_script_fetch_usage_model_response @statusCodeTypeName(statusCode: 200, typeName: "usage_model_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_script_fetch_usage_model_4xx_response") = usage_model_response | worker_script_fetch_usage_model_4xx_response

type usage_model_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_worker_script_fetch_usage_model_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_script_fetch_usage_model_oneOf_0_allOf_1_result {
  usage_model: JSON
}

type worker_script_fetch_usage_model_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_subdomain_get_subdomain_response @statusCodeTypeName(statusCode: 200, typeName: "subdomain_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_subdomain_get_subdomain_4xx_response") = subdomain_response | worker_subdomain_get_subdomain_4xx_response

type subdomain_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_worker_subdomain_get_subdomain_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_worker_subdomain_get_subdomain_oneOf_0_allOf_1_result {
  name: JSON
}

type worker_subdomain_get_subdomain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_categories_list_categories_response @statusCodeTypeName(statusCode: 200, typeName: "categories_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_categories_list_categories_4xx_response") = categories_components_schemas_response_collection | zero_trust_gateway_categories_list_categories_4xx_response

type categories_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_categories]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_categories {
  "Whether the category is in beta and subject to change."
  beta: Boolean
  class: class
  "A short summary of domains in the category."
  description: String
  "The identifier for this category. There is only one category per id."
  id: Int
  "The name of the category."
  name: String
  "All subcategories for this category."
  subcategories: [subcategory]
}

"Which account types are allowed to create policies based on this categories. \`blocked\` categories are blocked unconditionally for all accounts. \`removalPending\` categories can be removed from policies but not added. \`noBlock\` categories cannot be blocked."
enum class {
  free
  premium
  blocked
  removalPending
  noBlock
}

type subcategory {
  "Whether the category is in beta and subject to change."
  beta: Boolean
  class: class
  "A short summary of domains in the category."
  description: String
  "The identifier for this category. There is only one category per id."
  id: Int
  "The name of the category."
  name: String
}

type zero_trust_gateway_categories_list_categories_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_rulesets_list_account_rulesets_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_list_account_rulesets_4xx_response") = rulesets_response | account_rulesets_list_account_rulesets_4xx_response

type rulesets_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "A list of rulesets. The returned information will not include the rules in each ruleset."
  result: [ruleset_without_rules]
  "Whether the API call was successful"
  success: Boolean!
}

"A ruleset object."
type ruleset_without_rules {
  "An informative description of the ruleset."
  description: String
  id: rulesets_components_schemas_id!
  kind: schemas_kind
  "The timestamp of when the ruleset was last modified."
  last_updated: DateTime
  "The human-readable name of the ruleset."
  name: String
  phase: phase!
  version: version!
}

scalar rulesets_components_schemas_id @regexp(pattern: "^[0-9a-f]{32}$") @typescript(type: "string")

"The kind of the ruleset."
enum schemas_kind {
  custom
  root
  zone
}

scalar phase @regexp(pattern: "^[a-z_]+$") @typescript(type: "string")

scalar version @regexp(pattern: "^[0-9]+$") @typescript(type: "string")

type account_rulesets_list_account_rulesets_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_get_an_account_entry_point_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_get_an_account_entry_point_ruleset_4xx_response") = ruleset_response | account_rulesets_get_an_account_entry_point_ruleset_4xx_response

type ruleset_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: ruleset
  "Whether the API call was successful"
  success: Boolean!
}

"A ruleset object."
type ruleset {
  "An informative description of the ruleset."
  description: String
  id: rulesets_components_schemas_id!
  kind: schemas_kind
  "The timestamp of when the ruleset was last modified."
  last_updated: DateTime
  "The human-readable name of the ruleset."
  name: String
  phase: phase!
  "The list of rules in the ruleset."
  rules: [rules_components_schemas_rule]
  version: version!
}

"A rule object."
type rules_components_schemas_rule {
  action: rules_components_schemas_action
  action_parameters: action_parameters
  "The categories of the rule."
  categories: [String]
  "An informative description of the rule."
  description: String
  "Whether the rule should be executed."
  enabled: Boolean
  "The expression defining which traffic will match the rule."
  expression: String
  "The unique ID of the rule."
  id: String!
  "The timestamp of when the rule was last modified."
  last_updated: DateTime
  logging: logging
  "The reference of the rule (the rule ID by default)."
  ref: String
  version: schemas_version
}

scalar rules_components_schemas_action @regexp(pattern: "^[a-z_]+$") @typescript(type: "string")

"The parameters configuring the rule action."
type action_parameters {
  id: String
}

"An object configuring the rule's logging behavior."
type logging {
  "Whether to generate a log when the rule matches."
  enabled: Boolean
}

scalar schemas_version @regexp(pattern: "^[0-9]+$") @typescript(type: "string")

type account_rulesets_get_an_account_entry_point_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response") = rulesets_response | account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response

type account_rulesets_list_an_account_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_get_an_account_entry_point_ruleset_version_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_get_an_account_entry_point_ruleset_version_4xx_response") = ruleset_response | account_rulesets_get_an_account_entry_point_ruleset_version_4xx_response

type account_rulesets_get_an_account_entry_point_ruleset_version_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_get_an_account_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_get_an_account_ruleset_4xx_response") = ruleset_response | account_rulesets_get_an_account_ruleset_4xx_response

type account_rulesets_get_an_account_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions_4xx_response") = rulesets_response | account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions_4xx_response

type account_rulesets_list_an_account_ruleset_SINGLE_QUOTE__s_versions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_get_an_account_ruleset_version_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_get_an_account_ruleset_version_4xx_response") = ruleset_response | account_rulesets_get_an_account_ruleset_version_4xx_response

type account_rulesets_get_an_account_ruleset_version_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag_4xx_response") = ruleset_response | account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag_4xx_response

type account_rulesets_list_an_account_ruleset_version_SINGLE_QUOTE__s_rules_by_tag_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union accounts_account_details_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "accounts_account_details_4xx_response") = response_single | accounts_account_details_4xx_response

type accounts_account_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_applications_list_access_applications_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_list_access_applications_4xx_response") = apps_components_schemas_response_collection | access_applications_list_access_applications_4xx_response

type apps_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [apps]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type apps {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  "The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account."
  allowed_idps: [String]
  app_launcher_visible: JSON
  "When set to \`true\`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps."
  auto_redirect_to_identity: Boolean
  cors_headers: cors_headers
  "The custom error message shown to a user when they are denied access to the application."
  custom_deny_message: String
  "The custom URL a user is redirected to when they are denied access to the application."
  custom_deny_url: String
  "The URL or domain of the bookmark."
  domain: String
  "Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks."
  enable_binding_cookie: Boolean
  "Enables the HttpOnly cookie attribute, which increases security against XSS attacks."
  http_only_cookie_attribute: Boolean
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "Sets the SameSite cookie setting, which provides increased security against CSRF attacks."
  same_site_cookie_attribute: String
  "Returns a 401 status code when the request is blocked by a Service Auth policy."
  service_auth_401_redirect: Boolean
  "The amount of time that tokens issued for this application will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or µs), ms, s, m, h."
  session_duration: String
  "Enables automatic authentication through cloudflared."
  skip_interstitial: Boolean
  "The application type."
  type: String
  saas_app: saas_app
}

"Audience tag."
scalar schemas_aud @length(min: null, max: 64)

type cors_headers {
  "Allows all HTTP request headers."
  allow_all_headers: Boolean
  "Allows all HTTP request methods."
  allow_all_methods: Boolean
  "Allows all origins."
  allow_all_origins: Boolean
  "When set to \`true\`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests."
  allow_credentials: Boolean
  "Allowed HTTP request headers."
  allowed_headers: [JSON]
  "Allowed HTTP request methods."
  allowed_methods: [query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_0_allOf_1_cors_headers_allowed_methods_items]
  "Allowed origins."
  allowed_origins: [JSON]
  "The maximum number of seconds the results of a preflight request can be cached."
  max_age: Float
}

enum query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_0_allOf_1_cors_headers_allowed_methods_items {
  GET
  POST
  HEAD
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}

type saas_app {
  "The service provider's endpoint that is responsible for receiving and parsing a SAML assertion."
  consumer_service_url: URL
  created_at: DateTime
  custom_attributes: query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes
  "The unique identifier for your SaaS application."
  idp_entity_id: URL
  name_id_format: query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_name_id_format
  "The Access public certificate that will be used to verify your identity."
  public_key: String
  "A globally unique name for an identity or service provider."
  sp_entity_id: String
  "The endpoint where your SaaS application will send login requests."
  sso_endpoint: URL
  updated_at: DateTime
}

type query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes {
  "The name of the attribute."
  name: String
  name_format: query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes_name_format
  source: query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes_source
}

"A globally unique name for an identity or service provider."
enum query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes_name_format {
  urn_oasis_names_tc_SAML_2_0_attrname_format_unspecified @enum(value: "\\"urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified\\"")
  urn_oasis_names_tc_SAML_2_0_attrname_format_basic @enum(value: "\\"urn:oasis:names:tc:SAML:2.0:attrname-format:basic\\"")
  urn_oasis_names_tc_SAML_2_0_attrname_format_uri @enum(value: "\\"urn:oasis:names:tc:SAML:2.0:attrname-format:uri\\"")
}

type query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_custom_attributes_source {
  "The name of the IdP attribute."
  name: String
}

"The format of the name identifier sent to the SaaS application."
enum query_access_applications_list_access_applications_oneOf_0_allOf_1_result_items_anyOf_1_allOf_1_saas_app_name_id_format {
  id
  email
}

type access_applications_list_access_applications_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response") = ca_components_schemas_response_collection | access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response

type ca_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ca]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ca {
  "The Application Audience (AUD) tag. Identifies the application associated with the CA."
  aud: aud
  "The ID of the CA."
  id: ca_components_schemas_id
  "The public key to add to your SSH server configuration."
  public_key: String
}

"The Application Audience (AUD) tag. Identifies the application associated with the CA."
scalar aud @length(min: null, max: 64)

"The ID of the CA."
scalar ca_components_schemas_id @length(min: null, max: 48)

type access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_applications_get_an_access_application_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_get_an_access_application_4xx_response") = apps_components_schemas_single_response | access_applications_get_an_access_application_4xx_response

type apps_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: apps
  "Whether the API call was successful"
  success: Boolean!
}

type access_applications_get_an_access_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_applications_test_access_policies_response @statusCodeTypeName(statusCode: 200, typeName: "policy_check_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_test_access_policies_4xx_response") = policy_check_response | access_applications_test_access_policies_4xx_response

type policy_check_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_access_applications_test_access_policies_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_access_applications_test_access_policies_oneOf_0_allOf_1_result {
  app_state: query_access_applications_test_access_policies_oneOf_0_allOf_1_result_app_state
  user_identity: query_access_applications_test_access_policies_oneOf_0_allOf_1_result_user_identity
}

type query_access_applications_test_access_policies_oneOf_0_allOf_1_result_app_state {
  "UUID"
  app_uid: uuid!
  aud: String
  hostname: String
  name: String
  policies: [JSON]
  status: String
}

type query_access_applications_test_access_policies_oneOf_0_allOf_1_result_user_identity {
  account_id: String
  device_sessions: JSON
  email: EmailAddress
  geo: query_access_applications_test_access_policies_oneOf_0_allOf_1_result_user_identity_geo
  iat: Int
  id: String
  is_gateway: Boolean
  is_warp: Boolean
  name: String
  "UUID"
  user_uuid: uuid!
  version: Int
}

type query_access_applications_test_access_policies_oneOf_0_allOf_1_result_user_identity_geo {
  country: String
}

type access_applications_test_access_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_policies_get_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_policies_get_an_access_policy_4xx_response") = policies_components_schemas_single_response | access_policies_get_an_access_policy_4xx_response

type policies_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_policies
  "Whether the API call was successful"
  success: Boolean!
}

type schemas_policies {
  "Administrators who can approve a temporary authentication request."
  approval_groups: [approval_group]
  "Requires the user to request access from an administrator at the start of each session."
  approval_required: Boolean
  created_at: DateTime
  decision: decision
  "Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule]
  "The policy ID."
  id: components_schemas_uuid!
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule]
  "The name of the Access policy."
  name: String
  "The order of execution for this policy. Must be unique for each policy."
  precedence: Int
  "A custom message that will appear on the purpose justification screen."
  purpose_justification_prompt: String
  "Require users to enter a justification when they log in to the application."
  purpose_justification_required: Boolean
  "Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule]
  updated_at: DateTime
}

"A group of email addresses that can approve a temporary authentication request."
type approval_group {
  "The number of approvals needed to obtain access."
  approvals_needed: NonNegativeFloat!
  "A list of emails that can approve the access request."
  email_addresses: [JSON]
  "The UUID of an re-usable email list."
  email_list_uuid: String
}

"The action Access will take if a user matches this policy."
enum decision {
  allow
  deny
  non_identity
  bypass
}

union rule_components_schemas_rule = Email | Email_domain | Everyone | IP_ranges | IP_list | Valid_certificate | Access_groups | Azure_group | Github_organization | Google_Workspace_group | Okta_group | SAML_group

"Matches a specific email."
type Email {
  email: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_0_email!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_0_email {
  "The email of the user."
  email: EmailAddress!
}

"Match an entire email domain."
type Email_domain {
  email_domain: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_1_email_domain!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_1_email_domain {
  "The email domain to match."
  domain: String!
}

"Matches everyone."
type Everyone {
  "An empty object which matches on all users."
  everyone: JSON!
}

"Matches an IP address block."
type IP_ranges {
  ip: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_3_ip!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_3_ip {
  "An IPv4 or IPv6 CIDR block."
  ip: String!
}

"Matches an IP address from a list."
type IP_list {
  ip_list: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_4_ip_list!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_4_ip_list {
  "The ID of a previously created IP list."
  id: String!
}

"Matches any valid client certificate."
type Valid_certificate {
  certificate: JSON!
}

"Matches an Access group."
type Access_groups {
  group: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_6_group!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_6_group {
  "The ID of a previously created Access group."
  id: String!
}

"Matches an Azure group.\\nRequires an Azure identity provider."
type Azure_group {
  azureAD: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_7_azureAD!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_7_azureAD {
  "The ID of your Azure identity provider."
  connection_id: String!
  "The ID of an Azure group."
  id: String!
}

"Matches a Github organization.\\nRequires a Github identity provider."
type Github_organization {
  github_organization: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_8_github_organization! @resolveRootField(field: "github-organization")
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_8_github_organization {
  "The ID of your Github identity provider."
  connection_id: String!
  "The name of the organization."
  name: String!
}

"Matches a group in Google Workspace.\\nRequires a Google Workspace identity provider."
type Google_Workspace_group {
  gsuite: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_9_gsuite!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_9_gsuite {
  "The ID of your Google Workspace identity provider."
  connection_id: String!
  "The email of the Google Workspace group."
  email: EmailAddress!
}

"Matches an Okta group.\\nRequires an Okta identity provider."
type Okta_group {
  okta: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_10_okta!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_10_okta {
  "The ID of your Okta identity provider."
  connection_id: String!
  "The email of the Okta group."
  email: EmailAddress!
}

"Matches a SAML group.\\nRequires a SAML identity provider."
type SAML_group {
  saml: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_11_saml!
}

type query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_11_saml {
  "The name of the SAML attribute."
  attribute_name: String!
  "The SAML attribute value to look for."
  attribute_value: EmailAddress!
}

"The policy ID."
scalar components_schemas_uuid @length(min: null, max: 36)

type access_policies_get_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_single_response | access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response

type ca_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_policies_list_access_policies_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_policies_list_access_policies_4xx_response") = policies_components_schemas_response_collection | access_policies_list_access_policies_4xx_response

type policies_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_policies]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type access_policies_list_access_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_bookmark_applications__deprecated_list_bookmark_applications_response @statusCodeTypeName(statusCode: 200, typeName: "bookmarks_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_bookmark_applications__deprecated_list_bookmark_applications_4xx_response") = bookmarks_components_schemas_response_collection | access_bookmark_applications__deprecated_list_bookmark_applications_4xx_response

type bookmarks_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [bookmarks]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type bookmarks {
  "Displays the application in the App Launcher."
  app_launcher_visible: Boolean
  created_at: DateTime
  "The domain of the Bookmark application."
  domain: String
  "The unique identifier for the Bookmark application."
  id: JSON
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the Bookmark application."
  name: String
  updated_at: DateTime
}

type access_bookmark_applications__deprecated_list_bookmark_applications_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_bookmark_applications__deprecated_get_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "bookmarks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_bookmark_applications__deprecated_get_a_bookmark_application_4xx_response") = bookmarks_components_schemas_single_response | access_bookmark_applications__deprecated_get_a_bookmark_application_4xx_response

type bookmarks_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: bookmarks
  "Whether the API call was successful"
  success: Boolean!
}

type access_bookmark_applications__deprecated_get_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_m_tls_authentication_list_m_tls_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_m_tls_authentication_list_m_tls_certificates_4xx_response") = certificates_components_schemas_response_collection | access_m_tls_authentication_list_m_tls_certificates_4xx_response

type certificates_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_certificates]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_certificates {
  "The hostnames of the applications that will use this certificate."
  associated_hostnames: [String]
  created_at: DateTime
  expires_on: DateTime
  "The MD5 fingerprint of the certificate."
  fingerprint: String
  "The ID of the application that will use this certificate."
  id: JSON
  "The name of the certificate."
  name: String
  updated_at: DateTime
}

type access_m_tls_authentication_list_m_tls_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_m_tls_authentication_get_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_m_tls_authentication_get_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | access_m_tls_authentication_get_an_m_tls_certificate_4xx_response

type certificates_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_certificates
  "Whether the API call was successful"
  success: Boolean!
}

type access_m_tls_authentication_get_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_groups_list_access_groups_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_groups_list_access_groups_4xx_response") = groups_components_schemas_response_collection | access_groups_list_access_groups_4xx_response

type groups_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_groups]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_groups {
  created_at: DateTime
  "Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule]
  "The unique identifier for the Access group."
  id: JSON!
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule]
  "The name of the Access group."
  name: String
  "Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule]
  updated_at: DateTime
}

type access_groups_list_access_groups_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_groups_get_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_groups_get_an_access_group_4xx_response") = groups_components_schemas_single_response | access_groups_get_an_access_group_4xx_response

type groups_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_groups
  "Whether the API call was successful"
  success: Boolean!
}

type access_groups_get_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_identity_providers_list_access_identity_providers_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_identity_providers_list_access_identity_providers_4xx_response") = identity_providers_components_schemas_response_collection | access_identity_providers_list_access_identity_providers_4xx_response

type identity_providers_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [identity_providers]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type identity_providers {
  config: JSON
  "UUID"
  id: uuid!
  "The name of the identity provider, shown to users on the login page."
  name: String
  "The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/)."
  type: String
}

type access_identity_providers_list_access_identity_providers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union access_identity_providers_get_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_identity_providers_get_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | access_identity_providers_get_an_access_identity_provider_4xx_response

type identity_providers_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: identity_providers
  "Whether the API call was successful"
  success: Boolean!
}

type access_identity_providers_get_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_key_configuration_get_the_access_key_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keys_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_key_configuration_get_the_access_key_configuration_4xx_response") = keys_components_schemas_single_response | access_key_configuration_get_the_access_key_configuration_4xx_response

type keys_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  "The number of days until the next key rotation."
  days_until_next_rotation: Float
  "The number of days between key rotations."
  key_rotation_interval_days: PositiveFloat
  "The timestamp of the previous key rotation."
  last_key_rotation_at: DateTime
}

type access_key_configuration_get_the_access_key_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  "The number of days until the next key rotation."
  days_until_next_rotation: Float
  "The number of days between key rotations."
  key_rotation_interval_days: PositiveFloat
  "The timestamp of the previous key rotation."
  last_key_rotation_at: DateTime
}

union access_authentication_logs_get_access_authentication_logs_response @statusCodeTypeName(statusCode: 200, typeName: "access_requests_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_authentication_logs_get_access_authentication_logs_4xx_response") = access_requests_components_schemas_response_collection | access_authentication_logs_get_access_authentication_logs_4xx_response

type access_requests_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [access_requests]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type access_requests {
  "The event that occurred, such as a login attempt."
  action: String
  "The result of the authentication event."
  allowed: Boolean
  "The URL of the Access application."
  app_domain: String
  "The unique identifier for the Access application."
  app_uid: String
  "The IdP used to authenticate."
  connection: String
  created_at: DateTime
  "The IP address of the authenticating user."
  ip_address: String
  "The unique identifier for the request to Cloudflare."
  ray_id: ray_id
  "The email address of the authenticating user."
  user_email: EmailAddress
}

"The unique identifier for the request to Cloudflare."
scalar ray_id @length(min: null, max: 16)

type access_authentication_logs_get_access_authentication_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_organization_get_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_organization_get_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zero_trust_organization_get_your_zero_trust_organization_4xx_response

type organizations_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: organizations
  "Whether the API call was successful"
  success: Boolean!
}

type organizations {
  "The unique subdomain assigned to your Zero Trust organization."
  auth_domain: String
  created_at: DateTime
  "Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled."
  is_ui_read_only: Boolean
  login_design: login_design
  "The name of your Zero Trust organization."
  name: String
  updated_at: DateTime
}

type login_design {
  "The background color on your login page."
  background_color: String
  "The text at the bottom of your login page."
  footer_text: String
  "The text at the top of your login page."
  header_text: String
  "The URL of the logo on your login page."
  logo_path: URL
  "The text color on your login page."
  text_color: String
}

type zero_trust_organization_get_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_service_tokens_list_service_tokens_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_list_service_tokens_4xx_response") = service_tokens_components_schemas_response_collection | access_service_tokens_list_service_tokens_4xx_response

type service_tokens_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [service_tokens]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type service_tokens {
  "The Client ID for the service token. Access will check for this value in the \`CF-Access-Client-ID\` request header."
  client_id: String
  created_at: DateTime
  "The ID of the service token."
  id: JSON
  "The name of the service token."
  name: String
  updated_at: DateTime
}

type access_service_tokens_list_service_tokens_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_users_get_users_response @statusCodeTypeName(statusCode: 200, typeName: "users_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_users_get_users_4xx_response") = users_components_schemas_response_collection | zero_trust_users_get_users_4xx_response

type users_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [users]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_zero_trust_users_get_users_oneOf_0_allOf_1_result_info
}

type users {
  "True if the user has authenticated with Cloudflare Access."
  access_seat: Boolean
  "The number of active devices registered to the user."
  active_device_count: Float
  created_at: DateTime
  "The email of the user."
  email: EmailAddress
  "True if the user has logged into the WARP client."
  gateway_seat: Boolean
  "The ID of the user."
  id: String!
  "The time at which the user last successfully logged in."
  last_successful_login: DateTime
  "The name of the user."
  name: String
  "The unique API identifier for the Zero Trust seat."
  seat_uid: JSON
  "The unique API identifier for the user."
  uid: JSON
  updated_at: DateTime
}

type query_zero_trust_users_get_users_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type zero_trust_users_get_users_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_zero_trust_users_get_users_oneOf_0_allOf_1_result_info
}

union zero_trust_users_get_failed_logins_response @statusCodeTypeName(statusCode: 200, typeName: "failed_login_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_users_get_failed_logins_4xx_response") = failed_login_response | zero_trust_users_get_failed_logins_4xx_response

type failed_login_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_zero_trust_users_get_failed_logins_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_zero_trust_users_get_failed_logins_oneOf_0_allOf_1_result_items {
  expiration: Int
  metadata: query_zero_trust_users_get_failed_logins_oneOf_0_allOf_1_result_items_metadata
}

type query_zero_trust_users_get_failed_logins_oneOf_0_allOf_1_result_items_metadata {
  app_name: String
  aud: String
  datetime: DateTime
  ray_id: String
  user_email: EmailAddress
  user_uuid: String
}

type zero_trust_users_get_failed_logins_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_alert_types_get_alert_types_response @statusCodeTypeName(statusCode: 200, typeName: "alert_types_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_alert_types_get_alert_types_4xx_response") = alert_types_components_schemas_response_collection | notification_alert_types_get_alert_types_4xx_response

type alert_types_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result {
  Origin_Monitoring: [query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result_Origin_Monitoring_items] @resolveRootField(field: "Origin Monitoring")
  additionalProperties: JSON @resolveRoot
}

type query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result_Origin_Monitoring_items {
  description: String
  display_name: String
  filter_options: [query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result_Origin_Monitoring_items_filter_options_items]
  type: String
}

type query_notification_alert_types_get_alert_types_oneOf_0_allOf_1_result_Origin_Monitoring_items_filter_options_items {
  ComparisonOperator: String
  Key: String
  Optional: Boolean
}

type notification_alert_types_get_alert_types_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_mechanism_eligibility_get_delivery_mechanism_eligibility_response @statusCodeTypeName(statusCode: 200, typeName: "eligibility_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_mechanism_eligibility_get_delivery_mechanism_eligibility_4xx_response") = eligibility_components_schemas_response_collection | notification_mechanism_eligibility_get_delivery_mechanism_eligibility_4xx_response

type eligibility_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_notification_mechanism_eligibility_get_delivery_mechanism_eligibility_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_notification_mechanism_eligibility_get_delivery_mechanism_eligibility_oneOf_0_allOf_1_result {
  email: query_notification_mechanism_eligibility_get_delivery_mechanism_eligibility_oneOf_0_allOf_1_result_email
  additionalProperties: JSON @resolveRoot
}

type query_notification_mechanism_eligibility_get_delivery_mechanism_eligibility_oneOf_0_allOf_1_result_email {
  eligible: Boolean
  ready: Boolean
  type: String
}

type notification_mechanism_eligibility_get_delivery_mechanism_eligibility_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_destinations_with_pager_duty_list_pager_duty_services_response @statusCodeTypeName(statusCode: 200, typeName: "pagerduty_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_destinations_with_pager_duty_list_pager_duty_services_4xx_response") = pagerduty_components_schemas_response_collection | notification_destinations_with_pager_duty_list_pager_duty_services_4xx_response

type pagerduty_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [pagerduty]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type pagerduty {
  "UUID"
  id: uuid!
  "The name of the pagerduty service."
  name: String
}

type notification_destinations_with_pager_duty_list_pager_duty_services_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_webhooks_list_webhooks_response @statusCodeTypeName(statusCode: 200, typeName: "webhooks_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_webhooks_list_webhooks_4xx_response") = webhooks_components_schemas_response_collection | notification_webhooks_list_webhooks_4xx_response

type webhooks_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [webhooks]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type webhooks {
  "Timestamp of when the webhook destination was created."
  created_at: DateTime
  "UUID"
  id: uuid!
  "Timestamp of the last time an attempt to dispatch a notification to this webhook failed."
  last_failure: DateTime
  "Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook."
  last_success: DateTime
  "The name of the webhook destination. This will be included in the request body when you receive a webhook notification."
  name: String
  "Optional secret that will be passed in the \`cf-webhook-auth\` header when dispatching a webhook notification. Secrets are not returned in any API response body."
  secret: String
  type: webhooks_components_schemas_type
  "The POST endpoint to call when dispatching a notification."
  url: URL
}

"Type of webhook endpoint."
enum webhooks_components_schemas_type {
  slack
  generic
  gchat
}

type notification_webhooks_list_webhooks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_webhooks_get_a_webhook_response @statusCodeTypeName(statusCode: 200, typeName: "webhooks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_webhooks_get_a_webhook_4xx_response") = webhooks_components_schemas_single_response | notification_webhooks_get_a_webhook_4xx_response

type webhooks_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: webhooks
  "Whether the API call was successful"
  success: Boolean!
}

type notification_webhooks_get_a_webhook_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union notification_history_list_history_response @statusCodeTypeName(statusCode: 200, typeName: "history_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_history_list_history_4xx_response") = history_components_schemas_response_collection | notification_history_list_history_4xx_response

type history_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [history]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_notification_history_list_history_oneOf_0_allOf_1_result_info
}

type history {
  "Message body included in the notification sent."
  alert_body: String
  "Type of notification that has been dispatched."
  alert_type: String
  "Description of the notification policy (if present)."
  description: String
  "UUID"
  id: uuid!
  "The mechanism to which the notification has been dispatched."
  mechanism: EmailAddress
  mechanism_type: mechanism_type
  "Name of the policy."
  name: String
  "Timestamp of when the notification was dispatched in ISO 8601 format."
  sent: DateTime
}

"The type of mechanism to which the notification has been dispatched. This can be email/pagerduty/webhook based on the mechanism configured."
enum mechanism_type {
  email
  pagerduty
  webhook
}

type query_notification_history_list_history_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
}

type notification_history_list_history_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_notification_history_list_history_oneOf_0_allOf_1_result_info
}

union notification_policies_list_notification_policies_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_response_collection_2") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_policies_list_notification_policies_4xx_response") = policies_components_schemas_response_collection_2 | notification_policies_list_notification_policies_4xx_response

type policies_components_schemas_response_collection_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_policies]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type components_schemas_policies {
  "Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values."
  alert_type: String
  created: DateTime
  "Optional description for the Notification policy."
  description: String
  "Whether or not the Notification policy is enabled."
  enabled: Boolean
  filters: components_schemas_filters
  "UUID"
  id: uuid!
  mechanisms: mechanisms
  modified: DateTime
  "Name of the policy."
  name: String
}

type components_schemas_filters {
  slo: [String]
  additionalProperties: JSON @resolveRoot
}

"List of IDs that will be used when dispatching a notification. IDs for email type will be the email address."
type mechanisms {
  email: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_email_items]
  pagerduty: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_pagerduty_items]
  webhooks: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_webhooks_items]
  additionalProperties: JSON @resolveRoot
}

type query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_email_items {
  id: EmailAddress
}

type query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_pagerduty_items {
  id: String
}

type query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_webhooks_items {
  id: String
}

type notification_policies_list_notification_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_policies_get_a_notification_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_policies_get_a_notification_policy_4xx_response") = policies_components_schemas_single_response_2 | notification_policies_get_a_notification_policy_4xx_response

type policies_components_schemas_single_response_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: components_schemas_policies
  "Whether the API call was successful"
  success: Boolean!
}

type notification_policies_get_a_notification_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_level_custom_nameservers_list_account_custom_nameservers_response @statusCodeTypeName(statusCode: 200, typeName: "acns_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_list_account_custom_nameservers_4xx_response") = acns_response_collection | account_level_custom_nameservers_list_account_custom_nameservers_4xx_response

type acns_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [Custom_NS]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"A single account custom nameserver."
type Custom_NS {
  "A and AAAA records associated with the nameserver."
  dns_records: [query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_dns_records_items]!
  "The FQDN of the name server."
  ns_name: Hostname!
  status: query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_status!
  "Identifier"
  zone_tag: common_components_schemas_identifier!
}

type query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_dns_records_items {
  type: query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_dns_records_items_type
  "DNS record contents (an IPv4 or IPv6 address)."
  value: String
}

"DNS record type."
enum query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_dns_records_items_type {
  A
  AAAA
}

"Represents hostname values"
scalar Hostname

"Verification status of the nameserver."
enum query_account_level_custom_nameservers_list_account_custom_nameservers_oneOf_0_allOf_1_result_items_status {
  moved
  pending
  verified
}

type account_level_custom_nameservers_list_account_custom_nameservers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Account identifier tag."
scalar custom_ns_components_schemas_identifier @length(min: null, max: 32)

union account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers_response @statusCodeTypeName(statusCode: 200, typeName: "availability_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers_4xx_response") = availability_response | account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers_4xx_response

type availability_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [Hostname]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type account_level_custom_nameservers_get_eligible_zones_for_account_custom_nameservers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_list_devices_response @statusCodeTypeName(statusCode: 200, typeName: "devices_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_list_devices_4xx_response") = devices_response | devices_list_devices_4xx_response

type devices_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [devices]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type devices {
  "When the device was created."
  created: DateTime
  "True if the device was deleted."
  deleted: Boolean
  device_type: platform
  "Device ID."
  id: devices_components_schemas_uuid
  "IPv4 or IPv6 address."
  ip: String
  "The device's public key."
  key: String
  "When the device last connected to Cloudflare services."
  last_seen: DateTime
  "The device mac address."
  mac_address: String
  "The device manufacturer name."
  manufacturer: String
  "The device model name."
  model: String
  "The device name."
  name: String
  "The Linux distro name."
  os_distro_name: String
  "The Linux distro revision."
  os_distro_revision: String
  "The operating system version."
  os_version: String
  "When the device was revoked."
  revoked_at: DateTime
  "The device serial number."
  serial_number: String
  "When the device was updated."
  updated: DateTime
  user: user
  "The WARP client version."
  version: String
}

enum platform {
  windows
  mac
  linux
  android
  ios
}

"Device ID."
scalar devices_components_schemas_uuid @length(min: null, max: 36)

type user {
  "The contact email address of the user."
  email: EmailAddress
  "UUID"
  id: uuid!
  "The enrolled device user's name."
  name: String
}

type devices_list_devices_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_list_device_settings_policies_response @statusCodeTypeName(statusCode: 200, typeName: "device_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_list_device_settings_policies_4xx_response") = device_settings_response_collection | devices_list_device_settings_policies_4xx_response

type device_settings_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [device_settings_policy]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type device_settings_policy {
  "Whether to allow the user to switch WARP between modes."
  allow_mode_switch: Boolean
  "Whether to receive update notifications when a new version of the client is available."
  allow_updates: Boolean
  "Whether to allow devices to leave the organization."
  allowed_to_leave: Boolean
  "The amount of time in minutes to reconnect after having been disabled."
  auto_connect: Float
  "Turn on the captive portal after the specified amount of time."
  captive_portal: Float
  "Whether the policy is the default policy for an account."
  default: Boolean
  "If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set."
  disable_auto_fallback: Boolean
  "Whether the policy will be applied to matching devices."
  enabled: Boolean
  exclude: [split_tunnel]
  fallback_domains: [fallback_domain]
  gateway_unique_id: String
  include: [split_tunnel_include]
  "The wirefilter expression to match devices."
  match: components_schemas_match
  "The name of the device settings policy."
  name: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_name
  "UUID"
  policy_id: uuid!
  "The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field."
  precedence: Float
  service_mode_v2: service_mode_v2
  "The URL to launch when the Send Feedback button is clicked."
  support_url: URL
  "Whether to allow the user to turn off the WARP switch and disconnect the client."
  switch_locked: Boolean
}

type split_tunnel {
  "The address in CIDR format to exclude from the tunnel. If address is present, host must not be present."
  address: String!
  "A description of the split tunnel item, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_exclude_items_description!
  "The domain name to exclude from the tunnel. If host is present, address must not be present."
  host: String
}

"A description of the split tunnel item, displayed in the client UI."
scalar query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_exclude_items_description @length(min: null, max: 100)

type fallback_domain {
  "A description of the fallback domain, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_fallback_domains_items_description
  "A list of IP addresses to handle domain resolution."
  dns_server: [JSON]
  "The domain suffix to match when resolving locally."
  suffix: String!
}

"A description of the fallback domain, displayed in the client UI."
scalar query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_fallback_domains_items_description @length(min: null, max: 100)

type split_tunnel_include {
  "The address in CIDR format to include in the tunnel. If address is present, host must not be present."
  address: String!
  "A description of the split tunnel item, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_include_items_description!
  "The domain name to include in the tunnel. If host is present, address must not be present."
  host: String
}

"A description of the split tunnel item, displayed in the client UI."
scalar query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_include_items_description @length(min: null, max: 100)

"The wirefilter expression to match devices."
scalar components_schemas_match @length(min: null, max: 500)

"The name of the device settings policy."
scalar query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_name @length(min: null, max: 100)

type service_mode_v2 {
  "The mode to run the WARP client under."
  mode: String
  "The port number when used with proxy mode."
  port: Float
}

type devices_list_device_settings_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_default_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "default_device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_default_device_settings_policy_4xx_response") = default_device_settings_response | devices_get_default_device_settings_policy_4xx_response

type default_device_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: default_device_settings_policy
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type default_device_settings_policy {
  "Whether to allow the user to switch WARP between modes."
  allow_mode_switch: Boolean
  "Whether to receive update notifications when a new version of the client is available."
  allow_updates: Boolean
  "Whether to allow devices to leave the organization."
  allowed_to_leave: Boolean
  "The amount of time in minutes to reconnect after having been disabled."
  auto_connect: Float
  "Turn on the captive portal after the specified amount of time."
  captive_portal: Float
  "Whether the policy will be applied to matching devices."
  default: Boolean
  "If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set."
  disable_auto_fallback: Boolean
  "Whether the policy will be applied to matching devices."
  enabled: Boolean
  exclude: [split_tunnel]
  fallback_domains: [fallback_domain]
  gateway_unique_id: String
  include: [split_tunnel_include]
  service_mode_v2: service_mode_v2
  "The URL to launch when the Send Feedback button is clicked."
  support_url: URL
  "Whether to allow the user to turn off the WARP switch and disconnect the client."
  switch_locked: Boolean
}

type devices_get_default_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_split_tunnel_exclude_list_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_split_tunnel_exclude_list_4xx_response") = split_tunnel_response_collection | devices_get_split_tunnel_exclude_list_4xx_response

type split_tunnel_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [split_tunnel]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type devices_get_split_tunnel_exclude_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_local_domain_fallback_list_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_local_domain_fallback_list_4xx_response") = fallback_domain_response_collection | devices_get_local_domain_fallback_list_4xx_response

type fallback_domain_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [fallback_domain]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type devices_get_local_domain_fallback_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_split_tunnel_include_list_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_include_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_split_tunnel_include_list_4xx_response") = split_tunnel_include_response_collection | devices_get_split_tunnel_include_list_4xx_response

type split_tunnel_include_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [split_tunnel_include]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type devices_get_split_tunnel_include_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_device_settings_policy_by_id_response @statusCodeTypeName(statusCode: 200, typeName: "device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_device_settings_policy_by_id_4xx_response") = device_settings_response | devices_get_device_settings_policy_by_id_4xx_response

type device_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: device_settings_policy
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type devices_get_device_settings_policy_by_id_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_split_tunnel_exclude_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response") = split_tunnel_response_collection | devices_get_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response

type devices_get_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_local_domain_fallback_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_local_domain_fallback_list_for_a_device_settings_policy_4xx_response") = fallback_domain_response_collection | devices_get_local_domain_fallback_list_for_a_device_settings_policy_4xx_response

type devices_get_local_domain_fallback_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_get_split_tunnel_include_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_include_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_get_split_tunnel_include_list_for_a_device_settings_policy_4xx_response") = split_tunnel_include_response_collection | devices_get_split_tunnel_include_list_for_a_device_settings_policy_4xx_response

type devices_get_split_tunnel_include_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union device_posture_rules_list_device_posture_rules_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_rules_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_rules_list_device_posture_rules_4xx_response") = device_posture_rules_components_schemas_response_collection | device_posture_rules_list_device_posture_rules_4xx_response

type device_posture_rules_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [device_posture_rules]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type device_posture_rules {
  "The description of the Device Posture Rule."
  description: String
  "Expire posture results after the specified amount of time."
  expiration: String
  "API uuid tag."
  id: device_posture_rules_components_schemas_uuid!
  input: schemas_input
  "The conditions that the client must match to run the rule."
  match: [match_item]
  "The name of the Device Posture Rule."
  name: String
  "Tells the client when to run the device posture check."
  schedule: String
  type: device_posture_rules_components_schemas_type
}

"API uuid tag."
scalar device_posture_rules_components_schemas_uuid @length(min: null, max: 36)

"The value to be checked against."
type schemas_input {
  "API uuid tag."
  id: device_posture_rules_components_schemas_uuid!
}

type match_item {
  platform: platform
}

"The type of Device Posture Rule."
enum device_posture_rules_components_schemas_type {
  file
  application
  serial_number
  tanium
  gateway
  warp
}

type device_posture_rules_list_device_posture_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union device_posture_integrations_list_device_posture_integrations_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_integrations_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_integrations_list_device_posture_integrations_4xx_response") = device_posture_integrations_components_schemas_response_collection | device_posture_integrations_list_device_posture_integrations_4xx_response

type device_posture_integrations_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [device_posture_integrations]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type device_posture_integrations {
  config: workspace_one_config_response
  "API uuid tag."
  id: device_posture_integrations_components_schemas_uuid!
  "The interval between each posture check with the third party API. Use \\"m\\" for minutes (e.g. \\"5m\\") and \\"h\\" for hours (e.g. \\"12h\\")."
  interval: String
  "The name of the Device Posture Integration."
  name: String
  type: device_posture_integrations_components_schemas_type
}

"The Workspace One Config Response."
type workspace_one_config_response {
  "The Workspace One API URL provided in the Workspace One Admin Dashboard."
  api_url: URL!
  "The Workspace One Authorization URL depending on your region."
  auth_url: URL!
  "The Workspace One client ID provided in the Workspace One Admin Dashboard."
  client_id: String!
}

"API uuid tag."
scalar device_posture_integrations_components_schemas_uuid @length(min: null, max: 36)

"The type of Device Posture Integration."
enum device_posture_integrations_components_schemas_type {
  workspace_one
  crowdstrike_s2s
  uptycs
  intune
}

type device_posture_integrations_list_device_posture_integrations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union device_posture_integrations_device_posture_integration_details_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_integrations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_integrations_device_posture_integration_details_4xx_response") = device_posture_integrations_components_schemas_single_response | device_posture_integrations_device_posture_integration_details_4xx_response

type device_posture_integrations_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: device_posture_integrations
  "Whether the API call was successful"
  success: Boolean!
}

type device_posture_integrations_device_posture_integration_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union device_posture_rules_device_posture_rules_details_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_rules_device_posture_rules_details_4xx_response") = device_posture_rules_components_schemas_single_response | device_posture_rules_device_posture_rules_details_4xx_response

type device_posture_rules_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: device_posture_rules
  "Whether the API call was successful"
  success: Boolean!
}

type device_posture_rules_device_posture_rules_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_accounts_get_device_settings_for_zero_trust_account_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_get_device_settings_for_zero_trust_account_4xx_response") = gateway_account_device_settings_response | zero_trust_accounts_get_device_settings_for_zero_trust_account_4xx_response

type gateway_account_device_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: gateway_account_device_settings
  "Whether the API call was successful"
  success: Boolean!
}

type gateway_account_device_settings {
  "Enable gateway proxy filtering on TCP."
  gateway_proxy_enabled: Boolean
  "Enable gateway proxy filtering on UDP."
  gateway_udp_proxy_enabled: Boolean
}

type zero_trust_accounts_get_device_settings_for_zero_trust_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union devices_device_details_response @statusCodeTypeName(statusCode: 200, typeName: "device_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_device_details_4xx_response") = device_response | devices_device_details_4xx_response

type device_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type devices_device_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union devices_list_admin_override_code_for_device_response @statusCodeTypeName(statusCode: 200, typeName: "override_codes_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_list_admin_override_code_for_device_4xx_response") = override_codes_response | devices_list_admin_override_code_for_device_4xx_response

type override_codes_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_devices_list_admin_override_code_for_device_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_devices_list_admin_override_code_for_device_oneOf_0_allOf_1_result {
  disable_for_time: disable_for_time
}

type disable_for_time {
  "Override code that is valid for 1 hour."
  _1: String @resolveRootField(field: "1")
  "Override code that is valid for 3 hours."
  _3: String @resolveRootField(field: "3")
  "Override code that is valid for 6 hours."
  _6: String @resolveRootField(field: "6")
  "Override code that is valid for 12 hour2."
  _12: String @resolveRootField(field: "12")
  "Override code that is valid for 24 hour.2."
  _24: String @resolveRootField(field: "24")
}

type devices_list_admin_override_code_for_device_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_accounts_get_zero_trust_account_information_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_get_zero_trust_account_information_4xx_response") = gateway_account | zero_trust_accounts_get_zero_trust_account_information_4xx_response

type gateway_account {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zero_trust_accounts_get_zero_trust_account_information_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zero_trust_accounts_get_zero_trust_account_information_oneOf_0_allOf_1_result {
  "Gateway internal id."
  gateway_tag: gateway_tag
  "Cloudflare account tag."
  id: cf_account_id
  "The name of provider. Usually cloudflare."
  provider_name: String
}

"Gateway internal id."
scalar gateway_tag @length(min: null, max: 32)

"Cloudflare account tag."
scalar cf_account_id @length(min: null, max: 32)

type zero_trust_accounts_get_zero_trust_account_information_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings_response @statusCodeTypeName(statusCode: 200, typeName: "app_types_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings_4xx_response") = app_types_components_schemas_response_collection | zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings_4xx_response

type app_types_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [app_types]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union app_types = application | application_type

type application {
  "The identifier for the type of this application. There can be many applications with the same type. This refers to the \`id\` of an Application Type that has been returned."
  application_type_id: Int
  created_at: DateTime
  "The identifier for this application. There is only one application per id."
  id: Int
  "The name of the application or application type."
  name: String
}

type application_type {
  created_at: DateTime
  "A short summary of applications with this type."
  description: String
  "The identifier for the type of this application. There can be many applications with the same type. This refers to the \`id\` of an Application Type that has been returned."
  id: Int
  "The name of the application or application type."
  name: String
}

type zero_trust_gateway_application_and_application_type_mappings_list_application_and_application_type_mappings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_accounts_get_zero_trust_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_config") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_get_zero_trust_account_configuration_4xx_response") = gateway_account_config | zero_trust_accounts_get_zero_trust_account_configuration_4xx_response

type gateway_account_config {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result {
  settings: query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result_allOf_0_settings
  created_at: DateTime
  updated_at: DateTime
}

"account settings."
type query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result_allOf_0_settings {
  activity_log: activity_log_settings
  antivirus: anti_virus_settings
  block_page: block_page_settings
  browser_isolation: browser_isolation_settings
  fips: fips_settings
  tls_decrypt: tls_settings
}

"Activity log settings."
type activity_log_settings {
  "Enable activity logging."
  enabled: Boolean
}

"Anti virus settings."
type anti_virus_settings {
  "Set to enable antivirus scan on downloads."
  enabled_download_phase: Boolean
  "Set to enable antivirus scan on uploads."
  enabled_upload_phase: Boolean
  "Block requests for files that cannot be scanned."
  fail_closed: Boolean
}

"Block page layout settings."
type block_page_settings {
  "Block page background color in #rrggbb format."
  background_color: String
  "Enable only cipher suites and TLS versions compliant with FIPS 140-2."
  enabled: Boolean
  "Block page footer text."
  footer_text: String
  "Block page header text."
  header_text: String
  "Full URL to the logo file."
  logo_path: URL
  "Admin email for users to contact."
  mailto_address: EmailAddress
  "Subject line for emails created from block page."
  mailto_subject: String
  "Block page title."
  name: String
  "Suppress detailed info at the bottom of the block page."
  suppress_footer: Boolean
}

"Browser isolation settings."
type browser_isolation_settings {
  "Enable Browser Isolation."
  url_browser_isolation_enabled: Boolean
}

"FIPS settings."
type fips_settings {
  "Enable only cipher suites and TLS versions compliant with FIPS 140-2."
  tls: Boolean
}

"TLS interception settings."
type tls_settings {
  "Enable inspecting encrypted HTTP traffic."
  enabled: Boolean
}

type zero_trust_accounts_get_zero_trust_account_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_lists_list_zero_trust_lists_response @statusCodeTypeName(statusCode: 200, typeName: "lists_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_list_zero_trust_lists_4xx_response") = lists_components_schemas_response_collection | zero_trust_lists_list_zero_trust_lists_4xx_response

type lists_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [lists]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type lists {
  "The number of items in the List."
  count: Float
  created_at: DateTime
  "The description of the List."
  description: String
  "API Resource UUID tag."
  id: lists_components_schemas_uuid!
  "The name of the List."
  name: String
  type: lists_components_schemas_type
  updated_at: DateTime
}

"API Resource UUID tag."
scalar lists_components_schemas_uuid @length(min: null, max: 36)

"The type of List."
enum lists_components_schemas_type {
  SERIAL
  URL
  DOMAIN
  EMAIL
  IP
}

type zero_trust_lists_list_zero_trust_lists_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_lists_zero_trust_list_details_response @statusCodeTypeName(statusCode: 200, typeName: "lists_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_zero_trust_list_details_4xx_response") = lists_components_schemas_single_response | zero_trust_lists_zero_trust_list_details_4xx_response

type lists_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: lists
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_lists_zero_trust_list_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_lists_zero_trust_list_items_response @statusCodeTypeName(statusCode: 200, typeName: "list_item_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_zero_trust_list_items_4xx_response") = list_item_response_collection | zero_trust_lists_zero_trust_list_items_4xx_response

type list_item_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [[query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items]]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_2_result_info
}

type query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items {
  created_at: DateTime
  "The value of the item in a List."
  value: String
}

type query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_2_result_info {
  "Total results returned based on your search parameters."
  count: Float
  "Current page within paginated list of results."
  page: Float
  "Number of results per page of results."
  per_page: Float
  "Total results available without any search parameters."
  total_count: Float
}

type zero_trust_lists_zero_trust_list_items_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_2_result_info
}

union zero_trust_gateway_locations_list_zero_trust_gateway_locations_response @statusCodeTypeName(statusCode: 200, typeName: "locations_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_locations_list_zero_trust_gateway_locations_4xx_response") = locations_components_schemas_response_collection | zero_trust_gateway_locations_list_zero_trust_gateway_locations_4xx_response

type locations_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [locations]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type locations {
  "Set if the location is the default one."
  client_default: Boolean
  created_at: DateTime
  "The DNS Over HTTPS domain to send DNS requests to. (auto-generated)."
  doh_subdomain: String
  "Set if the location needs to resolve EDNS queries."
  ecs_support: Boolean
  id: String!
  "IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. (auto-generated)."
  ip: IPv6
  "The name of the Location."
  name: String
  "A list of network ranges that requests from this location would originate from."
  networks: [String]
  updated_at: DateTime
}

type zero_trust_gateway_locations_list_zero_trust_gateway_locations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_gateway_locations_zero_trust_gateway_location_details_response @statusCodeTypeName(statusCode: 200, typeName: "locations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_locations_zero_trust_gateway_location_details_4xx_response") = locations_components_schemas_single_response | zero_trust_gateway_locations_zero_trust_gateway_location_details_4xx_response

type locations_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: locations
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_locations_zero_trust_gateway_location_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_logging_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_4xx_response") = gateway_account_logging_settings_response | zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_4xx_response

type gateway_account_logging_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: gateway_account_logging_settings
  "Whether the API call was successful"
  success: Boolean!
}

type gateway_account_logging_settings {
  "Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent)."
  redact_pii: Boolean
  settings_by_rule_type: query_zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_oneOf_0_allOf_1_result_settings_by_rule_type
}

"Logging settings by rule type."
type query_zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_oneOf_0_allOf_1_result_settings_by_rule_type {
  dns: JSON
  http: JSON
  l4: JSON
}

type zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_proxy_endpoints_list_proxy_endpoints_response @statusCodeTypeName(statusCode: 200, typeName: "proxy_endpoints_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_proxy_endpoints_list_proxy_endpoints_4xx_response") = proxy_endpoints_components_schemas_response_collection | zero_trust_gateway_proxy_endpoints_list_proxy_endpoints_4xx_response

type proxy_endpoints_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [proxy_endpoints]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type proxy_endpoints {
  created_at: DateTime
  id: String!
  "A list of CIDRs to restrict ingress connections."
  ips: [String]
  "The name of the Proxy Endpoint."
  name: String
  "The subdomain to be used as the destination in the proxy client."
  subdomain: String
  updated_at: DateTime
}

type zero_trust_gateway_proxy_endpoints_list_proxy_endpoints_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_gateway_proxy_endpoints_proxy_endpoint_details_response @statusCodeTypeName(statusCode: 200, typeName: "proxy_endpoints_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_proxy_endpoints_proxy_endpoint_details_4xx_response") = proxy_endpoints_components_schemas_single_response | zero_trust_gateway_proxy_endpoints_proxy_endpoint_details_4xx_response

type proxy_endpoints_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: proxy_endpoints
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_proxy_endpoints_proxy_endpoint_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_rules_list_zero_trust_gateway_rules_response @statusCodeTypeName(statusCode: 200, typeName: "rules_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_rules_list_zero_trust_gateway_rules_4xx_response") = rules_components_schemas_response_collection | zero_trust_gateway_rules_list_zero_trust_gateway_rules_4xx_response

type rules_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [rules_components_schemas_rules]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type rules_components_schemas_rules {
  action: rules_components_schemas_action_2
  created_at: DateTime
  "Date of deletion, if any."
  deleted_at: DateTime
  "The description of the Rule."
  description: String
  "The wirefilter expression to be used for device posture check matching."
  device_posture: String
  "Set if the rule is enabled."
  enabled: Boolean
  "The protocol or layer to evaluate the traffic, identity, and device posture expressions."
  filters: [query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_filters_items]
  "API Resource UUID tag."
  id: rules_components_schemas_uuid!
  "The wirefilter expression to be used for identity matching."
  identity: String
  "The name of the Rule."
  name: String
  "Precedence sets the ordering of the rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value."
  precedence: Int
  rule_settings: rule_settings
  "The wirefilter expression to be used for traffic matching."
  traffic: String
  updated_at: DateTime
}

"The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to 'true'."
enum rules_components_schemas_action_2 {
  on
  off
  allow
  block
  scan
  noscan
  safesearch
  ytrestricted
  isolate
  noisolate
  override
  l4_override
}

"The protocol or layer to use."
enum query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_filters_items {
  http
  dns
  l4
}

"API Resource UUID tag."
scalar rules_components_schemas_uuid @length(min: null, max: 36)

"Additional settings that modify the rule's action."
type rule_settings {
  add_headers: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_add_headers
  biso_admin_controls: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_biso_admin_controls
  "Enable the custom block page."
  block_page_enabled: Boolean
  "The text describing why this block occurred that will be displayed on the custom block page (if enabled)."
  block_reason: String
  check_session: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_check_session
  "INSECURE - disable DNSSEC validation (for allow actions)."
  insecure_disable_dnssec_validation: Boolean
  "Include IPs in DNS resolver category blocks. By default categories only block on domain names."
  ip_categories: Boolean
  l4override: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_l4override
  "Override matching DNS queries with this."
  override_host: String
  "Override matching DNS queries with this."
  override_ips: [String]
}

"Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s)."
type query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_add_headers {
  My_Next_Header: [String] @resolveRootField(field: "My-Next-Header")
  X_Custom_Header_Name: [String] @resolveRootField(field: "X-Custom-Header-Name")
}

"Configure how browser isolation behaves."
type query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_biso_admin_controls {
  "Disable copy-paste."
  dcp: Boolean
  "Disable download."
  dd: Boolean
  "Disable keyboard usage."
  dk: Boolean
  "Disable printing."
  dp: Boolean
  "Disable upload."
  du: Boolean
}

"Configure how session check behaves."
type query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_check_session {
  "Configure how fresh the session needs to be to be considered valid."
  duration: String
  "Enable session enforcement for this fule."
  enforce: Boolean
}

"Send matching traffic to the supplied destination IP address and port."
type query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_l4override {
  "IPv4 or IPv6 address."
  ip: String
  "A port number to use for TCP/UDP overrides."
  port: Int
}

type zero_trust_gateway_rules_list_zero_trust_gateway_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zero_trust_gateway_rules_zero_trust_gateway_rule_details_response @statusCodeTypeName(statusCode: 200, typeName: "rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_rules_zero_trust_gateway_rule_details_4xx_response") = rules_components_schemas_single_response | zero_trust_gateway_rules_zero_trust_gateway_rule_details_4xx_response

type rules_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: rules_components_schemas_rules
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_rules_zero_trust_gateway_rule_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union origin_ca_list_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_certificate_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "origin_ca_list_certificates_4xx_response") = schemas_certificate_response_collection | origin_ca_list_certificates_4xx_response

type schemas_certificate_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [certificates]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type certificates {
  "The Origin CA certificate. Will be newline-encoded."
  certificate: String
  "The Certificate Signing Request (CSR). Must be newline-encoded."
  csr: String!
  "When the certificate will expire."
  expires_on: DateTime
  "Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate."
  hostnames: [JSON]!
  "The x509 serial number of the Origin CA certificate."
  id: String!
  request_type: request_type!
  requested_validity: requested_validity!
}

"Signature type desired on certificate (\\"origin-rsa\\" (rsa), \\"origin-ecc\\" (ecdsa), or \\"keyless-certificate\\" (for Keyless SSL servers)."
enum request_type {
  origin_rsa @enum(value: "\\"origin-rsa\\"")
  origin_ecc @enum(value: "\\"origin-ecc\\"")
  keyless_certificate @enum(value: "\\"keyless-certificate\\"")
}

"The number of days for which the certificate should be valid."
enum requested_validity {
  _7 @enum(value: "7")
  _30 @enum(value: "30")
  _90 @enum(value: "90")
  _365 @enum(value: "365")
  _730 @enum(value: "730")
  _1095 @enum(value: "1095")
  _5475 @enum(value: "5475")
}

type origin_ca_list_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union origin_ca_get_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "origin_ca_get_certificate_4xx_response") = schemas_certificate_response_single | origin_ca_get_certificate_4xx_response

type schemas_certificate_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type origin_ca_get_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_i_ps_cloudflare_ip_details_response @statusCodeTypeName(statusCode: 200, typeName: "cloudflare_i_ps_cloudflare_ip_details_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_i_ps_cloudflare_ip_details_4xx_response") = cloudflare_i_ps_cloudflare_ip_details_200_response | cloudflare_i_ps_cloudflare_ip_details_4xx_response

type cloudflare_i_ps_cloudflare_ip_details_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: ips
  "Whether the API call was successful"
  success: Boolean!
}

type ips {
  "A digest of the IP data. Useful for determining if the data has changed."
  etag: String
  "List of Cloudflare IPv4 CIDR addresses."
  ipv4_cidrs: [String]
  "List of Cloudflare IPv6 CIDR addresses."
  ipv6_cidrs: [String]
}

type cloudflare_i_ps_cloudflare_ip_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_SINGLE_QUOTE__s_account_memberships_list_memberships_response @statusCodeTypeName(statusCode: 200, typeName: "collection_membership_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_account_memberships_list_memberships_4xx_response") = collection_membership_response | user_SINGLE_QUOTE__s_account_memberships_list_memberships_4xx_response

type collection_membership_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [membership]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type membership {
  account: schemas_account
  "Enterprise only. Indicates whether or not API access is enabled specifically for this user on a given account."
  api_access_enabled: Boolean
  "The unique activation code for the account membership."
  code: code
  "Membership identifier tag."
  id: membership_components_schemas_identifier!
  permissions: permissions
  "List of role names for the user at the account."
  roles: [query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_roles_items]
  status: schemas_status
}

type schemas_account {
  "Timestamp for the creation of the account"
  created_on: DateTime
  "Identifier"
  id: common_components_schemas_identifier!
  "Account name"
  name: query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_name!
  settings: query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_settings
}

"Account name"
scalar query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_name @length(min: null, max: 100)

"Account settings"
type query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_settings {
  "Indicates whether membership in this account requires that\\nTwo-Factor Authentication is enabled"
  enforce_twofactor: Boolean
  "Indicates whether new zones should use the account-level custom\\nnameservers by default"
  use_account_custom_ns_by_default: Boolean
}

"The unique activation code for the account membership."
scalar code @length(min: null, max: 64)

"Membership identifier tag."
scalar membership_components_schemas_identifier @length(min: null, max: 32)

type permissions {
  analytics: grants
  billing: grants
  cache_purge: grants
  dns: grants
  dns_records: grants
  lb: grants
  logs: grants
  organization: grants
  ssl: grants
  waf: grants
  zone_settings: grants
  zones: grants
}

type grants {
  read: Boolean
  write: Boolean
}

scalar query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_roles_items @length(min: null, max: 120)

"Status of this membership."
enum schemas_status {
  accepted
  pending
  rejected
}

type user_SINGLE_QUOTE__s_account_memberships_list_memberships_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_SINGLE_QUOTE__s_account_memberships_membership_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_membership_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_account_memberships_membership_details_4xx_response") = single_membership_response | user_SINGLE_QUOTE__s_account_memberships_membership_details_4xx_response

type single_membership_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type user_SINGLE_QUOTE__s_account_memberships_membership_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organizations__deprecated_organization_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_organization_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organizations__deprecated_organization_details_4xx_response") = single_organization_response | organizations__deprecated_organization_details_4xx_response

type single_organization_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type organizations__deprecated_organization_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union audit_logs_get_organization_audit_logs_response @statusCodeTypeName(statusCode: "4xx", typeName: "audit_logs_get_organization_audit_logs_4xx_response") = query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0 | api_response_common | audit_logs_get_organization_audit_logs_4xx_response

type audit_logs_get_organization_audit_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_invites_list_invitations_response @statusCodeTypeName(statusCode: 200, typeName: "collection_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_invites_list_invitations_4xx_response") = collection_invite_response | organization_invites_list_invitations_4xx_response

type collection_invite_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [invite]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type invite {
  "When the invite is no longer active."
  expires_on: DateTime
  "Invite identifier tag."
  id: invite_components_schemas_identifier!
  "The email address of the user who created the invite."
  invited_by: EmailAddress
  "Email address of the user to add to the organization."
  invited_member_email: EmailAddress
  "ID of the user to add to the organization."
  invited_member_id: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_invited_member_id
  "When the invite was sent."
  invited_on: DateTime
  "ID of the organization the user will be added to."
  organization_id: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_id!
  "Organization name."
  organization_name: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_name
  "Roles to be assigned to this user."
  roles: [schemas_role]
  "Current status of two-factor enforcement on the organization."
  organization_is_enforcing_twofactor: Boolean
  status: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_status
}

"Invite identifier tag."
scalar invite_components_schemas_identifier @length(min: null, max: 32)

"ID of the user to add to the organization."
scalar query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_invited_member_id @length(min: null, max: 32)

"ID of the organization the user will be added to."
scalar query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_id @length(min: null, max: 32)

"Organization name."
scalar query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_name @length(min: null, max: 100)

type schemas_role {
  "Description of role's permissions."
  description: String!
  "Role identifier tag."
  id: role_components_schemas_identifier!
  "Role Name."
  name: components_schemas_name!
  "Access permissions for this User."
  permissions: [query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_roles_items_permissions_items]!
}

"Role identifier tag."
scalar role_components_schemas_identifier @length(min: null, max: 32)

"Role Name."
scalar components_schemas_name @length(min: null, max: 120)

scalar query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_roles_items_permissions_items @length(min: null, max: 160)

"Current status of the invitation."
enum query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_status {
  pending
  accepted
  rejected
  canceled
  left
  expired
}

type organization_invites_list_invitations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union organization_invites_invitation_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_invites_invitation_details_4xx_response") = single_invite_response | organization_invites_invitation_details_4xx_response

type single_invite_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type organization_invites_invitation_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_members_list_members_response @statusCodeTypeName(statusCode: 200, typeName: "collection_member_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_members_list_members_4xx_response") = collection_member_response | organization_members_list_members_4xx_response

type collection_member_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_member]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type components_schemas_member {
  "The contact email address of the user."
  email: EmailAddress!
  "Identifier"
  id: common_components_schemas_identifier!
  "Member Name."
  name: member_components_schemas_name
  "Roles assigned to this Member."
  roles: [schemas_role]!
  status: query_organization_members_list_members_oneOf_0_allOf_1_result_items_status!
}

"Member Name."
scalar member_components_schemas_name @length(min: null, max: 100)

"A member's status in the organization."
enum query_organization_members_list_members_oneOf_0_allOf_1_result_items_status {
  accepted
  invited
}

type organization_members_list_members_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"Organization identifier tag."
scalar organization_components_schemas_identifier @length(min: null, max: 32)

union organization_members_member_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_member_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_members_member_details_4xx_response") = single_member_response | organization_members_member_details_4xx_response

type single_member_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type organization_members_member_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_railgun_list_railguns_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_list_railguns_4xx_response") = railgun_response_collection | organization_railgun_list_railguns_4xx_response

type organization_railgun_list_railguns_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union organization_railgun_railgun_details_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_railgun_details_4xx_response") = railgun_response_single | organization_railgun_railgun_details_4xx_response

type organization_railgun_railgun_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_railgun_get_railgun_zones_response @statusCodeTypeName(statusCode: 200, typeName: "organization_railgun_get_railgun_zones_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_get_railgun_zones_4xx_response") = organization_railgun_get_railgun_zones_200_response | organization_railgun_get_railgun_zones_4xx_response

type organization_railgun_get_railgun_zones_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_zone]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type components_schemas_zone {
  "The last time proof of ownership was detected and the zone was made\\nactive"
  activated_on: DateTime
  "When the zone was created"
  created_on: DateTime!
  "The interval (in seconds) from when development mode expires\\n(positive integer) or last expired (negative integer) for the\\ndomain. If development mode has never been enabled, this value is 0."
  development_mode: Float!
  "Identifier"
  id: common_components_schemas_identifier!
  "When the zone was last modified"
  modified_on: DateTime!
  name: query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_name!
  "DNS host at the time of switching to Cloudflare"
  original_dnshost: query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_original_dnshost
  "Original name servers before moving to Cloudflare\\nNotes: Is this only available for full zones?"
  original_name_servers: [Hostname]
  "Registrar for the domain at the time of switching to Cloudflare"
  original_registrar: String
}

scalar query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_name @regexp(pattern: "^([a-zA-Z0-9][\\\\-a-zA-Z0-9]*\\\\.)+[\\\\-a-zA-Z0-9]{2,20}$") @typescript(type: "string")

"DNS host at the time of switching to Cloudflare"
scalar query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_original_dnshost @length(min: null, max: 50)

type organization_railgun_get_railgun_zones_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union organization_roles_list_roles_response @statusCodeTypeName(statusCode: 200, typeName: "collection_role_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_roles_list_roles_4xx_response") = collection_role_response | organization_roles_list_roles_4xx_response

type collection_role_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_role]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type organization_roles_list_roles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union organization_roles_role_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_role_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_roles_role_details_4xx_response") = single_role_response | organization_roles_role_details_4xx_response

type single_role_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type organization_roles_role_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union radar_annotations_get_outages_annotations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_annotations_get_outages_annotations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_annotations_get_outages_annotations_4xx_response") = radar_annotations_get_outages_annotations_200_response | radar_annotations_get_outages_annotations_4xx_response

type radar_annotations_get_outages_annotations_200_response {
  result: query_radar_annotations_get_outages_annotations_oneOf_0_result
  success: String
}

type query_radar_annotations_get_outages_annotations_oneOf_0_result {
  annotations: [query_radar_annotations_get_outages_annotations_oneOf_0_result_annotations_items]
}

type query_radar_annotations_get_outages_annotations_oneOf_0_result_annotations_items {
  asns: [Int]
  dataSource: String
  description: String
  endDate: DateTime
  eventType: String
  linkedUrl: URL
  locations: [String]
  outage: query_radar_annotations_get_outages_annotations_oneOf_0_result_annotations_items_outage
  scope: String
  startDate: DateTime
}

type query_radar_annotations_get_outages_annotations_oneOf_0_result_annotations_items_outage {
  outageCause: String
  outageType: String
}

type radar_annotations_get_outages_annotations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_annotations_get_top_outages_annotations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_annotations_get_top_outages_annotations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_annotations_get_top_outages_annotations_4xx_response") = radar_annotations_get_top_outages_annotations_200_response | radar_annotations_get_top_outages_annotations_4xx_response

type radar_annotations_get_top_outages_annotations_200_response {
  result: query_radar_annotations_get_top_outages_annotations_oneOf_0_result
  success: String
}

type query_radar_annotations_get_top_outages_annotations_oneOf_0_result {
  annotations: [query_radar_annotations_get_top_outages_annotations_oneOf_0_result_annotations_items]
}

type query_radar_annotations_get_top_outages_annotations_oneOf_0_result_annotations_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_annotations_get_top_outages_annotations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_a_summary_of_layer_3_attacks_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_a_summary_of_layer_3_attacks_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_a_summary_of_layer_3_attacks_4xx_response") = radar_attacks_get_a_summary_of_layer_3_attacks_200_response | radar_attacks_get_a_summary_of_layer_3_attacks_4xx_response

type radar_attacks_get_a_summary_of_layer_3_attacks_200_response {
  result: query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result
  success: String
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result {
  meta: query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta
  summary_0: query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_summary_0
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta {
  confidenceInfo: query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_dateRange
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_a_summary_of_layer_3_attacks_oneOf_0_result_summary_0 {
  gre: String
  icmp: String
  tcp: String
  udp: String
}

type radar_attacks_get_a_summary_of_layer_3_attacks_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_3_attacks_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_3_attacks_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_3_attacks_time_series_4xx_response") = radar_attacks_get_layer_3_attacks_time_series_200_response | radar_attacks_get_layer_3_attacks_time_series_4xx_response

type radar_attacks_get_layer_3_attacks_time_series_200_response {
  result: query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result {
  meta: query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta
  series: query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_series
}

type query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta_confidenceInfo {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_layer_3_attacks_time_series_oneOf_0_result_series {
  timestamps: [DateTime]
  values: [String]
}

type radar_attacks_get_layer_3_attacks_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_4xx_response") = radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_200_response | radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_4xx_response

type radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_200_response {
  result: query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result {
  meta: query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta
  serie_0: query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_serie_0
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_oneOf_0_result_serie_0 {
  gre: [String]
  icmp: [String]
  tcp: [String]
  timeseries: [String]
  udp: [String]
}

type radar_attacks_get_layer_3_attacks_by_network_protocol_COMMA__over_time_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_a_summary_of_layer_7_attacks_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_a_summary_of_layer_7_attacks_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_a_summary_of_layer_7_attacks_4xx_response") = radar_attacks_get_a_summary_of_layer_7_attacks_200_response | radar_attacks_get_a_summary_of_layer_7_attacks_4xx_response

type radar_attacks_get_a_summary_of_layer_7_attacks_200_response {
  result: query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result
  success: String
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result {
  meta: query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta
  summary_0: query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_summary_0
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta {
  confidenceInfo: query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_dateRange
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_a_summary_of_layer_7_attacks_oneOf_0_result_summary_0 {
  gre: String
  icmp: String
  tcp: String
  udp: String
}

type radar_attacks_get_a_summary_of_layer_7_attacks_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_attacks_layer_7_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_attacks_layer_7_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_attacks_layer_7_time_series_4xx_response") = radar_attacks_get_attacks_layer_7_time_series_200_response | radar_attacks_get_attacks_layer_7_time_series_4xx_response

type radar_attacks_get_attacks_layer_7_time_series_200_response {
  result: query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result
  success: String
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result {
  meta: query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta
  series: query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_series
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_attacks_layer_7_time_series_oneOf_0_result_series {
  timestamps: [DateTime]
  values: [String]
}

type radar_attacks_get_attacks_layer_7_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_4xx_response") = radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_200_response | radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_4xx_response

type radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_200_response {
  result: query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result {
  meta: query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta
  serie_0: query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_serie_0
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_oneOf_0_result_serie_0 {
  gre: [String]
  icmp: [String]
  tcp: [String]
  timeseries: [DateTime]
  udp: [String]
}

type radar_attacks_get_layer_7_attacks_by_mitigation_technique_COMMA__over_time_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_7_top_origin_a_ses_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_7_top_origin_a_ses_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_7_top_origin_a_ses_4xx_response") = radar_attacks_get_layer_7_top_origin_a_ses_200_response | radar_attacks_get_layer_7_top_origin_a_ses_4xx_response

type radar_attacks_get_layer_7_top_origin_a_ses_200_response {
  result: query_radar_attacks_get_layer_7_top_origin_a_ses_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_7_top_origin_a_ses_oneOf_0_result {
  top_0: [query_radar_attacks_get_layer_7_top_origin_a_ses_oneOf_0_result_top_0_items]
}

type query_radar_attacks_get_layer_7_top_origin_a_ses_oneOf_0_result_top_0_items {
  originAsn: Float
  originAsnName: String
  rank: String
  value: String
}

type radar_attacks_get_layer_7_top_origin_a_ses_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_4xx_response") = radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_200_response | radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_4xx_response

type radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_200_response {
  result: query_radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_oneOf_0_result {
  top_0: [query_radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_oneOf_0_result_top_0_items]
}

type query_radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_oneOf_0_result_top_0_items {
  originCountryAlpha2: String
  originCountryName: String
  rank: String
  targetCountryAlpha2: String
  targetCountryName: String
  value: String
}

type radar_attacks_get_layer_7_top_attack_pairs__origin_and_target_locations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_7_top_origin_locations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_7_top_origin_locations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_7_top_origin_locations_4xx_response") = radar_attacks_get_layer_7_top_origin_locations_200_response | radar_attacks_get_layer_7_top_origin_locations_4xx_response

type radar_attacks_get_layer_7_top_origin_locations_200_response {
  result: query_radar_attacks_get_layer_7_top_origin_locations_oneOf_0_result
  success: String
}

type query_radar_attacks_get_layer_7_top_origin_locations_oneOf_0_result {
  top_0: [query_radar_attacks_get_layer_7_top_origin_locations_oneOf_0_result_top_0_items]
}

type query_radar_attacks_get_layer_7_top_origin_locations_oneOf_0_result_top_0_items {
  originCountryAlpha2: String
  originCountryName: String
  rank: String
  value: String
}

type radar_attacks_get_layer_7_top_origin_locations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_attacks_get_layer_7_top_target_locations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_attacks_get_layer_7_top_target_locations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_attacks_get_layer_7_top_target_locations_4xx_response") = radar_attacks_get_layer_7_top_target_locations_200_response | radar_attacks_get_layer_7_top_target_locations_4xx_response

type radar_attacks_get_layer_7_top_target_locations_200_response {
  data: query_radar_attacks_get_layer_7_top_target_locations_oneOf_0_data
}

type query_radar_attacks_get_layer_7_top_target_locations_oneOf_0_data {
  top_0: [query_radar_attacks_get_layer_7_top_target_locations_oneOf_0_data_top_0_items]
}

type query_radar_attacks_get_layer_7_top_target_locations_oneOf_0_data_top_0_items {
  rank: String
  targetCountryAlpha2: String
  targetCountryName: String
  value: String
}

type radar_attacks_get_layer_7_top_target_locations_4xx_response {
  data: query_radar_attacks_get_layer_7_top_target_locations_oneOf_1_allOf_0_data
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

type query_radar_attacks_get_layer_7_top_target_locations_oneOf_1_allOf_0_data {
  top_0: [query_radar_attacks_get_layer_7_top_target_locations_oneOf_1_allOf_0_data_top_0_items]
}

type query_radar_attacks_get_layer_7_top_target_locations_oneOf_1_allOf_0_data_top_0_items {
  rank: String
  targetCountryAlpha2: String
  targetCountryName: String
  value: String
}

union radar_bgp_get_bgp_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_bgp_get_bgp_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_bgp_get_bgp_time_series_4xx_response") = radar_bgp_get_bgp_time_series_200_response | radar_bgp_get_bgp_time_series_4xx_response

type radar_bgp_get_bgp_time_series_200_response {
  result: query_radar_bgp_get_bgp_time_series_oneOf_0_result
  success: String
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result {
  meta: query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta
  series: query_radar_bgp_get_bgp_time_series_oneOf_0_result_series
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_bgp_get_bgp_time_series_oneOf_0_result_series {
  timestamps: [DateTime]
  values: [String]
}

type radar_bgp_get_bgp_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_bgp_get_top_autonomous_systems_response @statusCodeTypeName(statusCode: 200, typeName: "radar_bgp_get_top_autonomous_systems_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_bgp_get_top_autonomous_systems_4xx_response") = radar_bgp_get_top_autonomous_systems_200_response | radar_bgp_get_top_autonomous_systems_4xx_response

type radar_bgp_get_top_autonomous_systems_200_response {
  result: query_radar_bgp_get_top_autonomous_systems_oneOf_0_result
  success: String
}

type query_radar_bgp_get_top_autonomous_systems_oneOf_0_result {
  meta: query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_meta
  top_0: [query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_top_0_items]
}

type query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_meta {
  dateRange: query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_meta_dateRange
}

type query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_bgp_get_top_autonomous_systems_oneOf_0_result_top_0_items {
  ASName: String
  asn: String
  "Percentage of updates by this AS out of the total updates by all autonomous systems."
  value: String
}

type radar_bgp_get_top_autonomous_systems_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_bgp_get_top_prefixes_response @statusCodeTypeName(statusCode: 200, typeName: "radar_bgp_get_top_prefixes_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_bgp_get_top_prefixes_4xx_response") = radar_bgp_get_top_prefixes_200_response | radar_bgp_get_top_prefixes_4xx_response

type radar_bgp_get_top_prefixes_200_response {
  result: query_radar_bgp_get_top_prefixes_oneOf_0_result
  success: String
}

type query_radar_bgp_get_top_prefixes_oneOf_0_result {
  meta: query_radar_bgp_get_top_prefixes_oneOf_0_result_meta
  top_0: [query_radar_bgp_get_top_prefixes_oneOf_0_result_top_0_items]
}

type query_radar_bgp_get_top_prefixes_oneOf_0_result_meta {
  dateRange: query_radar_bgp_get_top_prefixes_oneOf_0_result_meta_dateRange
}

type query_radar_bgp_get_top_prefixes_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_bgp_get_top_prefixes_oneOf_0_result_top_0_items {
  prefix: String
  value: String
}

type radar_bgp_get_top_prefixes_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_datasets_get_datasets_response @statusCodeTypeName(statusCode: 200, typeName: "radar_datasets_get_datasets_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_datasets_get_datasets_4xx_response") = radar_datasets_get_datasets_200_response | radar_datasets_get_datasets_4xx_response

type radar_datasets_get_datasets_200_response {
  result: query_radar_datasets_get_datasets_oneOf_0_result
  success: String
}

type query_radar_datasets_get_datasets_oneOf_0_result {
  datasets: [query_radar_datasets_get_datasets_oneOf_0_result_datasets_items]
}

type query_radar_datasets_get_datasets_oneOf_0_result_datasets_items {
  description: String
  id: Int
  meta: JSON
  tags: [String]
  title: String
  type: String
}

type radar_datasets_get_datasets_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_dns_get_dns_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_dns_get_dns_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_dns_get_dns_time_series_4xx_response") = radar_dns_get_dns_time_series_200_response | radar_dns_get_dns_time_series_4xx_response

type radar_dns_get_dns_time_series_200_response {
  result: query_radar_dns_get_dns_time_series_oneOf_0_result
  success: String
}

type query_radar_dns_get_dns_time_series_oneOf_0_result {
  meta: query_radar_dns_get_dns_time_series_oneOf_0_result_meta
  series: query_radar_dns_get_dns_time_series_oneOf_0_result_series
}

type query_radar_dns_get_dns_time_series_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_dns_get_dns_time_series_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_dns_get_dns_time_series_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_dns_get_dns_time_series_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_dns_get_dns_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_dns_get_dns_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_dns_get_dns_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_dns_get_dns_time_series_oneOf_0_result_series {
  timestamps: [DateTime]
  values: [String]
}

type radar_dns_get_dns_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_dns_get_top_autonomous_systems_by_dns_queries__response @statusCodeTypeName(statusCode: 200, typeName: "radar_dns_get_top_autonomous_systems_by_dns_queries__200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_dns_get_top_autonomous_systems_by_dns_queries__4xx_response") = radar_dns_get_top_autonomous_systems_by_dns_queries__200_response | radar_dns_get_top_autonomous_systems_by_dns_queries__4xx_response

type radar_dns_get_top_autonomous_systems_by_dns_queries__200_response {
  result: query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result
  success: String
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result {
  meta: query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta
  top_0: [query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_top_0_items]
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta {
  confidenceInfo: query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_dateRange
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_dns_get_top_autonomous_systems_by_dns_queries__oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_dns_get_top_autonomous_systems_by_dns_queries__4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_dns_get_top_locations_by_dns_queries_response @statusCodeTypeName(statusCode: 200, typeName: "radar_dns_get_top_locations_by_dns_queries_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_dns_get_top_locations_by_dns_queries_4xx_response") = radar_dns_get_top_locations_by_dns_queries_200_response | radar_dns_get_top_locations_by_dns_queries_4xx_response

type radar_dns_get_top_locations_by_dns_queries_200_response {
  result: query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result
  success: String
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result {
  meta: query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta
  top_0: [query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_top_0_items]
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta {
  confidenceInfo: query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_dateRange
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_dns_get_top_locations_by_dns_queries_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_dns_get_top_locations_by_dns_queries_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_entities_get_autonomous_systems_response @statusCodeTypeName(statusCode: 200, typeName: "radar_entities_get_autonomous_systems_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_entities_get_autonomous_systems_4xx_response") = radar_entities_get_autonomous_systems_200_response | radar_entities_get_autonomous_systems_4xx_response

type radar_entities_get_autonomous_systems_200_response {
  ases: [query_radar_entities_get_autonomous_systems_oneOf_0_ases_items]
}

type query_radar_entities_get_autonomous_systems_oneOf_0_ases_items {
  aka: String
  asn: Int
  name: String
  nameLong: String
  website: URL
}

type radar_entities_get_autonomous_systems_4xx_response {
  ases: [query_radar_entities_get_autonomous_systems_oneOf_1_allOf_0_ases_items]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

type query_radar_entities_get_autonomous_systems_oneOf_1_allOf_0_ases_items {
  aka: String
  asn: Int
  name: String
  nameLong: String
  website: URL
}

union radar_entities_get_autonomous_system_information_by_ip_address_response @statusCodeTypeName(statusCode: 200, typeName: "radar_entities_get_autonomous_system_information_by_ip_address_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_entities_get_autonomous_system_information_by_ip_address_4xx_response") = radar_entities_get_autonomous_system_information_by_ip_address_200_response | radar_entities_get_autonomous_system_information_by_ip_address_4xx_response

type radar_entities_get_autonomous_system_information_by_ip_address_200_response {
  result: query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result
  success: String
}

type query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result {
  asn: query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result_asn
}

type query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result_asn {
  aka: String
  asn: Int
  country: String
  name: String
  nameLong: String
  related: [query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result_asn_related_items]
  website: URL
}

type query_radar_entities_get_autonomous_system_information_by_ip_address_oneOf_0_result_asn_related_items {
  aka: String
  asn: Int
  name: String
}

type radar_entities_get_autonomous_system_information_by_ip_address_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_entities_get_autonomous_system__as_by_id_response @statusCodeTypeName(statusCode: 200, typeName: "radar_entities_get_autonomous_system__as_by_id_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_entities_get_autonomous_system__as_by_id_4xx_response") = radar_entities_get_autonomous_system__as_by_id_200_response | radar_entities_get_autonomous_system__as_by_id_4xx_response

type radar_entities_get_autonomous_system__as_by_id_200_response {
  result: query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result
  success: String
}

type query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result {
  asn: query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result_asn
}

type query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result_asn {
  aka: String
  asn: Int
  confidenceLevel: Int
  country: String
  name: String
  nameLong: String
  related: [query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result_asn_related_items]
  website: URL
}

type query_radar_entities_get_autonomous_system__as_by_id_oneOf_0_result_asn_related_items {
  aka: String
  asn: Int
  name: String
}

type radar_entities_get_autonomous_system__as_by_id_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_entities_get_locations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_entities_get_locations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_entities_get_locations_4xx_response") = radar_entities_get_locations_200_response | radar_entities_get_locations_4xx_response

type radar_entities_get_locations_200_response {
  result: query_radar_entities_get_locations_oneOf_0_result
  success: String
}

type query_radar_entities_get_locations_oneOf_0_result {
  locations: [query_radar_entities_get_locations_oneOf_0_result_locations_items]
}

type query_radar_entities_get_locations_oneOf_0_result_locations_items {
  alpha2: String
  latitude: String
  longitude: String
  name: String
}

type radar_entities_get_locations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_entities_get_location_response @statusCodeTypeName(statusCode: 200, typeName: "radar_entities_get_location_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_entities_get_location_4xx_response") = radar_entities_get_location_200_response | radar_entities_get_location_4xx_response

type radar_entities_get_location_200_response {
  result: query_radar_entities_get_location_oneOf_0_result
  success: String
}

type query_radar_entities_get_location_oneOf_0_result {
  location: query_radar_entities_get_location_oneOf_0_result_location
}

type query_radar_entities_get_location_oneOf_0_result_location {
  alpha2: String
  confidenceLvel: Int
  latitude: String
  longitude: String
  name: String
  region: String
  subregion: String
}

type radar_entities_get_location_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_bot_classes_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_bot_classes_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_bot_classes_4xx_response") = radar_http_get_a_summary_of_bot_classes_200_response | radar_http_get_a_summary_of_bot_classes_4xx_response

type radar_http_get_a_summary_of_bot_classes_200_response {
  result: query_radar_http_get_a_summary_of_bot_classes_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_bot_classes_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_bot_classes_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_bot_classes_oneOf_0_result_summary_0 {
  bot: String
  human: String
}

type radar_http_get_a_summary_of_bot_classes_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_device_types_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_device_types_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_device_types_4xx_response") = radar_http_get_a_summary_of_device_types_200_response | radar_http_get_a_summary_of_device_types_4xx_response

type radar_http_get_a_summary_of_device_types_200_response {
  result: query_radar_http_get_a_summary_of_device_types_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_device_types_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_device_types_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_device_types_oneOf_0_result_summary_0 {
  desktop: String
  mobile: String
  other: String
}

type radar_http_get_a_summary_of_device_types_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_http_protocols_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_http_protocols_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_http_protocols_4xx_response") = radar_http_get_a_summary_of_http_protocols_200_response | radar_http_get_a_summary_of_http_protocols_4xx_response

type radar_http_get_a_summary_of_http_protocols_200_response {
  result: query_radar_http_get_a_summary_of_http_protocols_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_http_protocols_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_http_protocols_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_http_protocols_oneOf_0_result_summary_0 {
  http: String
  https: String
}

type radar_http_get_a_summary_of_http_protocols_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_http_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_http_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_http_versions_4xx_response") = radar_http_get_a_summary_of_http_versions_200_response | radar_http_get_a_summary_of_http_versions_4xx_response

type radar_http_get_a_summary_of_http_versions_200_response {
  result: query_radar_http_get_a_summary_of_http_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_http_versions_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_http_versions_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_http_versions_oneOf_0_result_summary_0 {
  HTTP_1_x: String @resolveRootField(field: "HTTP/1.x")
  HTTP_2: String @resolveRootField(field: "HTTP/2")
  HTTP_3: String @resolveRootField(field: "HTTP/3")
}

type radar_http_get_a_summary_of_http_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_ip_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_ip_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_ip_versions_4xx_response") = radar_http_get_a_summary_of_ip_versions_200_response | radar_http_get_a_summary_of_ip_versions_4xx_response

type radar_http_get_a_summary_of_ip_versions_200_response {
  result: query_radar_http_get_a_summary_of_ip_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_ip_versions_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_ip_versions_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_ip_versions_oneOf_0_result_summary_0 {
  IPv4: String
  IPv6: String
}

type radar_http_get_a_summary_of_ip_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_a_summary_of_tls_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_a_summary_of_tls_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_a_summary_of_tls_versions_4xx_response") = radar_http_get_a_summary_of_tls_versions_200_response | radar_http_get_a_summary_of_tls_versions_4xx_response

type radar_http_get_a_summary_of_tls_versions_200_response {
  result: query_radar_http_get_a_summary_of_tls_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_a_summary_of_tls_versions_oneOf_0_result {
  meta: JSON
  summary_0: query_radar_http_get_a_summary_of_tls_versions_oneOf_0_result_summary_0
}

type query_radar_http_get_a_summary_of_tls_versions_oneOf_0_result_summary_0 {
  TLS_1_0: String @resolveRootField(field: "TLS 1.0")
  TLS_1_1: String @resolveRootField(field: "TLS 1.1")
  TLS_1_2: String @resolveRootField(field: "TLS 1.2")
  TLS_1_3: String @resolveRootField(field: "TLS 1.3")
  TLS_QUIC: String @resolveRootField(field: "TLS QUIC")
}

type radar_http_get_a_summary_of_tls_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_bot_classes_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_bot_classes_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_bot_classes_4xx_response") = radar_http_get_time_series_of_bot_classes_200_response | radar_http_get_time_series_of_bot_classes_4xx_response

type radar_http_get_time_series_of_bot_classes_200_response {
  result: query_radar_http_get_time_series_of_bot_classes_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_bot_classes_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_bot_classes_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_bot_classes_oneOf_0_result_serie_0 {
  bot: [String]
  human: [String]
  timestamps: [String]
}

type radar_http_get_time_series_of_bot_classes_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_user_agents_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_user_agents_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_user_agents_4xx_response") = radar_http_get_time_series_of_user_agents_200_response | radar_http_get_time_series_of_user_agents_4xx_response

type radar_http_get_time_series_of_user_agents_200_response {
  result: query_radar_http_get_time_series_of_user_agents_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_user_agents_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_user_agents_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_user_agents_oneOf_0_result_serie_0 {
  _LESS_THAN_browser_name_GREATER_THAN_: [String] @resolveRootField(field: "<browser name>")
  timestamps: [String]
}

type radar_http_get_time_series_of_user_agents_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_user_agents_aggregated_in_families_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_user_agents_aggregated_in_families_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_user_agents_aggregated_in_families_4xx_response") = radar_http_get_time_series_of_user_agents_aggregated_in_families_200_response | radar_http_get_time_series_of_user_agents_aggregated_in_families_4xx_response

type radar_http_get_time_series_of_user_agents_aggregated_in_families_200_response {
  result: query_radar_http_get_time_series_of_user_agents_aggregated_in_families_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_user_agents_aggregated_in_families_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_user_agents_aggregated_in_families_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_user_agents_aggregated_in_families_oneOf_0_result_serie_0 {
  _LESS_THAN_browser_name_GREATER_THAN_: [String] @resolveRootField(field: "<browser name>")
  timestamps: [String]
}

type radar_http_get_time_series_of_user_agents_aggregated_in_families_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_device_types_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_device_types_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_device_types_4xx_response") = radar_http_get_time_series_of_device_types_200_response | radar_http_get_time_series_of_device_types_4xx_response

type radar_http_get_time_series_of_device_types_200_response {
  result: query_radar_http_get_time_series_of_device_types_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_device_types_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_device_types_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_device_types_oneOf_0_result_serie_0 {
  desktop: [String]
  mobile: [String]
  other: [String]
  timestamps: [String]
}

type radar_http_get_time_series_of_device_types_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_http_protocols_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_http_protocols_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_http_protocols_4xx_response") = radar_http_get_time_series_of_http_protocols_200_response | radar_http_get_time_series_of_http_protocols_4xx_response

type radar_http_get_time_series_of_http_protocols_200_response {
  result: query_radar_http_get_time_series_of_http_protocols_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_http_protocols_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_http_protocols_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_http_protocols_oneOf_0_result_serie_0 {
  http: [String]
  https: [String]
  timestamps: [String]
}

type radar_http_get_time_series_of_http_protocols_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_http_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_http_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_http_versions_4xx_response") = radar_http_get_time_series_of_http_versions_200_response | radar_http_get_time_series_of_http_versions_4xx_response

type radar_http_get_time_series_of_http_versions_200_response {
  result: query_radar_http_get_time_series_of_http_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_http_versions_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_http_versions_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_http_versions_oneOf_0_result_serie_0 {
  HTTP_1_x: [String] @resolveRootField(field: "HTTP/1.x")
  HTTP_2: [String] @resolveRootField(field: "HTTP/2")
  HTTP_3: [String] @resolveRootField(field: "HTTP/3")
  timestamps: [String]
}

type radar_http_get_time_series_of_http_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_ip_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_ip_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_ip_versions_4xx_response") = radar_http_get_time_series_of_ip_versions_200_response | radar_http_get_time_series_of_ip_versions_4xx_response

type radar_http_get_time_series_of_ip_versions_200_response {
  result: query_radar_http_get_time_series_of_ip_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_ip_versions_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_ip_versions_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_ip_versions_oneOf_0_result_serie_0 {
  IPv4: [String]
  IPv6: [String]
  timestamps: [String]
}

type radar_http_get_time_series_of_ip_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_time_series_of_tls_versions_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_time_series_of_tls_versions_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_time_series_of_tls_versions_4xx_response") = radar_http_get_time_series_of_tls_versions_200_response | radar_http_get_time_series_of_tls_versions_4xx_response

type radar_http_get_time_series_of_tls_versions_200_response {
  result: query_radar_http_get_time_series_of_tls_versions_oneOf_0_result
  success: String
}

type query_radar_http_get_time_series_of_tls_versions_oneOf_0_result {
  meta: JSON
  serie_0: query_radar_http_get_time_series_of_tls_versions_oneOf_0_result_serie_0
}

type query_radar_http_get_time_series_of_tls_versions_oneOf_0_result_serie_0 {
  TLS_1_0: [String] @resolveRootField(field: "TLS 1.0")
  TLS_1_1: [String] @resolveRootField(field: "TLS 1.1")
  TLS_1_2: [String] @resolveRootField(field: "TLS 1.2")
  TLS_1_3: [String] @resolveRootField(field: "TLS 1.3")
  TLS_QUIC: [String] @resolveRootField(field: "TLS QUIC")
  timestamps: [String]
}

type radar_http_get_time_series_of_tls_versions_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_autonomous_systems_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_http_requests_4xx_response") = radar_http_get_top_autonomous_systems_by_http_requests_200_response | radar_http_get_top_autonomous_systems_by_http_requests_4xx_response

type radar_http_get_top_autonomous_systems_by_http_requests_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_requests_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_autonomous_systems_by_bot_class_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_bot_class_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_bot_class_4xx_response") = radar_http_get_top_autonomous_systems_by_bot_class_200_response | radar_http_get_top_autonomous_systems_by_bot_class_4xx_response

type radar_http_get_top_autonomous_systems_by_bot_class_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_bot_class_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_bot_class_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"Bot class."
enum bot_class {
  LIKELY_AUTOMATED
  LIKELY_HUMAN
}

union radar_http_get_top_autonomous_systems_by_device_type_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_device_type_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_device_type_4xx_response") = radar_http_get_top_autonomous_systems_by_device_type_200_response | radar_http_get_top_autonomous_systems_by_device_type_4xx_response

type radar_http_get_top_autonomous_systems_by_device_type_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_device_type_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_device_type_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"Device type."
enum device_type {
  DESKTOP
  MOBILE
  OTHER
}

union radar_http_get_top_autonomous_systems_by_http_protocol_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_http_protocol_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_http_protocol_4xx_response") = radar_http_get_top_autonomous_systems_by_http_protocol_200_response | radar_http_get_top_autonomous_systems_by_http_protocol_4xx_response

type radar_http_get_top_autonomous_systems_by_http_protocol_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_protocol_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_http_protocol_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"HTTP Protocol."
enum http_protocol {
  HTTP
  HTTPS
}

union radar_http_get_top_autonomous_systems_by_http_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_http_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_http_version_4xx_response") = radar_http_get_top_autonomous_systems_by_http_version_200_response | radar_http_get_top_autonomous_systems_by_http_version_4xx_response

type radar_http_get_top_autonomous_systems_by_http_version_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_http_version_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_http_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"HTTP version."
enum http_version {
  HTTPv1
  HTTPv2
  HTTPv3
}

union radar_http_get_top_autonomous_systems_by_ip_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_ip_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_ip_version_4xx_response") = radar_http_get_top_autonomous_systems_by_ip_version_200_response | radar_http_get_top_autonomous_systems_by_ip_version_4xx_response

type radar_http_get_top_autonomous_systems_by_ip_version_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_ip_version_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_ip_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"IP version."
enum ip_version {
  IPv4
  IPv6
}

union radar_http_get_top_autonomous_systems_by_tls_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_autonomous_systems_by_tls_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_autonomous_systems_by_tls_version_4xx_response") = radar_http_get_top_autonomous_systems_by_tls_version_200_response | radar_http_get_top_autonomous_systems_by_tls_version_4xx_response

type radar_http_get_top_autonomous_systems_by_tls_version_200_response {
  result: query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result {
  meta: query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_autonomous_systems_by_tls_version_oneOf_0_result_top_0_items {
  clientASN: String
  clientASName: String
  value: String
}

type radar_http_get_top_autonomous_systems_by_tls_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

"TLS version."
enum tls_version {
  TLSv1_0
  TLSv1_1
  TLSv1_2
  TLSv1_3
  TLSvQUIC
}

union radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_4xx_response") = radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_200_response | radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_4xx_response

type radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_200_response {
  result: query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result {
  meta: query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_oneOf_0_result_top_0_items {
  _LESS_THAN_browser_name_GREATER_THAN_: String @resolveRootField(field: "<browser name>")
  value: String
}

type radar_http_get_top_user_agents_aggregated_in_families_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_user_agents_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_user_agents_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_user_agents_by_http_requests_4xx_response") = radar_http_get_top_user_agents_by_http_requests_200_response | radar_http_get_top_user_agents_by_http_requests_4xx_response

type radar_http_get_top_user_agents_by_http_requests_200_response {
  result: query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result {
  meta: query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_user_agents_by_http_requests_oneOf_0_result_top_0_items {
  _LESS_THAN_browser_name_GREATER_THAN_: String @resolveRootField(field: "<browser name>")
  value: String
}

type radar_http_get_top_user_agents_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_http_requests_4xx_response") = radar_http_get_top_locations_by_http_requests_200_response | radar_http_get_top_locations_by_http_requests_4xx_response

type radar_http_get_top_locations_by_http_requests_200_response {
  result: query_radar_http_get_top_locations_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_requests_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_bot_class_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_bot_class_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_bot_class_4xx_response") = radar_http_get_top_locations_by_bot_class_200_response | radar_http_get_top_locations_by_bot_class_4xx_response

type radar_http_get_top_locations_by_bot_class_200_response {
  result: query_radar_http_get_top_locations_by_bot_class_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_bot_class_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_bot_class_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_device_type_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_device_type_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_device_type_4xx_response") = radar_http_get_top_locations_by_device_type_200_response | radar_http_get_top_locations_by_device_type_4xx_response

type radar_http_get_top_locations_by_device_type_200_response {
  result: query_radar_http_get_top_locations_by_device_type_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_device_type_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_device_type_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_device_type_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_http_protocol_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_http_protocol_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_http_protocol_4xx_response") = radar_http_get_top_locations_by_http_protocol_200_response | radar_http_get_top_locations_by_http_protocol_4xx_response

type radar_http_get_top_locations_by_http_protocol_200_response {
  result: query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_protocol_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_http_protocol_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_http_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_http_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_http_version_4xx_response") = radar_http_get_top_locations_by_http_version_200_response | radar_http_get_top_locations_by_http_version_4xx_response

type radar_http_get_top_locations_by_http_version_200_response {
  result: query_radar_http_get_top_locations_by_http_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_http_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_http_version_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_http_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_ip_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_ip_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_ip_version_4xx_response") = radar_http_get_top_locations_by_ip_version_200_response | radar_http_get_top_locations_by_ip_version_4xx_response

type radar_http_get_top_locations_by_ip_version_200_response {
  result: query_radar_http_get_top_locations_by_ip_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_ip_version_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_ip_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_http_get_top_locations_by_tls_version_response @statusCodeTypeName(statusCode: 200, typeName: "radar_http_get_top_locations_by_tls_version_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_http_get_top_locations_by_tls_version_4xx_response") = radar_http_get_top_locations_by_tls_version_200_response | radar_http_get_top_locations_by_tls_version_4xx_response

type radar_http_get_top_locations_by_tls_version_200_response {
  result: query_radar_http_get_top_locations_by_tls_version_oneOf_0_result
  success: String
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result {
  meta: query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta
  top_0: [query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_top_0_items]
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta {
  confidenceInfo: query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_dateRange
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_http_get_top_locations_by_tls_version_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_http_get_top_locations_by_tls_version_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_net_flows_get_net_flow_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_net_flows_get_net_flow_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_net_flows_get_net_flow_time_series_4xx_response") = radar_net_flows_get_net_flow_time_series_200_response | radar_net_flows_get_net_flow_time_series_4xx_response

type radar_net_flows_get_net_flow_time_series_200_response {
  result: query_radar_net_flows_get_net_flow_time_series_oneOf_0_result
  success: String
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result {
  meta: query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta
  series: query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_series
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta {
  aggInterval: String
  confidenceInfo: query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_dateRange
  lastUpdated: DateTime
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_net_flows_get_net_flow_time_series_oneOf_0_result_series {
  timestamps: [DateTime]
  values: [String]
}

type radar_net_flows_get_net_flow_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_net_flows_get_top_autonomous_systems_response @statusCodeTypeName(statusCode: 200, typeName: "radar_net_flows_get_top_autonomous_systems_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_net_flows_get_top_autonomous_systems_4xx_response") = radar_net_flows_get_top_autonomous_systems_200_response | radar_net_flows_get_top_autonomous_systems_4xx_response

type radar_net_flows_get_top_autonomous_systems_200_response {
  result: query_radar_net_flows_get_top_autonomous_systems_oneOf_0_result
  success: String
}

type query_radar_net_flows_get_top_autonomous_systems_oneOf_0_result {
  top_0: [query_radar_net_flows_get_top_autonomous_systems_oneOf_0_result_top_0_items]
}

type query_radar_net_flows_get_top_autonomous_systems_oneOf_0_result_top_0_items {
  clientASN: Float
  clientASName: String
  value: String
}

type radar_net_flows_get_top_autonomous_systems_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_net_flows_get_top_locations_response @statusCodeTypeName(statusCode: 200, typeName: "radar_net_flows_get_top_locations_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_net_flows_get_top_locations_4xx_response") = radar_net_flows_get_top_locations_200_response | radar_net_flows_get_top_locations_4xx_response

type radar_net_flows_get_top_locations_200_response {
  result: query_radar_net_flows_get_top_locations_oneOf_0_result
  success: String
}

type query_radar_net_flows_get_top_locations_oneOf_0_result {
  top_0: [query_radar_net_flows_get_top_locations_oneOf_0_result_top_0_items]
}

type query_radar_net_flows_get_top_locations_oneOf_0_result_top_0_items {
  clientCountryAlpha2: String
  clientCountryName: String
  value: String
}

type radar_net_flows_get_top_locations_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_ranking_get_domains_rank_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_ranking_get_domains_rank_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_ranking_get_domains_rank_time_series_4xx_response") = radar_ranking_get_domains_rank_time_series_200_response | radar_ranking_get_domains_rank_time_series_4xx_response

type radar_ranking_get_domains_rank_time_series_200_response {
  result: query_radar_ranking_get_domains_rank_time_series_oneOf_0_result
  success: String
}

type query_radar_ranking_get_domains_rank_time_series_oneOf_0_result {
  meta: query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_meta
  serie_0: query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_serie_0
}

type query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_meta {
  dateRange: query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_meta_dateRange
}

type query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_meta_dateRange {
  "Adjusted end of date range."
  endTime: DateTime
  "Adjusted start of date range."
  startTime: DateTime
}

type query_radar_ranking_get_domains_rank_time_series_oneOf_0_result_serie_0 {
  _LESS_THAN_domain_name_GREATER_THAN_: [Int] @resolveRootField(field: "<domain name>")
  timestamps: [Date]
}

type radar_ranking_get_domains_rank_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_ranking_get_domains_rank_top_response @statusCodeTypeName(statusCode: 200, typeName: "radar_ranking_get_domains_rank_top_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_ranking_get_domains_rank_top_4xx_response") = radar_ranking_get_domains_rank_top_200_response | radar_ranking_get_domains_rank_top_4xx_response

type radar_ranking_get_domains_rank_top_200_response {
  result: query_radar_ranking_get_domains_rank_top_oneOf_0_result
  success: String
}

type query_radar_ranking_get_domains_rank_top_oneOf_0_result {
  meta: query_radar_ranking_get_domains_rank_top_oneOf_0_result_meta
  top_0: [query_radar_ranking_get_domains_rank_top_oneOf_0_result_top_0_items]
}

type query_radar_ranking_get_domains_rank_top_oneOf_0_result_meta {
  top_0: query_radar_ranking_get_domains_rank_top_oneOf_0_result_meta_top_0
}

type query_radar_ranking_get_domains_rank_top_oneOf_0_result_meta_top_0 {
  date: Date
}

type query_radar_ranking_get_domains_rank_top_oneOf_0_result_top_0_items {
  domain: String
  rank: Int
}

type radar_ranking_get_domains_rank_top_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_response @statusCodeTypeName(statusCode: 200, typeName: "radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_4xx_response") = radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_200_response | radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_4xx_response

type radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_200_response {
  result: [query_radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_oneOf_0_result_items]
  success: String
}

type query_radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_oneOf_0_result_items {
  code: String
  name: String
  type: String
}

type radar_search_search_for_locations_COMMA__autonomous_systems__as_and_reports_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_specialevents_list_special_events_response @statusCodeTypeName(statusCode: 200, typeName: "radar_specialevents_list_special_events_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_specialevents_list_special_events_4xx_response") = radar_specialevents_list_special_events_200_response | radar_specialevents_list_special_events_4xx_response

type radar_specialevents_list_special_events_200_response {
  result: query_radar_specialevents_list_special_events_oneOf_0_result
  success: String
}

type query_radar_specialevents_list_special_events_oneOf_0_result {
  specialEvents: [query_radar_specialevents_list_special_events_oneOf_0_result_specialEvents_items]
}

type query_radar_specialevents_list_special_events_oneOf_0_result_specialEvents_items {
  alias: String
  categories: [query_radar_specialevents_list_special_events_oneOf_0_result_specialEvents_items_categories_items]
  description: String
  id: Int
  title: String
}

type query_radar_specialevents_list_special_events_oneOf_0_result_specialEvents_items_categories_items {
  categoryAlias: String
  location: String
}

type radar_specialevents_list_special_events_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_specialevents_get_a_single_special_events_response @statusCodeTypeName(statusCode: 200, typeName: "radar_specialevents_get_a_single_special_events_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_specialevents_get_a_single_special_events_4xx_response") = radar_specialevents_get_a_single_special_events_200_response | radar_specialevents_get_a_single_special_events_4xx_response

type radar_specialevents_get_a_single_special_events_200_response {
  result: query_radar_specialevents_get_a_single_special_events_oneOf_0_result
  success: String
}

type query_radar_specialevents_get_a_single_special_events_oneOf_0_result {
  specialEvent: query_radar_specialevents_get_a_single_special_events_oneOf_0_result_specialEvent
}

type query_radar_specialevents_get_a_single_special_events_oneOf_0_result_specialEvent {
  alias: String
  categories: [query_radar_specialevents_get_a_single_special_events_oneOf_0_result_specialEvent_categories_items]
  description: String
  id: Int
  title: String
}

type query_radar_specialevents_get_a_single_special_events_oneOf_0_result_specialEvent_categories_items {
  categoryAlias: String
  location: String
}

type radar_specialevents_get_a_single_special_events_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_specialevents_get_special_events_time_series_response @statusCodeTypeName(statusCode: 200, typeName: "radar_specialevents_get_special_events_time_series_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_specialevents_get_special_events_time_series_4xx_response") = radar_specialevents_get_special_events_time_series_200_response | radar_specialevents_get_special_events_time_series_4xx_response

type radar_specialevents_get_special_events_time_series_200_response {
  result: query_radar_specialevents_get_special_events_time_series_oneOf_0_result
  success: String
}

type query_radar_specialevents_get_special_events_time_series_oneOf_0_result {
  serie_0: query_radar_specialevents_get_special_events_time_series_oneOf_0_result_serie_0
}

type query_radar_specialevents_get_special_events_time_series_oneOf_0_result_serie_0 {
  timestamps: [DateTime]
  values: [String]
}

type radar_specialevents_get_special_events_time_series_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_verified_bots_get_top_verified_bots_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_verified_bots_get_top_verified_bots_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_verified_bots_get_top_verified_bots_by_http_requests_4xx_response") = radar_verified_bots_get_top_verified_bots_by_http_requests_200_response | radar_verified_bots_get_top_verified_bots_by_http_requests_4xx_response

type radar_verified_bots_get_top_verified_bots_by_http_requests_200_response {
  result: query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result {
  meta: query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_verified_bots_get_top_verified_bots_by_http_requests_oneOf_0_result_top_0_items {
  botCategory: String
  botName: String
  botOwner: String
  value: String
}

type radar_verified_bots_get_top_verified_bots_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union radar_verified_bots_get_top_verified_bot_categories_by_http_requests_response @statusCodeTypeName(statusCode: 200, typeName: "radar_verified_bots_get_top_verified_bot_categories_by_http_requests_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_verified_bots_get_top_verified_bot_categories_by_http_requests_4xx_response") = radar_verified_bots_get_top_verified_bot_categories_by_http_requests_200_response | radar_verified_bots_get_top_verified_bot_categories_by_http_requests_4xx_response

type radar_verified_bots_get_top_verified_bot_categories_by_http_requests_200_response {
  result: query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result
  success: String
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result {
  meta: query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta
  top_0: [query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_top_0_items]
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta {
  confidenceInfo: query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_confidenceInfo
  dateRange: query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_dateRange
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_confidenceInfo {
  annotations: [query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items]
  level: Int
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_confidenceInfo_annotations_items {
  dataSource: String
  description: String
  endTime: DateTime
  eventType: String
  startTime: DateTime
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_meta_dateRange {
  endTime: DateTime
  startTime: DateTime
}

type query_radar_verified_bots_get_top_verified_bot_categories_by_http_requests_oneOf_0_result_top_0_items {
  botCategory: String
  value: String
}

type radar_verified_bots_get_top_verified_bot_categories_by_http_requests_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union railgun_list_railguns_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_list_railguns_4xx_response") = railgun_response_collection | railgun_list_railguns_4xx_response

type railgun_list_railguns_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union railgun_railgun_details_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_railgun_details_4xx_response") = railgun_response_single | railgun_railgun_details_4xx_response

type railgun_railgun_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union railgun_list_railgun_zones_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_list_railgun_zones_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_list_railgun_zones_4xx_response") = railgun_list_railgun_zones_200_response | railgun_list_railgun_zones_4xx_response

type railgun_list_railgun_zones_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_zone]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type railgun_list_railgun_zones_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_user_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_user_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_user_details_4xx_response") = single_user_response | user_user_details_4xx_response

type single_user_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type user_user_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union audit_logs_get_user_audit_logs_response @statusCodeTypeName(statusCode: "4xx", typeName: "audit_logs_get_user_audit_logs_4xx_response") = query_audit_logs_get_account_audit_logs_oneOf_0_oneOf_0 | api_response_common | audit_logs_get_user_audit_logs_4xx_response

type audit_logs_get_user_audit_logs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_billing_history_billing_history_details_response @statusCodeTypeName(statusCode: 200, typeName: "billing_history_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "user_billing_history_billing_history_details_4xx_response") = billing_history_collection | user_billing_history_billing_history_details_4xx_response

type billing_history_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [billing_history]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type billing_history {
  "The billing item action."
  action: action!
  "The amount associated with this billing item."
  amount: Float!
  "The monetary unit in which pricing information is displayed."
  currency: String!
  "The billing item description."
  description: schemas_description!
  "Billing item identifier tag."
  id: billing_history_components_schemas_identifier!
  "When the billing item was created."
  occurred_at: DateTime!
  "The billing item type."
  type: type!
  zone: schemas_zone!
}

"The billing item action."
scalar action @length(min: null, max: 30)

"The billing item description."
scalar schemas_description @length(min: null, max: 255)

"Billing item identifier tag."
scalar billing_history_components_schemas_identifier @length(min: null, max: 32)

"The billing item type."
scalar type @length(min: null, max: 30)

type schemas_zone {
  name: JSON
}

type user_billing_history_billing_history_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_billing_profile_billing_profile_details_response @statusCodeTypeName(statusCode: 200, typeName: "billing_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_billing_profile_billing_profile_details_4xx_response") = billing_response_single | user_billing_profile_billing_profile_details_4xx_response

type user_billing_profile_billing_profile_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_a_user_list_ip_access_rules_response @statusCodeTypeName(statusCode: 200, typeName: "rule_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_user_list_ip_access_rules_4xx_response") = rule_collection_response | ip_access_rules_for_a_user_list_ip_access_rules_4xx_response

type rule_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [rule]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type rule {
  "The available actions that a rule can apply to a matched request."
  allowed_modes: [schemas_mode]!
  configuration: schemas_configuration!
  "The timestamp of when the rule was created."
  created_on: DateTime
  "The unique identifier of the IP Access rule."
  id: rule_components_schemas_identifier!
  mode: schemas_mode!
  "The timestamp of when the rule was last modified."
  modified_on: DateTime
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
}

"The action to apply to a matched request."
enum schemas_mode {
  block
  challenge
  whitelist
  js_challenge
  managed_challenge
}

"The rule configuration."
union schemas_configuration = ip_configuration | An_IPv6_address_configuration_ | cidr_configuration | An_ASN_configuration_ | A_country_configuration_

type ip_configuration {
  target: ip_const
  "The IP address to match. This address will be compared to the IP address of incoming requests."
  value: String
}

enum ip_const @typescript(type: "\\"ip\\"") @example(value: "\\"ip\\"") {
  ip @enum(value: "\\"ip\\"")
}

type An_IPv6_address_configuration_ {
  target: ip6_const
  "The IPv6 address to match."
  value: IPv6
}

enum ip6_const @typescript(type: "\\"ip6\\"") @example(value: "\\"ip6\\"") {
  ip6 @enum(value: "\\"ip6\\"")
}

type cidr_configuration {
  target: ip_range_const
  "The IP address range to match. You can only use prefix lengths \`/16\` and \`/24\` for IPv4 ranges, and prefix lengths \`/32\`, \`/48\`, and \`/64\` for IPv6 ranges."
  value: String
}

enum ip_range_const @typescript(type: "\\"ip_range\\"") @example(value: "\\"ip_range\\"") {
  ip_range @enum(value: "\\"ip_range\\"")
}

type An_ASN_configuration_ {
  target: asn_const
  "The AS number to match."
  value: String
}

enum asn_const @typescript(type: "\\"asn\\"") @example(value: "\\"asn\\"") {
  asn @enum(value: "\\"asn\\"")
}

type A_country_configuration_ {
  target: country_const
  "The two-letter ISO-3166-1 alpha-2 code to match. For more information, refer to [IP Access rules: Parameters](https://developers.cloudflare.com/waf/tools/ip-access-rules/parameters/#country)."
  value: String
}

enum country_const @typescript(type: "\\"country\\"") @example(value: "\\"country\\"") {
  country @enum(value: "\\"country\\"")
}

"The unique identifier of the IP Access rule."
scalar rule_components_schemas_identifier @length(min: null, max: 32)

type ip_access_rules_for_a_user_list_ip_access_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_SINGLE_QUOTE__s_invites_list_invitations_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_collection_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_invites_list_invitations_4xx_response") = schemas_collection_invite_response | user_SINGLE_QUOTE__s_invites_list_invitations_4xx_response

type schemas_collection_invite_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_invite]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_invite {
  "When the invite is no longer active."
  expires_on: DateTime
  "Invite identifier tag."
  id: invite_components_schemas_identifier!
  "The email address of the user who created the invite."
  invited_by: EmailAddress
  "Email address of the user to add to the organization."
  invited_member_email: EmailAddress
  "ID of the user to add to the organization."
  invited_member_id: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_invited_member_id
  "When the invite was sent."
  invited_on: DateTime
  "ID of the organization the user will be added to."
  organization_id: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_id!
  "Organization name."
  organization_name: query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_organization_name
  "Roles to be assigned to this user."
  roles: [schemas_role]
  status: query_user_SINGLE_QUOTE__s_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_status
}

"Current status of the invitation."
enum query_user_SINGLE_QUOTE__s_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_status {
  pending
  accepted
  rejected
  expired
}

type user_SINGLE_QUOTE__s_invites_list_invitations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_SINGLE_QUOTE__s_invites_invitation_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_invites_invitation_details_4xx_response") = single_invite_response | user_SINGLE_QUOTE__s_invites_invitation_details_4xx_response

type user_SINGLE_QUOTE__s_invites_invitation_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_monitors_list_monitors_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_list_monitors_4xx_response") = monitor_components_schemas_response_collection | load_balancer_monitors_list_monitors_4xx_response

type monitor_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [monitor]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type monitor {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  created_on: DateTime
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header
  id: String!
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String
  modified_on: DateTime
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int
  type: monitor_components_schemas_type
}

type load_balancer_monitors_list_monitors_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union load_balancer_monitors_monitor_details_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_monitor_details_4xx_response") = monitor_components_schemas_single_response | load_balancer_monitors_monitor_details_4xx_response

type monitor_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: monitor
  "Whether the API call was successful"
  success: Boolean!
}

type load_balancer_monitors_monitor_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_monitors_list_monitor_references_response @statusCodeTypeName(statusCode: 200, typeName: "references_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_list_monitor_references_4xx_response") = references_response | load_balancer_monitors_list_monitor_references_4xx_response

type load_balancer_monitors_list_monitor_references_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union load_balancer_pools_list_pools_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_list_pools_4xx_response") = pool_components_schemas_response_collection | load_balancer_pools_list_pools_4xx_response

type load_balancer_pools_list_pools_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union load_balancer_pools_pool_details_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_pool_details_4xx_response") = pool_components_schemas_single_response | load_balancer_pools_pool_details_4xx_response

type load_balancer_pools_pool_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_pools_pool_health_details_response @statusCodeTypeName(statusCode: 200, typeName: "health_details") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_pool_health_details_4xx_response") = health_details | load_balancer_pools_pool_health_details_4xx_response

type load_balancer_pools_pool_health_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_pools_list_pool_references_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_references_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_list_pool_references_4xx_response") = schemas_references_response | load_balancer_pools_list_pool_references_4xx_response

type load_balancer_pools_list_pool_references_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union load_balancer_monitors_preview_result_response @statusCodeTypeName(statusCode: 200, typeName: "preview_result_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_preview_result_4xx_response") = preview_result_response | load_balancer_monitors_preview_result_4xx_response

type load_balancer_monitors_preview_result_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  abwlnp5jbqn45ecgxd03erbgtxtqai0d: query_account_load_balancer_monitors_preview_result_oneOf_0_allOf_1_abwlnp5jbqn45ecgxd03erbgtxtqai0d
  additionalProperties: JSON @resolveRoot
}

union load_balancer_healthcheck_events_list_healthcheck_events_response @statusCodeTypeName(statusCode: 200, typeName: "analytics_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_healthcheck_events_list_healthcheck_events_4xx_response") = analytics_components_schemas_response_collection | load_balancer_healthcheck_events_list_healthcheck_events_4xx_response

type analytics_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [analytics]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type analytics {
  id: Int
  origins: [JSON]
  pool: query_load_balancer_healthcheck_events_list_healthcheck_events_oneOf_0_allOf_1_result_items_pool
  timestamp: DateTime
}

type query_load_balancer_healthcheck_events_list_healthcheck_events_oneOf_0_allOf_1_result_items_pool {
  changed: Boolean
  healthy: Boolean
  id: String
  minimum_origins: Int
  name: String
}

type load_balancer_healthcheck_events_list_healthcheck_events_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_SINGLE_QUOTE__s_organizations_list_organizations_response @statusCodeTypeName(statusCode: 200, typeName: "collection_organization_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_organizations_list_organizations_4xx_response") = collection_organization_response | user_SINGLE_QUOTE__s_organizations_list_organizations_4xx_response

type collection_organization_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [organization]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type organization {
  "Identifier"
  id: common_components_schemas_identifier!
  "Organization name."
  name: schemas_name
  "Access permissions for this User."
  permissions: [query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_roles_items_permissions_items]
  "List of roles that a user has within an organization."
  roles: [query_user_SINGLE_QUOTE__s_organizations_list_organizations_oneOf_0_allOf_1_result_items_roles_items]
  status: components_schemas_status
}

"Organization name."
scalar schemas_name @length(min: null, max: 100)

scalar query_user_SINGLE_QUOTE__s_organizations_list_organizations_oneOf_0_allOf_1_result_items_roles_items @length(min: null, max: 120)

"Whether the user is a member of the organization or has an inivitation pending."
enum components_schemas_status {
  member
  invited
}

type user_SINGLE_QUOTE__s_organizations_list_organizations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_SINGLE_QUOTE__s_organizations_organization_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_organization_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_organizations_organization_details_4xx_response") = single_organization_response | user_SINGLE_QUOTE__s_organizations_organization_details_4xx_response

type user_SINGLE_QUOTE__s_organizations_organization_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_subscription_get_user_subscriptions_response @statusCodeTypeName(statusCode: 200, typeName: "user_subscription_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "user_subscription_get_user_subscriptions_4xx_response") = user_subscription_response_collection | user_subscription_get_user_subscriptions_4xx_response

type user_subscription_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [subscription]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type user_subscription_get_user_subscriptions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_api_tokens_list_tokens_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_list_tokens_4xx_response") = api_response_collection | user_api_tokens_list_tokens_4xx_response

type user_api_tokens_list_tokens_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union permission_groups_list_permission_groups_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "permission_groups_list_permission_groups_4xx_response") = schemas_response_collection | permission_groups_list_permission_groups_4xx_response

type schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type permission_groups_list_permission_groups_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_api_tokens_verify_token_response @statusCodeTypeName(statusCode: 200, typeName: "response_single_segment") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_verify_token_4xx_response") = response_single_segment | user_api_tokens_verify_token_4xx_response

type response_single_segment {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_user_api_tokens_verify_token_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_user_api_tokens_verify_token_oneOf_0_allOf_1_result {
  "The expiration time on or after which the JWT MUST NOT be accepted for processing."
  expires_on: DateTime
  "Token identifier tag."
  id: components_schemas_identifier!
  "The time before which the token MUST NOT be accepted for processing."
  not_before: DateTime
  status: status!
}

"Token identifier tag."
scalar components_schemas_identifier @length(min: null, max: 32)

"Status of the token."
enum status {
  active
  disabled
  expired
}

type user_api_tokens_verify_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_api_tokens_token_details_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_token_details_4xx_response") = response_single | user_api_tokens_token_details_4xx_response

type user_api_tokens_token_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_list_zones_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_list_zones_4xx_response") = components_schemas_response_collection | zone_list_zones_4xx_response

type components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [zone_components_schemas_zone]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type zone_components_schemas_zone {
  "The last time proof of ownership was detected and the zone was made\\nactive"
  activated_on: DateTime
  "When the zone was created"
  created_on: DateTime!
  "The interval (in seconds) from when development mode expires\\n(positive integer) or last expired (negative integer) for the\\ndomain. If development mode has never been enabled, this value is 0."
  development_mode: Float!
  "Identifier"
  id: common_components_schemas_identifier!
  "When the zone was last modified"
  modified_on: DateTime!
  name: query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_name!
  "DNS host at the time of switching to Cloudflare"
  original_dnshost: query_organization_railgun_get_railgun_zones_oneOf_0_allOf_1_result_items_original_dnshost
  "Original name servers before moving to Cloudflare\\nNotes: Is this only available for full zones?"
  original_name_servers: [Hostname]
  "Registrar for the domain at the time of switching to Cloudflare"
  original_registrar: String
}

type zone_list_zones_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union load_balancers_load_balancer_details_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_load_balancer_details_4xx_response") = load_balancer_components_schemas_single_response | load_balancers_load_balancer_details_4xx_response

type load_balancer_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: load_balancer
  "Whether the API call was successful"
  success: Boolean!
}

type load_balancer {
  adaptive_routing: adaptive_routing
  country_pools: country_pools
  created_on: DateTime
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]
  "Object description."
  description: String
  "Whether to enable (the default) this load balancer."
  enabled: Boolean
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON
  id: String!
  location_strategy: location_strategy
  modified_on: DateTime
  "The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used."
  name: String
  pop_pools: pop_pools
  "Whether the hostname should be gray clouded (false) or orange clouded (true)."
  proxied: Boolean
  random_steering: random_steering
  region_pools: region_pools
  "BETA Field Not General Access: A list of rules for this load balancer to execute."
  rules: [query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items]
  session_affinity: session_affinity
  session_affinity_attributes: session_affinity_attributes
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

"Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin."
type adaptive_routing {
  "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See \`session_affinity_attributes\` for control over when sessions are broken or reassigned."
  failover_across_pools: Boolean
}

"A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools."
type country_pools {
  GB: [String]
  US: [String]
}

"Controls location-based steering for non-proxied requests. See \`steering_policy\` to learn how steering is affected."
type location_strategy {
  mode: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_mode
  prefer_ecs: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_prefer_ecs
}

"Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.\\n- \`\\"pop\\"\`: Use the Cloudflare PoP location.\\n- \`\\"resolver_ip\\"\`: Use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, use the Cloudflare PoP location."
enum query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_mode {
  pop
  resolver_ip
}

"Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.\\n- \`\\"always\\"\`: Always prefer ECS.\\n- \`\\"never\\"\`: Never prefer ECS.\\n- \`\\"proximity\\"\`: Prefer ECS only when \`steering_policy=\\"proximity\\"\`.\\n- \`\\"geo\\"\`: Prefer ECS only when \`steering_policy=\\"geo\\"\`."
enum query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_prefer_ecs {
  always
  never
  proximity
  geo
}

"(Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools."
type pop_pools {
  LAX: [String]
  LHR: [String]
  SJC: [String]
}

"Configures pool weights for random steering. When steering_policy is 'random', a random pool is selected with probability proportional to these pool weights."
type random_steering {
  "The default weight for pools in the load balancer that are not specified in the pool_weights map."
  default_weight: NonNegativeFloat
  pool_weights: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_random_steering_pool_weights
}

"A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer."
type query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_random_steering_pool_weights {
  _9290f38c5d07c2e2f4df57b1f61d4196: Float @resolveRootField(field: "9290f38c5d07c2e2f4df57b1f61d4196")
  de90f38ced07c2e2f4df50b1f61d4194: Float
}

"A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools."
type region_pools {
  ENAM: [String]
  WNAM: [String]
}

"A rule object containing conditions and overrides for this load balancer to evaluate."
type query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items {
  "The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions."
  condition: String
  "Disable this specific rule. It will no longer be evaluated by this load balancer."
  disabled: Boolean
  fixed_response: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response
  "Name of this rule. Only used for human readability."
  name: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_name
  overrides: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides
  "The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority."
  priority: Int
  "If this rule's condition is true, this causes rule evaluation to stop after processing this rule."
  terminates: Boolean
}

"A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates."
type query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response {
  "The http 'Content-Type' header to include in the response."
  content_type: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_content_type
  "The http 'Location' header to include in the response."
  location: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_location
  "Text to include as the http body."
  message_body: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_message_body
  "The http status code to respond with."
  status_code: Int
}

"The http 'Content-Type' header to include in the response."
scalar query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_content_type @length(min: null, max: 32)

"The http 'Location' header to include in the response."
scalar query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_location @length(min: null, max: 2048)

"Text to include as the http body."
scalar query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_message_body @length(min: null, max: 1024)

"Name of this rule. Only used for human readability."
scalar query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_name @length(min: null, max: 200)

"A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional."
type query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides {
  adaptive_routing: adaptive_routing
  country_pools: country_pools
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON
  location_strategy: location_strategy
  pop_pools: pop_pools
  random_steering: random_steering
  region_pools: region_pools
  session_affinity: session_affinity
  session_affinity_attributes: session_affinity_attributes
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

"The session_affinity specifies the type of session affinity the load balancer should use unless specified as \\"none\\" or \\"\\"(default). The supported types are \\"cookie\\" and \\"ip_cookie\\". \\"cookie\\" - On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy then a new origin server is calculated and used. \\"ip_cookie\\" behaves the same as \\"cookie\\" except the initial origin selection is stable and based on the client’s ip address."
enum session_affinity {
  none
  cookie
  ip_cookie
  _QUOTATION_MARK__QUOTATION_MARK_ @enum(value: "\\"\\\\\\"\\\\\\"\\"")
}

"Configures cookie attributes for session affinity cookie."
type session_affinity_attributes {
  "Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer."
  drain_duration: Float
  samesite: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_samesite
  secure: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_secure
  zero_downtime_failover: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_zero_downtime_failover
}

"Configures the SameSite attribute on session affinity cookie. Value \\"Auto\\" will be translated to \\"Lax\\" or \\"None\\" depending if Always Use HTTPS is enabled. Note: when using value \\"None\\", the secure attribute can not be set to \\"Never\\"."
enum query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_samesite {
  Auto
  Lax
  None
  Strict
}

"Configures the Secure attribute on session affinity cookie. Value \\"Always\\" indicates the Secure attribute will be set in the Set-Cookie header, \\"Never\\" indicates the Secure attribute will not be set, and \\"Auto\\" will set the Secure attribute depending if Always Use HTTPS is enabled."
enum query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_secure {
  Auto
  Always
  Never
}

"Configures the zero-downtime failover between origins within a pool when session affinity is enabled. Value \\"none\\" means no failover takes place for sessions pinned to the origin (default). Value \\"temporary\\" means traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. Value \\"sticky\\" means the session affinity cookie is updated and subsequent requests are sent to the new origin. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance."
enum query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_zero_downtime_failover {
  none
  temporary
  sticky
}

"Steering Policy for this load balancer.\\n- \`\\"off\\"\`: Use \`default_pools\`.\\n- \`\\"geo\\"\`: Use \`region_pools\`/\`country_pools\`/\`pop_pools\`. For non-proxied requests, the country for \`country_pools\` is determined by \`location_strategy\`.\\n- \`\\"random\\"\`: Select a pool randomly.\\n- \`\\"dynamic_latency\\"\`: Use round trip time to select the closest pool in default_pools (requires pool health checks).\\n- \`\\"proximity\\"\`: Use the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by \`location_strategy\` for non-proxied requests.\\n- \`\\"\\"\`: Will map to \`\\"geo\\"\` if you use \`region_pools\`/\`country_pools\`/\`pop_pools\` otherwise \`\\"off\\"\`."
enum steering_policy {
  off
  geo
  random
  dynamic_latency
  proximity
  _QUOTATION_MARK__QUOTATION_MARK_ @enum(value: "\\"\\\\\\"\\\\\\"\\"")
}

type load_balancers_load_balancer_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_zone_details_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_zone_details_4xx_response") = components_schemas_response_single | zone_zone_details_4xx_response

type components_schemas_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zone_zone_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_applications_list_access_applications_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_response_collection_2") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_list_access_applications_4xx_response") = apps_components_schemas_response_collection_2 | zone_level_access_applications_list_access_applications_4xx_response

type apps_components_schemas_response_collection_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_apps]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_apps {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  "The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account."
  allowed_idps: [String]
  app_launcher_visible: JSON
  "When set to \`true\`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps."
  auto_redirect_to_identity: Boolean
  cors_headers: cors_headers
  "The custom error message shown to a user when they are denied access to the application."
  custom_deny_message: String
  "The custom URL a user is redirected to when they are denied access to the application."
  custom_deny_url: String
  "The URL or domain of the bookmark."
  domain: String
  "Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks."
  enable_binding_cookie: Boolean
  "Enables the HttpOnly cookie attribute, which increases security against XSS attacks."
  http_only_cookie_attribute: Boolean
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "Sets the SameSite cookie setting, which provides increased security against CSRF attacks."
  same_site_cookie_attribute: String
  "Returns a 401 status code when the request is blocked by a Service Auth policy."
  service_auth_401_redirect: Boolean
  "The amount of time that tokens issued for this application will be valid. Must be in the format \`300ms\` or \`2h45m\`. Valid time units are: ns, us (or µs), ms, s, m, h."
  session_duration: String
  "Enables automatic authentication through cloudflared."
  skip_interstitial: Boolean
  "The application type."
  type: String
  saas_app: saas_app
}

type zone_level_access_applications_list_access_applications_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response") = ca_components_schemas_response_collection | zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response

type zone_level_access_short_lived_certificate_c_as_list_short_lived_certificate_c_as_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_applications_get_an_access_application_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_get_an_access_application_4xx_response") = apps_components_schemas_single_response_2 | zone_level_access_applications_get_an_access_application_4xx_response

type apps_components_schemas_single_response_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_apps
  "Whether the API call was successful"
  success: Boolean!
}

type zone_level_access_applications_get_an_access_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_applications_test_access_policies_response @statusCodeTypeName(statusCode: 200, typeName: "policy_check_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_test_access_policies_4xx_response") = policy_check_response | zone_level_access_applications_test_access_policies_4xx_response

type zone_level_access_applications_test_access_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_policies_get_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_policies_get_an_access_policy_4xx_response") = policies_components_schemas_single_response | zone_level_access_policies_get_an_access_policy_4xx_response

type zone_level_access_policies_get_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_single_response | zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response

type zone_level_access_short_lived_certificate_c_as_get_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_policies_list_access_policies_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_policies_list_access_policies_4xx_response") = policies_components_schemas_response_collection | zone_level_access_policies_list_access_policies_4xx_response

type zone_level_access_policies_list_access_policies_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_m_tls_authentication_list_m_tls_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_m_tls_authentication_list_m_tls_certificates_4xx_response") = certificates_components_schemas_response_collection | zone_level_access_m_tls_authentication_list_m_tls_certificates_4xx_response

type zone_level_access_m_tls_authentication_list_m_tls_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_m_tls_authentication_get_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_m_tls_authentication_get_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | zone_level_access_m_tls_authentication_get_an_m_tls_certificate_4xx_response

type zone_level_access_m_tls_authentication_get_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_groups_list_access_groups_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_groups_list_access_groups_4xx_response") = groups_components_schemas_response_collection | zone_level_access_groups_list_access_groups_4xx_response

type zone_level_access_groups_list_access_groups_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_groups_get_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_groups_get_an_access_group_4xx_response") = groups_components_schemas_single_response | zone_level_access_groups_get_an_access_group_4xx_response

type zone_level_access_groups_get_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_identity_providers_list_access_identity_providers_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_identity_providers_list_access_identity_providers_4xx_response") = identity_providers_components_schemas_response_collection | zone_level_access_identity_providers_list_access_identity_providers_4xx_response

type zone_level_access_identity_providers_list_access_identity_providers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_level_access_identity_providers_get_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_identity_providers_get_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | zone_level_access_identity_providers_get_an_access_identity_provider_4xx_response

type zone_level_access_identity_providers_get_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_zero_trust_organization_get_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_zero_trust_organization_get_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zone_level_zero_trust_organization_get_your_zero_trust_organization_4xx_response

type zone_level_zero_trust_organization_get_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_service_tokens_list_service_tokens_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_service_tokens_list_service_tokens_4xx_response") = service_tokens_components_schemas_response_collection | zone_level_access_service_tokens_list_service_tokens_4xx_response

type zone_level_access_service_tokens_list_service_tokens_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union dns_analytics_table_response @statusCodeTypeName(statusCode: 200, typeName: "dns_analytics_table_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_analytics_table_4xx_response") = dns_analytics_table_200_response | dns_analytics_table_4xx_response

type dns_analytics_table_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type dns_analytics_table_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_analytics_by_time_response @statusCodeTypeName(statusCode: 200, typeName: "dns_analytics_by_time_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_analytics_by_time_4xx_response") = dns_analytics_by_time_200_response | dns_analytics_by_time_4xx_response

type dns_analytics_by_time_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: result
  "Whether the API call was successful"
  success: Boolean!
}

type dns_analytics_by_time_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancers_list_load_balancers_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_list_load_balancers_4xx_response") = load_balancer_components_schemas_response_collection | load_balancers_list_load_balancers_4xx_response

type load_balancer_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [load_balancer]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type load_balancers_list_load_balancers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__secondary_zone_secondary_zone_configuration_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_incoming") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__secondary_zone_secondary_zone_configuration_details_4xx_response") = single_response_incoming | secondary_dns__secondary_zone_secondary_zone_configuration_details_4xx_response

type single_response_incoming {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_secondary_dns__secondary_zone_secondary_zone_configuration_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_secondary_dns__secondary_zone_secondary_zone_configuration_details_oneOf_0_allOf_1_result {
  "How often should a secondary zone auto refresh regardless of DNS NOTIFY.\\nNot applicable for primary zones."
  auto_refresh_seconds: Float
  "The time for a specific event."
  checked_time: DateTime
  "The time for a specific event."
  created_time: DateTime
  id: String!
  "The time for a specific event."
  modified_time: DateTime
  "Zone name."
  name: String
  "A list of peer tags."
  peers: [JSON]
  "The serial number of the SOA for the given zone."
  soa_serial: Float
}

type secondary_dns__secondary_zone_secondary_zone_configuration_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_primary_zone_configuration_details_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_outgoing") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_primary_zone_configuration_details_4xx_response") = single_response_outgoing | secondary_dns__primary_zone_primary_zone_configuration_details_4xx_response

type single_response_outgoing {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_secondary_dns__primary_zone_primary_zone_configuration_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_secondary_dns__primary_zone_primary_zone_configuration_details_oneOf_0_allOf_1_result {
  "The time for a specific event."
  checked_time: DateTime
  "The time for a specific event."
  created_time: DateTime
  id: String!
  "The time for a specific event."
  last_transferred_time: DateTime
  "Zone name."
  name: String
  "A list of peer tags."
  peers: [JSON]
  "The serial number of the SOA for the given zone."
  soa_serial: Float
}

type secondary_dns__primary_zone_primary_zone_configuration_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_get_outgoing_zone_transfer_status_response @statusCodeTypeName(statusCode: 200, typeName: "enable_transfer_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_get_outgoing_zone_transfer_status_4xx_response") = enable_transfer_response | secondary_dns__primary_zone_get_outgoing_zone_transfer_status_4xx_response

type enable_transfer_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The zone transfer status of a primary zone"
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__primary_zone_get_outgoing_zone_transfer_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_subscription_zone_subscription_details_response @statusCodeTypeName(statusCode: 200, typeName: "zone_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_subscription_zone_subscription_details_4xx_response") = zone_subscription_response_single | zone_subscription_zone_subscription_details_4xx_response

type zone_subscription_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zone_subscription_zone_subscription_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union total_tls_total_tls_settings_details_response @statusCodeTypeName(statusCode: 200, typeName: "total_tls_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "total_tls_total_tls_settings_details_4xx_response") = total_tls_settings_response | total_tls_total_tls_settings_details_4xx_response

type total_tls_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_total_tls_total_tls_settings_details_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_total_tls_total_tls_settings_details_oneOf_0_allOf_1_result {
  certificate_authority: schemas_certificate_authority
  "If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone."
  enabled: Boolean
  validity_days: schemas_validity_days
}

"The Certificate Authority that Total TLS certificates will be issued through."
enum schemas_certificate_authority {
  google
  lets_encrypt
}

enum schemas_validity_days @typescript(type: "90") @example(value: "90") {
  _90 @enum(value: "90")
}

type total_tls_total_tls_settings_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_analytics__deprecated_get_analytics_by_co_locations_response @statusCodeTypeName(statusCode: 200, typeName: "colo_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_analytics__deprecated_get_analytics_by_co_locations_4xx_response") = colo_response | zone_analytics__deprecated_get_analytics_by_co_locations_4xx_response

type colo_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "A breakdown of all dashboard analytics data by co-locations. This is limited to Enterprise zones only."
  result: [query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  query: query_response
}

type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items {
  "The airport code identifer for the co-location."
  colo_id: String
  "Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters."
  timeseries: [query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items]
  totals: totals_by_colo
}

type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items {
  bandwidth: bandwidth_by_colo
  requests: requests_by_colo
  "The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.\\n\\nRanges that the Cloudflare web application provides will provide the following period length for each point:\\n- Last 60 minutes (from -59 to -1): 1 minute resolution\\n- Last 7 hours (from -419 to -60): 15 minutes resolution\\n- Last 15 hours (from -899 to -420): 30 minutes resolution\\n- Last 72 hours (from -4320 to -900): 1 hour resolution\\n- Older than 3 days (-525600 to -4320): 1 day resolution."
  since: String
  threats: threats
  "The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used."
  until: String
}

"Breakdown of totals for bandwidth in the form of bytes."
type bandwidth_by_colo {
  "The total number of bytes served within the time frame."
  all: Int
  "The number of bytes that were cached (and served) by Cloudflare."
  cached: Int
  "The number of bytes that were fetched and served from the origin server."
  uncached: Int
}

"Breakdown of totals for requests."
type requests_by_colo {
  "Total number of requests served."
  all: Int
  "Total number of cached requests served."
  cached: Int
  country: query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_requests_country
  http_status: query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_requests_http_status
  "Total number of requests served from the origin."
  uncached: Int
}

"Key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country."
type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_requests_country {
  AG: Int
  GI: Int
  US: Int
  additionalProperties: JSON @resolveRoot
}

"A variable list of key/value pairs where the key is a HTTP status code and the value is the number of requests with that code served."
type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_requests_http_status {
  _200: Int @resolveRootField(field: "200")
  _301: Int @resolveRootField(field: "301")
  _400: Int @resolveRootField(field: "400")
  _402: Int @resolveRootField(field: "402")
  _404: Int @resolveRootField(field: "404")
}

"Breakdown of totals for threats."
type threats {
  "The total number of identifiable threats received over the time frame."
  all: Int
  country: query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_threats_country
  type: query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_threats_type
}

"A list of key/value pairs where the key is a two-digit country code and the value is the number of malicious requests received from that country."
type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_threats_country {
  AU: Int
  CN: Int
  US: Int
}

"The list of key/value pairs where the key is a threat category and the value is the number of requests."
type query_zone_analytics__deprecated_get_analytics_by_co_locations_oneOf_0_allOf_1_result_items_timeseries_items_threats_type {
  hot_ban_unknown: Int @resolveRootField(field: "hot.ban.unknown")
  macro_chl_captchaErr: Int @resolveRootField(field: "macro.chl.captchaErr")
  macro_chl_jschlErr: Int @resolveRootField(field: "macro.chl.jschlErr")
  user_ban_ip: Int @resolveRootField(field: "user.ban.ip")
}

"Breakdown of totals by data type."
type totals_by_colo {
  bandwidth: bandwidth_by_colo
  requests: requests_by_colo
  "The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.\\n\\nRanges that the Cloudflare web application provides will provide the following period length for each point:\\n- Last 60 minutes (from -59 to -1): 1 minute resolution\\n- Last 7 hours (from -419 to -60): 15 minutes resolution\\n- Last 15 hours (from -899 to -420): 30 minutes resolution\\n- Last 72 hours (from -4320 to -900): 1 hour resolution\\n- Older than 3 days (-525600 to -4320): 1 day resolution."
  since: String
  threats: threats
  "The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used."
  until: String
}

"The exact parameters/timestamps the analytics service used to return data."
type query_response {
  "The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.\\n\\nRanges that the Cloudflare web application provides will provide the following period length for each point:\\n- Last 60 minutes (from -59 to -1): 1 minute resolution\\n- Last 7 hours (from -419 to -60): 15 minutes resolution\\n- Last 15 hours (from -899 to -420): 30 minutes resolution\\n- Last 72 hours (from -4320 to -900): 1 hour resolution\\n- Older than 3 days (-525600 to -4320): 1 day resolution."
  since: String
  "The amount of time (in minutes) that each data point in the timeseries represents. The granularity of the time-series returned (e.g. each bucket in the time series representing 1-minute vs 1-day) is calculated by the API based on the time-range provided to the API."
  time_delta: Int
  "The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used."
  until: String
}

type zone_analytics__deprecated_get_analytics_by_co_locations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  query: query_response
}

union zone_analytics__deprecated_get_dashboard_response @statusCodeTypeName(statusCode: 200, typeName: "dashboard_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_analytics__deprecated_get_dashboard_4xx_response") = dashboard_response | zone_analytics__deprecated_get_dashboard_4xx_response

type dashboard_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Dashboard_response
  "Whether the API call was successful"
  success: Boolean!
  query: query_response
}

"Totals and timeseries data."
type Dashboard_response {
  "Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters."
  timeseries: [query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items]
  totals: totals
}

type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items {
  bandwidth: bandwidth
  pageviews: pageviews
  requests: schemas_requests
  "The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.\\n\\nRanges that the Cloudflare web application provides will provide the following period length for each point:\\n- Last 60 minutes (from -59 to -1): 1 minute resolution\\n- Last 7 hours (from -419 to -60): 15 minutes resolution\\n- Last 15 hours (from -899 to -420): 30 minutes resolution\\n- Last 72 hours (from -4320 to -900): 1 hour resolution\\n- Older than 3 days (-525600 to -4320): 1 day resolution."
  since: String
  threats: threats
  uniques: uniques
  "The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used."
  until: String
}

"Breakdown of totals for bandwidth in the form of bytes."
type bandwidth {
  "The total number of bytes served within the time frame."
  all: Int
  "The number of bytes that were cached (and served) by Cloudflare."
  cached: Int
  content_type: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_content_type
  country: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_country
  ssl: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_ssl
  ssl_protocols: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_ssl_protocols
  "The number of bytes that were fetched and served from the origin server."
  uncached: Int
}

"A variable list of key/value pairs where the key represents the type of content served, and the value is the number in bytes served."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_content_type {
  css: Int
  gif: Int
  html: Int
  javascript: Int
  jpeg: Int
}

"A variable list of key/value pairs where the key is a two-digit country code and the value is the number of bytes served to that country."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_country {
  AG: Int
  GI: Int
  US: Int
}

"A break down of bytes served over HTTPS."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_ssl {
  "The number of bytes served over HTTPS."
  encrypted: Int
  "The number of bytes served over HTTP."
  unencrypted: Int
}

"A breakdown of requests by their SSL protocol."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_bandwidth_ssl_protocols {
  "The number of requests served over TLS v1.0."
  TLSv1: Int
  "The number of requests served over TLS v1.1."
  TLSv1_1: Int @resolveRootField(field: "TLSv1.1")
  "The number of requests served over TLS v1.2."
  TLSv1_2: Int @resolveRootField(field: "TLSv1.2")
  "The number of requests served over TLS v1.3."
  TLSv1_3: Int @resolveRootField(field: "TLSv1.3")
  "The number of requests served over HTTP."
  none: Int
}

"Breakdown of totals for pageviews."
type pageviews {
  "The total number of pageviews served within the time range."
  all: Int
  search_engine: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_pageviews_search_engine
}

"A variable list of key/value pairs representing the search engine and number of hits."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_pageviews_search_engine {
  baidubot: Int
  bingbot: Int
  googlebot: Int
  pingdom: Int
}

"Breakdown of totals for requests."
type schemas_requests {
  "Total number of requests served."
  all: Int
  "Total number of cached requests served."
  cached: Int
  content_type: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_content_type
  country: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_country
  http_status: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_http_status
  ssl: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_ssl
  ssl_protocols: query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_ssl_protocols
  "Total number of requests served from the origin."
  uncached: Int
}

"A variable list of key/value pairs where the key represents the type of content served, and the value is the number of requests."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_content_type {
  css: Int
  gif: Int
  html: Int
  javascript: Int
  jpeg: Int
}

"A variable list of key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_country {
  AG: Int
  GI: Int
  US: Int
}

"Key/value pairs where the key is a HTTP status code and the value is the number of requests served with that code."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_http_status {
  _200: Int @resolveRootField(field: "200")
  _301: Int @resolveRootField(field: "301")
  _400: Int @resolveRootField(field: "400")
  _402: Int @resolveRootField(field: "402")
  _404: Int @resolveRootField(field: "404")
  additionalProperties: JSON @resolveRoot
}

"A break down of requests served over HTTPS."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_ssl {
  "The number of requests served over HTTPS."
  encrypted: Int
  "The number of requests served over HTTP."
  unencrypted: Int
}

"A breakdown of requests by their SSL protocol."
type query_zone_analytics__deprecated_get_dashboard_oneOf_0_allOf_1_result_timeseries_items_requests_ssl_protocols {
  "The number of requests served over TLS v1.0."
  TLSv1: Int
  "The number of requests served over TLS v1.1."
  TLSv1_1: Int @resolveRootField(field: "TLSv1.1")
  "The number of requests served over TLS v1.2."
  TLSv1_2: Int @resolveRootField(field: "TLSv1.2")
  "The number of requests served over TLS v1.3."
  TLSv1_3: Int @resolveRootField(field: "TLSv1.3")
  "The number of requests served over HTTP."
  none: Int
}

type uniques {
  "Total number of unique IP addresses within the time range."
  all: Int
}

"Breakdown of totals by data type."
type totals {
  bandwidth: bandwidth
  pageviews: pageviews
  requests: schemas_requests
  "The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.\\n\\nRanges that the Cloudflare web application provides will provide the following period length for each point:\\n- Last 60 minutes (from -59 to -1): 1 minute resolution\\n- Last 7 hours (from -419 to -60): 15 minutes resolution\\n- Last 15 hours (from -899 to -420): 30 minutes resolution\\n- Last 72 hours (from -4320 to -900): 1 hour resolution\\n- Older than 3 days (-525600 to -4320): 1 day resolution."
  since: String
  threats: threats
  uniques: uniques
  "The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used."
  until: String
}

type zone_analytics__deprecated_get_dashboard_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  query: query_response
}

union argo_analytics_for_zone_argo_analytics_for_a_zone_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_analytics_for_zone_argo_analytics_for_a_zone_4xx_response") = schemas_response_single | argo_analytics_for_zone_argo_analytics_for_a_zone_4xx_response

type schemas_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type argo_analytics_for_zone_argo_analytics_for_a_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps_4xx_response") = schemas_response_single | argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps_4xx_response

type argo_analytics_for_geolocation_argo_analytics_for_a_zone_at_different_po_ps_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union argo_smart_routing_get_argo_smart_routing_setting_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_smart_routing_get_argo_smart_routing_setting_4xx_response") = schemas_response_single | argo_smart_routing_get_argo_smart_routing_setting_4xx_response

type argo_smart_routing_get_argo_smart_routing_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rate_plan_list_available_plans_response @statusCodeTypeName(statusCode: 200, typeName: "zone_rate_plan_list_available_plans_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rate_plan_list_available_plans_4xx_response") = zone_rate_plan_list_available_plans_200_response | zone_rate_plan_list_available_plans_4xx_response

type zone_rate_plan_list_available_plans_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [available_rate_plan]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type available_rate_plan {
  "Indicates whether you can subscribe to this plan."
  can_subscribe: Boolean
  "The monetary unit in which pricing information is displayed."
  currency: String
  "Indicates whether this plan is managed externally."
  externally_managed: Boolean
  frequency: schemas_frequency
  "Identifier"
  id: common_components_schemas_identifier!
  "Indicates whether you are currently subscribed to this plan."
  is_subscribed: Boolean
  "Indicates whether this plan has a legacy discount applied."
  legacy_discount: Boolean
  "The legacy identifier for this rate plan, if any."
  legacy_id: String
  "The plan name."
  name: rate_plan_components_schemas_name
  "The amount you will be billed for this plan."
  price: Float
}

"The frequency at which you will be billed for this plan."
enum schemas_frequency {
  weekly
  monthly
  quarterly
  yearly
}

"The plan name."
scalar rate_plan_components_schemas_name @length(min: null, max: 80)

type zone_rate_plan_list_available_plans_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_rate_plan_available_plan_details_response @statusCodeTypeName(statusCode: 200, typeName: "zone_rate_plan_available_plan_details_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rate_plan_available_plan_details_4xx_response") = zone_rate_plan_available_plan_details_200_response | zone_rate_plan_available_plan_details_4xx_response

type zone_rate_plan_available_plan_details_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: available_rate_plan
  "Whether the API call was successful"
  success: Boolean!
}

type zone_rate_plan_available_plan_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rate_plan_list_available_rate_plans_response @statusCodeTypeName(statusCode: 200, typeName: "plan_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rate_plan_list_available_rate_plans_4xx_response") = plan_response_collection | zone_rate_plan_list_available_rate_plans_4xx_response

type plan_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_rate_plan]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_rate_plan {
  "Array of available components values for the plan."
  components: [component_value2]
  "The monetary unit in which pricing information is displayed."
  currency: String
  "The duration of the plan subscription."
  duration: Float
  frequency: schemas_frequency
  "Plan identifier tag."
  id: String
  "The plan name."
  name: rate_plan_components_schemas_name
}

type component_value2 {
  "The default amount allocated."
  default: Float
  name: component_value_components_schemas_name
  "The unit price of the addon."
  unit_price: Float
}

"The unique component."
enum component_value_components_schemas_name {
  zones
  page_rules
  dedicated_certificates
  dedicated_certificates_custom
}

type zone_rate_plan_list_available_rate_plans_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_cache_settings_get_cache_reserve_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_cache_settings_get_cache_reserve_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_cache_settings_get_cache_reserve_setting_4xx_response") = zone_cache_settings_get_cache_reserve_setting_200_response | zone_cache_settings_get_cache_reserve_setting_4xx_response

type zone_cache_settings_get_cache_reserve_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_cache_settings_get_cache_reserve_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zone_cache_settings_get_cache_reserve_setting_oneOf_0_allOf_1_result {
  id: cache_reserve_const
  "last time this setting was modified."
  modified_on: DateTime
  value: cache_reserve_value!
}

enum cache_reserve_const @typescript(type: "\\"cache_reserve\\"") @example(value: "\\"cache_reserve\\"") {
  cache_reserve @enum(value: "\\"cache_reserve\\"")
}

"Value of the Cache Reserve zone setting."
enum cache_reserve_value {
  on
  off
}

type zone_cache_settings_get_cache_reserve_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_cache_settings_get_variants_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_cache_settings_get_variants_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_cache_settings_get_variants_setting_4xx_response") = zone_cache_settings_get_variants_setting_200_response | zone_cache_settings_get_variants_setting_4xx_response

type zone_cache_settings_get_variants_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_cache_settings_get_variants_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zone_cache_settings_get_variants_setting_oneOf_0_allOf_1_result {
  id: variants_const
  "last time this setting was modified."
  modified_on: DateTime
  value: variants_value!
}

enum variants_const @typescript(type: "\\"variants\\"") @example(value: "\\"variants\\"") {
  variants @enum(value: "\\"variants\\"")
}

"Value of the zone setting."
type variants_value {
  "List of strings with the MIME types of all the variants that should be served for avif."
  avif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for bmp."
  bmp: [JSON]
  "List of strings with the MIME types of all the variants that should be served for gif."
  gif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jp2."
  jp2: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpeg."
  jpeg: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpg."
  jpg: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpg2."
  jpg2: [JSON]
  "List of strings with the MIME types of all the variants that should be served for png."
  png: [JSON]
  "List of strings with the MIME types of all the variants that should be served for tif."
  tif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for tiff."
  tiff: [JSON]
  "List of strings with the MIME types of all the variants that should be served for webp."
  webp: [JSON]
}

type zone_cache_settings_get_variants_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_ssl_for_a_zone_list_ssl_configurations_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_list_ssl_configurations_4xx_response") = certificate_response_collection | custom_ssl_for_a_zone_list_ssl_configurations_4xx_response

type certificate_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [custom_certificate]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type custom_certificate {
  bundle_method: bundle_method!
  "When the certificate from the authority expires."
  expires_on: DateTime!
  geo_restrictions: geo_restrictions
  hosts: [query_custom_ssl_for_a_zone_list_ssl_configurations_oneOf_0_allOf_1_result_items_hosts_items]!
  "Custom certificate identifier tag."
  id: custom_certificate_components_schemas_identifier!
  "The certificate authority that issued the certificate."
  issuer: String!
  keyless_server: keyless_certificate
  "When the certificate was last modified."
  modified_on: DateTime!
  "Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected."
  policy: String
  "The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates."
  priority: Float!
  "The type of hash used for the certificate."
  signature: String!
  status: custom_certificate_components_schemas_status!
  "When the certificate was uploaded to Cloudflare."
  uploaded_on: DateTime!
  "Identifier"
  zone_id: common_components_schemas_identifier!
}

"A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it."
enum bundle_method {
  ubiquitous
  optimal
  force
}

"Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance."
type geo_restrictions {
  label: query_custom_ssl_for_a_zone_list_ssl_configurations_oneOf_0_allOf_1_result_items_geo_restrictions_label
}

enum query_custom_ssl_for_a_zone_list_ssl_configurations_oneOf_0_allOf_1_result_items_geo_restrictions_label {
  us
  eu
  highest_security
}

"The valid hosts for the certificates."
scalar query_custom_ssl_for_a_zone_list_ssl_configurations_oneOf_0_allOf_1_result_items_hosts_items @length(min: null, max: 253)

"Custom certificate identifier tag."
scalar custom_certificate_components_schemas_identifier @length(min: null, max: 36)

type keyless_certificate {
  "When the Keyless SSL was created."
  created_on: DateTime!
  "Whether or not the Keyless SSL is on or off."
  enabled: Boolean!
  "The keyless SSL name."
  host: Hostname!
  "Keyless certificate identifier tag."
  id: keyless_certificate_components_schemas_identifier!
  "When the Keyless SSL was last modified."
  modified_on: DateTime!
  "The keyless SSL name."
  name: keyless_certificate_components_schemas_name!
  "Available permissions for the Keyless SSL for the current user requesting the item."
  permissions: [JSON]!
  "The keyless SSL port used to commmunicate between Cloudflare and the client's Keyless SSL server."
  port: Float!
  status: keyless_certificate_components_schemas_status!
}

"Keyless certificate identifier tag."
scalar keyless_certificate_components_schemas_identifier @length(min: null, max: 32)

"The keyless SSL name."
scalar keyless_certificate_components_schemas_name @length(min: null, max: 180)

"Status of the Keyless SSL."
enum keyless_certificate_components_schemas_status {
  active
  deleted
}

"Status of the zone's custom SSL."
enum custom_certificate_components_schemas_status {
  active
  expired
  deleted
  pending
  initializing
}

type custom_ssl_for_a_zone_list_ssl_configurations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union custom_ssl_for_a_zone_ssl_configuration_details_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_ssl_configuration_details_4xx_response") = certificate_response_single | custom_ssl_for_a_zone_ssl_configuration_details_4xx_response

type certificate_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type custom_ssl_for_a_zone_ssl_configuration_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_hostname_for_a_zone_list_custom_hostnames_response @statusCodeTypeName(statusCode: 200, typeName: "custom_hostname_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_for_a_zone_list_custom_hostnames_4xx_response") = custom_hostname_response_collection | custom_hostname_for_a_zone_list_custom_hostnames_4xx_response

type custom_hostname_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [custom_hostname]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type custom_hostname {
  "This is the time the hostname was created."
  created_at: DateTime
  custom_metadata: custom_metadata
  "a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record."
  custom_origin_server: String
  "A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server."
  custom_origin_sni: String
  "The custom hostname that will point to your hostname via CNAME."
  hostname: hostname!
  "Custom hostname identifier tag."
  id: custom_hostname_components_schemas_identifier!
  ownership_verification: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ownership_verification
  ownership_verification_http: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ownership_verification_http
  ssl: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl!
  status: custom_hostname_components_schemas_status
  "These are errors that were encountered while trying to activate a hostname."
  verification_errors: [JSON]
}

"These are per-hostname (customer) settings."
type custom_metadata {
  "Unique metadata for this hostname."
  key: String
}

"The custom hostname that will point to your hostname via CNAME."
scalar hostname @length(min: null, max: 255)

"Custom hostname identifier tag."
scalar custom_hostname_components_schemas_identifier @length(min: 36, max: 36)

type query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ownership_verification {
  "DNS Name for record."
  name: String
  type: txt_const
  "Content for the record."
  value: String
}

enum txt_const @typescript(type: "\\"txt\\"") @example(value: "\\"txt\\"") {
  txt @enum(value: "\\"txt\\"")
}

type query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ownership_verification_http {
  "Token to be served."
  http_body: String
  "The HTTP URL that will be checked during custom hostname verification and where the customer should host the token."
  http_url: URL
}

type query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl {
  bundle_method: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_bundle_method
  certificate_authority: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_certificate_authority
  "If a custom uploaded certificate is used."
  custom_certificate: String
  "The identifier for the Custom CSR that was used."
  custom_csr_id: String
  "The key for a custom uploaded certificate."
  custom_key: String
  "The time the custom certificate expires on."
  expires_on: DateTime
  "A list of Hostnames on a custom uploaded certificate."
  hosts: [JSON]
  "Custom hostname SSL identifier tag."
  id: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_id
  "The issuer on a custom uploaded certificate."
  issuer: String
  method: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_method
  "The serial number on a custom uploaded certificate."
  serial_number: String
  settings: sslsettings
  "The signature on a custom uploaded certificate."
  signature: String
  status: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_status
  type: dv_const
  "The time the custom certificate was uploaded."
  uploaded_on: DateTime
  "Domain validation errors that have been received by the certificate authority (CA)."
  validation_errors: [query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_validation_errors_items]
  validation_records: [validation_record]
  "Indicates whether the certificate covers a wildcard."
  wildcard: Boolean
}

"A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_bundle_method {
  ubiquitous
  optimal
  force
}

"The Certificate Authority that has issued this certificate."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_certificate_authority {
  digicert
  google
  lets_encrypt
}

"Custom hostname SSL identifier tag."
scalar query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_id @length(min: 36, max: 36)

"Domain control validation (DCV) method used for this hostname."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_method {
  http
  txt
  email
}

"SSL specific settings."
type sslsettings {
  "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
  ciphers: [String]
  early_hints: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_early_hints
  http2: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_http2
  min_tls_version: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_min_tls_version
  tls_1_3: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_tls_1_3
}

"Whether or not Early Hints is enabled."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_early_hints {
  on
  off
}

"Whether or not HTTP2 is enabled."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_http2 {
  on
  off
}

"The minimum TLS version supported."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_min_tls_version {
  _1_0 @enum(value: "\\"1.0\\"")
  _1_1 @enum(value: "\\"1.1\\"")
  _1_2 @enum(value: "\\"1.2\\"")
  _1_3 @enum(value: "\\"1.3\\"")
}

"Whether or not TLS 1.3 is enabled."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_tls_1_3 {
  on
  off
}

"Status of the hostname's SSL certificates."
enum query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_status {
  initializing
  pending_validation
  deleted
  pending_issuance
  pending_deployment
  pending_deletion
  pending_expiration
  expired
  active
  initializing_timed_out
  validation_timed_out
  issuance_timed_out
  deployment_timed_out
  deletion_timed_out
  pending_cleanup
  staging_deployment
  staging_active
  deactivating
  inactive
  backup_issued
  holding_deployment
}

enum dv_const @typescript(type: "\\"dv\\"") @example(value: "\\"dv\\"") {
  dv @enum(value: "\\"dv\\"")
}

type query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_validation_errors_items {
  "A domain validation error."
  message: String
}

"Certificate's required validation record."
type validation_record {
  "The set of email addresses that the certificate authority (CA) will use to complete domain validation."
  emails: [JSON]
  "The content that the certificate authority (CA) will expect to find at the http_url during the domain validation."
  http_body: String
  "The url that will be checked during domain validation."
  http_url: URL
  "The hostname that the certificate authority (CA) will check for a TXT record during domain validation ."
  txt_name: String
  "The TXT record that the certificate authority (CA) will check during domain validation."
  txt_value: String
}

"Status of the hostname's activation."
enum custom_hostname_components_schemas_status {
  active
  pending
  active_redeploying
  moved
  pending_deletion
  deleted
  pending_blocked
  pending_migration
  pending_provisioned
  test_pending
  test_active
  test_active_apex
  test_blocked
  test_failed
  provisioned
  blocked
}

type custom_hostname_for_a_zone_list_custom_hostnames_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_origin_response") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames_4xx_response") = fallback_origin_response | custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames_4xx_response

type fallback_origin_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type custom_hostname_fallback_origin_for_a_zone_get_fallback_origin_for_custom_hostnames_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_hostname_for_a_zone_custom_hostname_details_response @statusCodeTypeName(statusCode: 200, typeName: "custom_hostname_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_for_a_zone_custom_hostname_details_4xx_response") = custom_hostname_response_single | custom_hostname_for_a_zone_custom_hostname_details_4xx_response

type custom_hostname_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type custom_hostname_for_a_zone_custom_hostname_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata_response @statusCodeTypeName(statusCode: 200, typeName: "get_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata_4xx_response") = get_response | account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata_4xx_response

type get_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
  "Whether zone uses account-level custom nameservers."
  enabled: Boolean
}

type account_level_custom_nameservers_usage_for_a_zone_get_account_custom_nameserver_related_zone_metadata_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
  "Whether zone uses account-level custom nameservers."
  enabled: Boolean
}

union custom_pages_for_a_zone_list_custom_pages_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_a_zone_list_custom_pages_4xx_response") = custom_pages_response_collection | custom_pages_for_a_zone_list_custom_pages_4xx_response

type custom_pages_for_a_zone_list_custom_pages_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union custom_pages_for_a_zone_get_a_custom_page_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_a_zone_get_a_custom_page_4xx_response") = custom_pages_response_single | custom_pages_for_a_zone_get_a_custom_page_4xx_response

type custom_pages_for_a_zone_get_a_custom_page_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"The name of the custom page type."
enum custom_pages_components_schemas_identifier {
  basic_challenge
  managed_challenge
  waf_block
  ratelimit_block
  country_challenge
  ip_block
  under_attack
  _500_errors @enum(value: "\\"500_errors\\"")
  _1000_errors @enum(value: "\\"1000_errors\\"")
}

union dns_records_for_a_zone_list_dns_records_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_list_dns_records_4xx_response") = dns_response_collection | dns_records_for_a_zone_list_dns_records_4xx_response

type dns_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [dns_record]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union dns_record = A_Record | AAAA_Record | CNAME_Record | HTTPS_Record | NS_Record | MX_Record | TXT_Record | LOC_Record | SRV_Record | CERT_Record | DNSKEY_Record | DS_Record | NAPTR_Record | SMIMEA_Record | SSHFP_Record | SVCB_Record | TLSA_Record | URI_Record

type A_Record {
  "A valid IPv4 address."
  content: IPv4
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: A_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"DNS record identifier tag."
scalar dns_record_components_schemas_identifier @length(min: null, max: 32)

"Extra Cloudflare-specific information about the record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta {
  "Will exist if Cloudflare automatically added this DNS record during initial setup."
  auto_added: Boolean
  "Where the record originated from."
  source: String
}

"DNS record name (or @ for the zone apex)."
scalar dns_record_components_schemas_name @length(min: null, max: 255)

enum A_const @typescript(type: "\\"A\\"") @example(value: "\\"A\\"") {
  A @enum(value: "\\"A\\"")
}

type AAAA_Record {
  "A valid IPv6 address."
  content: IPv6
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: AAAA_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

enum AAAA_const @typescript(type: "\\"AAAA\\"") @example(value: "\\"AAAA\\"") {
  AAAA @enum(value: "\\"AAAA\\"")
}

type CNAME_Record {
  "A valid hostname."
  content: JSON
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: CNAME_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

enum CNAME_const @typescript(type: "\\"CNAME\\"") @example(value: "\\"CNAME\\"") {
  CNAME @enum(value: "\\"CNAME\\"")
}

type HTTPS_Record {
  "Formatted HTTPS content. See 'data' to set HTTPS properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_3_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: HTTPS_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a HTTPS record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_3_allOf_1_data {
  "priority."
  priority: NonNegativeFloat
  "target."
  target: String
  "value."
  value: String
}

enum HTTPS_const @typescript(type: "\\"HTTPS\\"") @example(value: "\\"HTTPS\\"") {
  HTTPS @enum(value: "\\"HTTPS\\"")
}

type NS_Record {
  "A valid name server host name."
  content: String
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: NS_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

enum NS_const @typescript(type: "\\"NS\\"") @example(value: "\\"NS\\"") {
  NS @enum(value: "\\"NS\\"")
}

type MX_Record {
  "A valid mail server hostname."
  content: Hostname
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: MX_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
  "Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred."
  priority: NonNegativeFloat
}

enum MX_const @typescript(type: "\\"MX\\"") @example(value: "\\"MX\\"") {
  MX @enum(value: "\\"MX\\"")
}

type TXT_Record {
  "Text content for the record."
  content: String
  "When the record was created."
  created_on: DateTime
  "Metadata about the record."
  data: JSON
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: TXT_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

enum TXT_const @typescript(type: "\\"TXT\\"") @example(value: "\\"TXT\\"") {
  TXT @enum(value: "\\"TXT\\"")
}

type LOC_Record {
  "Formatted LOC content. See 'data' to set LOC properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: LOC_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a LOC record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data {
  "Altitude of location in meters."
  altitude: Float
  "Degrees of latitude."
  lat_degrees: NonNegativeFloat
  lat_direction: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data_lat_direction
  "Minutes of latitude."
  lat_minutes: NonNegativeFloat
  "Seconds of latitude."
  lat_seconds: NonNegativeFloat
  "Degrees of longitude."
  long_degrees: NonNegativeFloat
  long_direction: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data_long_direction
  "Minutes of longitude."
  long_minutes: NonNegativeFloat
  "Seconds of longitude."
  long_seconds: NonNegativeFloat
  "Horizontal precision of location."
  precision_horz: NonNegativeFloat
  "Vertical precision of location."
  precision_vert: NonNegativeFloat
  "Size of location in meters."
  size: NonNegativeFloat
}

"Latitude direction."
enum query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data_lat_direction {
  N
  S
}

"Longitude direction."
enum query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_7_allOf_1_data_long_direction {
  E
  W
}

enum LOC_const @typescript(type: "\\"LOC\\"") @example(value: "\\"LOC\\"") {
  LOC @enum(value: "\\"LOC\\"")
}

type SRV_Record {
  "Priority, weight, port, and SRV target. See 'data' for setting the individual component values."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_8_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "Service, protocol, and SRV name content. See 'data' for setting the individual component values."
  name: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_8_allOf_1_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: SRV_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a SRV record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_8_allOf_1_data {
  "A valid hostname."
  name: Hostname
  "The port of the service."
  port: NonNegativeFloat
  "Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred."
  priority: NonNegativeFloat
  "A valid protocol."
  proto: String
  "A service type, prefixed with an underscore."
  service: String
  "A valid hostname."
  target: Hostname
  "The record weight."
  weight: NonNegativeFloat
}

"Service, protocol, and SRV name content. See 'data' for setting the individual component values."
scalar query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_8_allOf_1_name @length(min: null, max: 255)

enum SRV_const @typescript(type: "\\"SRV\\"") @example(value: "\\"SRV\\"") {
  SRV @enum(value: "\\"SRV\\"")
}

type CERT_Record {
  "Formatted CERT content. See 'data' to set CERT properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_9_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: CERT_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a CERT record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_9_allOf_1_data {
  "Algorithm."
  algorithm: NonNegativeFloat
  "Certificate."
  certificate: String
  "Key Tag."
  key_tag: NonNegativeFloat
  "Type."
  type: NonNegativeFloat
}

enum CERT_const @typescript(type: "\\"CERT\\"") @example(value: "\\"CERT\\"") {
  CERT @enum(value: "\\"CERT\\"")
}

type DNSKEY_Record {
  "Formatted DNSKEY content. See 'data' to set DNSKEY properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_10_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: DNSKEY_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a DNSKEY record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_10_allOf_1_data {
  "Algorithm."
  algorithm: NonNegativeFloat
  "Flags."
  flags: NonNegativeFloat
  "Protocol."
  protocol: NonNegativeFloat
  "Public Key."
  public_key: String
}

enum DNSKEY_const @typescript(type: "\\"DNSKEY\\"") @example(value: "\\"DNSKEY\\"") {
  DNSKEY @enum(value: "\\"DNSKEY\\"")
}

type DS_Record {
  "Formatted DS content. See 'data' to set DS properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_11_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: DS_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a DS record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_11_allOf_1_data {
  "Algorithm."
  algorithm: NonNegativeFloat
  "Digest."
  digest: String
  "Digest Type."
  digest_type: NonNegativeFloat
  "Key Tag."
  key_tag: NonNegativeFloat
}

enum DS_const @typescript(type: "\\"DS\\"") @example(value: "\\"DS\\"") {
  DS @enum(value: "\\"DS\\"")
}

type NAPTR_Record {
  "Formatted NAPTR content. See 'data' to set NAPTR properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_12_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: NAPTR_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a NAPTR record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_12_allOf_1_data {
  "Flags."
  flags: String
  "Order."
  order: NonNegativeFloat
  "Preference."
  preference: NonNegativeFloat
  "Regex."
  regex: String
  "Replacement."
  replacement: String
  "Service."
  service: String
}

enum NAPTR_const @typescript(type: "\\"NAPTR\\"") @example(value: "\\"NAPTR\\"") {
  NAPTR @enum(value: "\\"NAPTR\\"")
}

type SMIMEA_Record {
  "Formatted SMIMEA content. See 'data' to set SMIMEA properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_13_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: SMIMEA_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a SMIMEA record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_13_allOf_1_data {
  "Certificate."
  certificate: String
  "Matching Type."
  matching_type: NonNegativeFloat
  "Selector."
  selector: NonNegativeFloat
  "Usage."
  usage: NonNegativeFloat
}

enum SMIMEA_const @typescript(type: "\\"SMIMEA\\"") @example(value: "\\"SMIMEA\\"") {
  SMIMEA @enum(value: "\\"SMIMEA\\"")
}

type SSHFP_Record {
  "Formatted SSHFP content. See 'data' to set SSHFP properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_14_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: SSHFP_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a SSHFP record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_14_allOf_1_data {
  "algorithm."
  algorithm: NonNegativeFloat
  "fingerprint."
  fingerprint: String
  "type."
  type: NonNegativeFloat
}

enum SSHFP_const @typescript(type: "\\"SSHFP\\"") @example(value: "\\"SSHFP\\"") {
  SSHFP @enum(value: "\\"SSHFP\\"")
}

type SVCB_Record {
  "Formatted SVCB content. See 'data' to set SVCB properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_15_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: SVCB_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a SVCB record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_15_allOf_1_data {
  "priority."
  priority: NonNegativeFloat
  "target."
  target: String
  "value."
  value: String
}

enum SVCB_const @typescript(type: "\\"SVCB\\"") @example(value: "\\"SVCB\\"") {
  SVCB @enum(value: "\\"SVCB\\"")
}

type TLSA_Record {
  "Formatted TLSA content. See 'data' to set TLSA properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_16_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: TLSA_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
}

"Components of a TLSA record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_16_allOf_1_data {
  "certificate."
  certificate: String
  "Matching Type."
  matching_type: NonNegativeFloat
  "Selector."
  selector: NonNegativeFloat
  "Usage."
  usage: NonNegativeFloat
}

enum TLSA_const @typescript(type: "\\"TLSA\\"") @example(value: "\\"TLSA\\"") {
  TLSA @enum(value: "\\"TLSA\\"")
}

type URI_Record {
  "Formatted URI content. See 'data' to set URI properties."
  content: String
  "When the record was created."
  created_on: DateTime
  data: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_17_allOf_1_data
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
  "Whether this record can be modified/deleted (true means it's managed by Cloudflare)."
  locked: Boolean
  meta: query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_meta
  "When the record was last modified."
  modified_on: DateTime
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record can be proxied by Cloudflare or not."
  proxiable: Boolean
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: URI_const
  "Identifier"
  zone_id: common_components_schemas_identifier!
  "The domain of the record."
  zone_name: Hostname
  "Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred."
  priority: NonNegativeFloat
}

"Components of a URI record."
type query_dns_records_for_a_zone_list_dns_records_oneOf_0_allOf_1_result_items_oneOf_17_allOf_1_data {
  "The record content."
  content: URL
  "The record weight."
  weight: NonNegativeFloat
}

enum URI_const @typescript(type: "\\"URI\\"") @example(value: "\\"URI\\"") {
  URI @enum(value: "\\"URI\\"")
}

type dns_records_for_a_zone_list_dns_records_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type dns_records_for_a_zone_export_dns_records_4xx_response {
  JSON: JSON @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_records_for_a_zone_dns_record_details_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_dns_record_details_4xx_response") = dns_response_single | dns_records_for_a_zone_dns_record_details_4xx_response

type dns_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type dns_records_for_a_zone_dns_record_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dnssec_dnssec_details_response @statusCodeTypeName(statusCode: 200, typeName: "dnssec_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dnssec_dnssec_details_4xx_response") = dnssec_response_single | dnssec_dnssec_details_4xx_response

type dnssec_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type dnssec_dnssec_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_settings_get_email_routing_settings_response @statusCodeTypeName(statusCode: 200, typeName: "email_settings_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_settings_get_email_routing_settings_4xx_response") = email_settings_response_single | email_routing_settings_get_email_routing_settings_4xx_response

type email_settings_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type email_routing_settings_get_email_routing_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_settings_email_routing_dns_settings_response @statusCodeTypeName(statusCode: 200, typeName: "dns_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_settings_email_routing_dns_settings_4xx_response") = dns_settings_response_collection | email_routing_settings_email_routing_dns_settings_4xx_response

type dns_settings_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_dns_record]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

"List of records needed to enable an Email Routing zone."
type schemas_dns_record {
  "DNS record content."
  content: String
  "DNS record name (or @ for the zone apex)."
  name: query_email_routing_settings_email_routing_dns_settings_oneOf_0_allOf_1_result_items_name
  "Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred."
  priority: NonNegativeFloat
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: query_email_routing_settings_email_routing_dns_settings_oneOf_0_allOf_1_result_items_type
}

"DNS record name (or @ for the zone apex)."
scalar query_email_routing_settings_email_routing_dns_settings_oneOf_0_allOf_1_result_items_name @length(min: null, max: 255)

"DNS record type."
enum query_email_routing_settings_email_routing_dns_settings_oneOf_0_allOf_1_result_items_type {
  A
  AAAA
  CNAME
  HTTPS
  TXT
  SRV
  LOC
  MX
  NS
  CERT
  DNSKEY
  DS
  NAPTR
  SMIMEA
  SSHFP
  SVCB
  TLSA
  URI
}

type email_routing_settings_email_routing_dns_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union email_routing_routing_rules_list_routing_rules_response @statusCodeTypeName(statusCode: 200, typeName: "rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_list_routing_rules_4xx_response") = rules_response_collection | email_routing_routing_rules_list_routing_rules_4xx_response

type rules_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [rules]
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_info
}

type rules {
  "List actions patterns."
  actions: [schemas_action]
  "Routing rule status."
  enabled: Boolean
  "Matching patterns to forward to your actions."
  matchers: [matcher]
  "Routing rule name."
  name: rules_components_schemas_name
  "Priority of the routing rule."
  priority: NonNegativeFloat
  "Routing rule identifier."
  tag: rule_identifier!
}

"Actions pattern."
type schemas_action {
  type: query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_items_allOf_0_actions_items_type!
  value: [EmailAddress]!
}

"Type of supported action."
enum query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_items_allOf_0_actions_items_type {
  forward
  worker
}

"Matching pattern to forward your actions."
type matcher {
  field: to_const!
  type: literal_const!
  "Value for matcher."
  value: EmailAddress!
}

enum to_const @typescript(type: "\\"to\\"") @example(value: "\\"to\\"") {
  to @enum(value: "\\"to\\"")
}

enum literal_const @typescript(type: "\\"literal\\"") @example(value: "\\"literal\\"") {
  literal @enum(value: "\\"literal\\"")
}

"Routing rule name."
scalar rules_components_schemas_name @length(min: null, max: 256)

"Routing rule identifier."
scalar rule_identifier @length(min: null, max: 32)

type query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_info {
  count: Int
  page: Int
  per_page: Int
  total_count: Int
}

type email_routing_routing_rules_list_routing_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_info
}

union email_routing_routing_rules_get_catch_all_rule_response @statusCodeTypeName(statusCode: 200, typeName: "catch_all_rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_get_catch_all_rule_4xx_response") = catch_all_rule_response_single | email_routing_routing_rules_get_catch_all_rule_4xx_response

type catch_all_rule_response_single {
  "List actions for the catch-all routing rule."
  actions: [catchall_action]
  "Routing rule status."
  enabled: Boolean
  "List of matchers for the catch-all routing rule."
  matchers: [catchall_matcher]
  "Routing rule name."
  name: rules_components_schemas_name
  "Routing rule identifier."
  tag: rule_identifier!
}

"Action for the catch-all routing rule."
type catchall_action {
  type: query_email_routing_routing_rules_get_catch_all_rule_oneOf_0_actions_items_type!
  value: [EmailAddress]
}

"Type of action for catch-all rule."
enum query_email_routing_routing_rules_get_catch_all_rule_oneOf_0_actions_items_type {
  drop
  forward
  worker
}

"Matcher for catch-all routing rule."
type catchall_matcher {
  type: all_const!
}

enum all_const @typescript(type: "\\"all\\"") @example(value: "\\"all\\"") {
  all @enum(value: "\\"all\\"")
}

type email_routing_routing_rules_get_catch_all_rule_4xx_response {
  "List actions for the catch-all routing rule."
  actions: [catchall_action]
  "Routing rule status."
  enabled: Boolean
  "List of matchers for the catch-all routing rule."
  matchers: [catchall_matcher]
  "Routing rule name."
  name: rules_components_schemas_name
  "Routing rule identifier."
  tag: rule_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_routing_rules_get_routing_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_get_routing_rule_4xx_response") = rule_response_single | email_routing_routing_rules_get_routing_rule_4xx_response

type rule_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type email_routing_routing_rules_get_routing_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union filters_list_filters_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_filter_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_list_filters_4xx_response") = schemas_filter_response_collection | filters_list_filters_4xx_response

type schemas_filter_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_filters_list_filters_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_filters_list_filters_oneOf_0_allOf_1_result_items {
  "An informative summary of the filter."
  description: filters_components_schemas_description
  "The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/)."
  expression: String
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
  "When true, indicates that the filter is currently paused."
  paused: Boolean
  "A short reference tag. Allows you to select related filters."
  ref: schemas_ref
  JSON: JSON @resolveRoot
}

"An informative summary of the filter."
scalar filters_components_schemas_description @length(min: null, max: 500)

"The unique identifier of the filter."
scalar filters_components_schemas_id @length(min: 32, max: 32)

"A short reference tag. Allows you to select related filters."
scalar schemas_ref @length(min: null, max: 50)

type filters_list_filters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union filters_get_a_filter_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_filter_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_get_a_filter_4xx_response") = schemas_filter_response_single | filters_get_a_filter_4xx_response

type schemas_filter_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_filters_get_a_filter_oneOf_0_allOf_1_result!
  "Whether the API call was successful"
  success: Boolean!
}

union query_filters_get_a_filter_oneOf_0_allOf_1_result = query_filters_get_a_filter_oneOf_0_allOf_1_result_oneOf_0 | JSON_container

type query_filters_get_a_filter_oneOf_0_allOf_1_result_oneOf_0 {
  "An informative summary of the filter."
  description: filters_components_schemas_description
  "The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/)."
  expression: String
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
  "When true, indicates that the filter is currently paused."
  paused: Boolean
  "A short reference tag. Allows you to select related filters."
  ref: schemas_ref
  JSON: JSON @resolveRoot
}

type JSON_container {
  JSON: JSON
}

type filters_get_a_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_lockdown_list_zone_lockdown_rules_response @statusCodeTypeName(statusCode: 200, typeName: "zonelockdown_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_lockdown_list_zone_lockdown_rules_4xx_response") = zonelockdown_response_collection | zone_lockdown_list_zone_lockdown_rules_4xx_response

type zonelockdown_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [zonelockdown]!
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type zonelockdown {
  "A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of \`ip\` or \`ip_range\` configurations."
  configurations: [query_zone_lockdown_list_zone_lockdown_rules_oneOf_0_allOf_1_result_items_configurations_items]!
  "The timestamp of when the rule was created."
  created_on: DateTime!
  "An informative summary of the rule."
  description: lockdowns_components_schemas_description!
  "The unique identifier of the Zone Lockdown rule."
  id: lockdowns_components_schemas_id!
  "The timestamp of when the rule was last modified."
  modified_on: DateTime!
  "When true, indicates that the rule is currently paused."
  paused: Boolean!
  "The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns."
  urls: [String]!
}

type query_zone_lockdown_list_zone_lockdown_rules_oneOf_0_allOf_1_result_items_configurations_items {
  target: JSON
  "The IP address range to match. You can only use prefix lengths \`/16\` and \`/24\`."
  value: String
}

"An informative summary of the rule."
scalar lockdowns_components_schemas_description @length(min: null, max: 1024)

"The unique identifier of the Zone Lockdown rule."
scalar lockdowns_components_schemas_id @length(min: null, max: 32)

type zone_lockdown_list_zone_lockdown_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_lockdown_get_a_zone_lockdown_rule_response @statusCodeTypeName(statusCode: 200, typeName: "zonelockdown_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_lockdown_get_a_zone_lockdown_rule_4xx_response") = zonelockdown_response_single | zone_lockdown_get_a_zone_lockdown_rule_4xx_response

type zonelockdown_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: zonelockdown!
  "Whether the API call was successful"
  success: Boolean!
}

type zone_lockdown_get_a_zone_lockdown_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union firewall_rules_list_firewall_rules_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_list_firewall_rules_4xx_response") = filter_rules_response_collection | firewall_rules_list_firewall_rules_4xx_response

type filter_rules_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items]!
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items {
  action: firewall_rules_components_schemas_action
  "An informative summary of the firewall rule."
  description: firewall_rules_components_schemas_description
  "The unique identifier of the firewall rule."
  id: firewall_rules_components_schemas_id!
  "When true, indicates that the firewall rule is currently paused."
  paused: Boolean
  "The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority."
  priority: NonNegativeFloat
  products: [query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_products_items]
  "A short reference tag. Allows you to select related firewall rules."
  ref: ref
  filter: query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_filter
  JSON: JSON @resolveRoot
}

"The action to apply to a matched request. The \`log\` action is only available on an Enterprise plan."
enum firewall_rules_components_schemas_action {
  block
  challenge
  js_challenge
  managed_challenge
  allow
  log
  bypass
}

"An informative summary of the firewall rule."
scalar firewall_rules_components_schemas_description @length(min: null, max: 500)

"The unique identifier of the firewall rule."
scalar firewall_rules_components_schemas_id @length(min: null, max: 32)

"A list of products to bypass for a request when using the \`bypass\` action."
enum query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_products_items {
  zoneLockdown
  uaBlock
  bic
  hot
  securityLevel
  rateLimit
  waf
}

"A short reference tag. Allows you to select related firewall rules."
scalar ref @length(min: null, max: 50)

union query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_filter = filter | deleted_filter

type filter {
  "An informative summary of the filter."
  description: filters_components_schemas_description
  "The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/)."
  expression: String
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
  "When true, indicates that the filter is currently paused."
  paused: Boolean
  "A short reference tag. Allows you to select related filters."
  ref: schemas_ref
}

type deleted_filter {
  "When true, indicates that the firewall rule was deleted."
  deleted: Boolean!
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
}

type firewall_rules_list_firewall_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union firewall_rules_get_a_firewall_rule_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_get_a_firewall_rule_4xx_response") = filter_rules_single_response | firewall_rules_get_a_firewall_rule_4xx_response

type filter_rules_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_firewall_rules_get_a_firewall_rule_oneOf_0_allOf_1_result!
  "Whether the API call was successful"
  success: Boolean!
}

type query_firewall_rules_get_a_firewall_rule_oneOf_0_allOf_1_result {
  action: firewall_rules_components_schemas_action
  "An informative summary of the firewall rule."
  description: firewall_rules_components_schemas_description
  "The unique identifier of the firewall rule."
  id: firewall_rules_components_schemas_id!
  "When true, indicates that the firewall rule is currently paused."
  paused: Boolean
  "The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority."
  priority: NonNegativeFloat
  products: [query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_products_items]
  "A short reference tag. Allows you to select related firewall rules."
  ref: ref
  filter: query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_filter
  JSON: JSON @resolveRoot
}

type firewall_rules_get_a_firewall_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_agent_blocking_rules_list_user_agent_blocking_rules_response @statusCodeTypeName(statusCode: 200, typeName: "firewalluablock_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "user_agent_blocking_rules_list_user_agent_blocking_rules_4xx_response") = firewalluablock_response_collection | user_agent_blocking_rules_list_user_agent_blocking_rules_4xx_response

type firewalluablock_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [ua_rules]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type ua_rules {
  configuration: components_schemas_configuration
  "An informative summary of the rule."
  description: ua_rules_components_schemas_description
  "The unique identifier of the User Agent Blocking rule."
  id: ua_rules_components_schemas_id!
  mode: ua_rules_components_schemas_mode
  "When true, indicates that the rule is currently paused."
  paused: Boolean
}

"The configuration object for the current rule."
type components_schemas_configuration {
  "The configuration target for this rule. You must set the target to \`ua\` for User Agent Blocking rules."
  target: String
  "The exact user agent string to match. This value will be compared to the received \`User-Agent\` HTTP header value."
  value: String
}

"An informative summary of the rule."
scalar ua_rules_components_schemas_description @length(min: null, max: 1024)

"The unique identifier of the User Agent Blocking rule."
scalar ua_rules_components_schemas_id @length(min: null, max: 32)

"The action to apply to a matched request."
enum ua_rules_components_schemas_mode {
  block
  challenge
  js_challenge
  managed_challenge
}

type user_agent_blocking_rules_list_user_agent_blocking_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union user_agent_blocking_rules_get_a_user_agent_blocking_rule_response @statusCodeTypeName(statusCode: 200, typeName: "firewalluablock_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_agent_blocking_rules_get_a_user_agent_blocking_rule_4xx_response") = firewalluablock_response_single | user_agent_blocking_rules_get_a_user_agent_blocking_rule_4xx_response

type firewalluablock_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type user_agent_blocking_rules_get_a_user_agent_blocking_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waf_overrides_list_waf_overrides_response @statusCodeTypeName(statusCode: 200, typeName: "override_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_overrides_list_waf_overrides_4xx_response") = override_response_collection | waf_overrides_list_waf_overrides_4xx_response

type override_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [query_waf_overrides_list_waf_overrides_oneOf_0_allOf_1_result_items]!
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_waf_overrides_list_waf_overrides_oneOf_0_allOf_1_result_items {
  "An informative summary of the current URI-based WAF override."
  description: overrides_components_schemas_description
  groups: groups
  "The unique identifier of the WAF override."
  id: overrides_components_schemas_id!
  "When true, indicates that the WAF package is currently paused."
  paused: Boolean
  "The relative priority of the current URI-based WAF override when multiple overrides match a single URL. A lower number indicates higher priority. Higher priority overrides may overwrite values set by lower priority overrides."
  priority: Float
  rewrite_action: rewrite_action
  rules: schemas_rules
  "The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns."
  urls: [String]
  JSON: JSON @resolveRoot
}

"An informative summary of the current URI-based WAF override."
scalar overrides_components_schemas_description @length(min: null, max: 1024)

"An object that allows you to enable or disable WAF rule groups for the current WAF override. Each key of this object must be the ID of a WAF rule group, and each value must be a valid WAF action (usually \`default\` or \`disable\`). When creating a new URI-based WAF override, you must provide a \`groups\` object or a \`rules\` object."
type groups {
  ea8687e59929c1fd05ba97574ad43f77: String
  additionalProperties: JSON @resolveRoot
}

"The unique identifier of the WAF override."
scalar overrides_components_schemas_id @length(min: null, max: 32)

"Specifies that, when a WAF rule matches, its configured action will be replaced by the action configured in this object."
type rewrite_action {
  block: waf_rewrite_action
  challenge: String
  default: String
  disable: waf_rewrite_action
  simulate: String
}

"The WAF rule action to apply."
enum waf_rewrite_action {
  challenge
  block
  simulate
  disable
  default
}

"An object that allows you to override the action of specific WAF rules. Each key of this object must be the ID of a WAF rule, and each value must be a valid WAF action. Unless you are disabling a rule, ensure that you also enable the rule group that this WAF rule belongs to. When creating a new URI-based WAF override, you must provide a \`groups\` object or a \`rules\` object."
type schemas_rules {
  _100015: String @resolveRootField(field: "100015")
  additionalProperties: JSON @resolveRoot
}

type waf_overrides_list_waf_overrides_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waf_overrides_get_a_waf_override_response @statusCodeTypeName(statusCode: 200, typeName: "override_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_overrides_get_a_waf_override_4xx_response") = override_response_single | waf_overrides_get_a_waf_override_4xx_response

type override_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: override!
  "Whether the API call was successful"
  success: Boolean!
}

type override {
  "An informative summary of the current URI-based WAF override."
  description: overrides_components_schemas_description
  groups: groups
  "The unique identifier of the WAF override."
  id: overrides_components_schemas_id!
  "When true, indicates that the WAF package is currently paused."
  paused: Boolean
  "The relative priority of the current URI-based WAF override when multiple overrides match a single URL. A lower number indicates higher priority. Higher priority overrides may overwrite values set by lower priority overrides."
  priority: Float
  rewrite_action: rewrite_action
  rules: schemas_rules
  "The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns."
  urls: [String]
}

type waf_overrides_get_a_waf_override_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waf_packages_list_waf_packages_response @statusCodeTypeName(statusCode: 200, typeName: "package_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_packages_list_waf_packages_4xx_response") = package_response_collection | waf_packages_list_waf_packages_4xx_response

type package_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [package]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union package = Traditional_WAF_package | Anomaly_detection_WAF_package_OWASP

type Traditional_WAF_package {
  "A summary of the purpose/function of the WAF package."
  description: String!
  detection_mode: detection_mode!
  "The unique identifier of a WAF package."
  id: package_components_schemas_identifier!
  "The name of the WAF package."
  name: String!
  status: package_components_schemas_status
  "Identifier"
  zone_id: common_components_schemas_identifier!
}

"The mode that defines how rules within the package are evaluated during the course of a request. When a package uses anomaly detection mode (\`anomaly\` value), each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined in the WAF package, the action configured in the package will be performed. Traditional detection mode (\`traditional\` value) will decide the action to take when it is triggered by the request. If multiple rules are triggered, the action providing the highest protection will be applied (for example, a 'block' action will win over a 'challenge' action)."
enum detection_mode {
  anomaly
  traditional
}

"The unique identifier of a WAF package."
scalar package_components_schemas_identifier @length(min: null, max: 32)

enum package_components_schemas_status @typescript(type: "\\"active\\"") @example(value: "\\"active\\"") {
  active @enum(value: "\\"active\\"")
}

type Anomaly_detection_WAF_package_OWASP {
  "A summary of the purpose/function of the WAF package."
  description: String
  "When a WAF package uses anomaly detection, each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined on the WAF package, the action defined on the package will be taken."
  detection_mode: String
  "The unique identifier of a WAF package."
  id: package_components_schemas_identifier!
  "The name of the WAF package."
  name: String
  status: package_components_schemas_status
  "Identifier"
  zone_id: common_components_schemas_identifier!
  action_mode: action_mode
  sensitivity: sensitivity
}

"The default action performed by the rules in the WAF package."
enum action_mode {
  simulate
  block
  challenge
}

"The sensitivity of the WAF package."
enum sensitivity {
  high
  medium
  low
  off
}

type waf_packages_list_waf_packages_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waf_packages_get_a_waf_package_response @statusCodeTypeName(statusCode: "4xx", typeName: "waf_packages_get_a_waf_package_4xx_response") = api_response_single | query_waf_packages_get_a_waf_package_oneOf_0_oneOf_1 | waf_packages_get_a_waf_package_4xx_response

type api_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_waf_packages_get_a_waf_package_oneOf_0_oneOf_1 {
  result: JSON
}

type waf_packages_get_a_waf_package_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waf_rule_groups_list_waf_rule_groups_response @statusCodeTypeName(statusCode: 200, typeName: "rule_group_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rule_groups_list_waf_rule_groups_4xx_response") = rule_group_response_collection | waf_rule_groups_list_waf_rule_groups_4xx_response

type rule_group_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [schemas_group]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_group {
  "An informative summary of what the rule group does."
  description: String
  "The unique identifier of the rule group."
  id: group_components_schemas_identifier!
  "The number of rules within the group that have been modified from their default configuration."
  modified_rules_count: Float
  "The name of the rule group."
  name: String
  "The unique identifier of a WAF package."
  package_id: package_components_schemas_identifier!
  "The number of rules in the current rule group."
  rules_count: Float
  "The available states for the rule group."
  allowed_modes: [components_schemas_mode]
  mode: components_schemas_mode
}

"The unique identifier of the rule group."
scalar group_components_schemas_identifier @length(min: null, max: 32)

"The state of the rules contained in the rule group. When \`on\`, the rules in the group are configurable/usable."
enum components_schemas_mode {
  on
  off
}

type waf_rule_groups_list_waf_rule_groups_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waf_rule_groups_get_a_waf_rule_group_response @statusCodeTypeName(statusCode: 200, typeName: "rule_group_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rule_groups_get_a_waf_rule_group_4xx_response") = rule_group_response_single | waf_rule_groups_get_a_waf_rule_group_4xx_response

type rule_group_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type waf_rule_groups_get_a_waf_rule_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_list_health_checks_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_list_health_checks_4xx_response") = healthchecks_components_schemas_response_collection | health_checks_list_health_checks_4xx_response

type healthchecks_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [healthchecks]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type healthchecks {
  "The hostname or IP address of the origin server to run health checks on."
  address: String
  "A list of regions from which to run health checks. Null means Cloudflare will pick a default region."
  check_regions: [query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_check_regions_items]
  "The number of consecutive fails required from a health check before changing the health to unhealthy."
  consecutive_fails: Int
  "The number of consecutive successes required from a health check before changing the health to healthy."
  consecutive_successes: Int
  created_on: DateTime
  "A human-readable description of the health check."
  description: String
  "The current failure reason if status is unhealthy."
  failure_reason: String
  http_config: http_config
  id: String!
  "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations."
  interval: Int
  modified_on: DateTime
  "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int
  status: healthchecks_components_schemas_status
  "If suspended, no health checks are sent to the origin."
  suspended: Boolean
  tcp_config: tcp_config
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int
  "The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'."
  type: String
}

"WNAM: Western North America, ENAM: Eastern North America, WEU: Western Europe, EEU: Eastern Europe, NSAM: Northern South America, SSAM: Southern South America, OC: Oceania, ME: Middle East, NAF: North Africa, SAF: South Africa, IN: India, SEAS: South East Asia, NEAS: North East Asia, ALL_REGIONS: all regions (BUSINESS and ENTERPRISE customers only)."
enum query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_check_regions_items {
  WNAM
  ENAM
  WEU
  EEU
  NSAM
  SSAM
  OC
  ME
  NAF
  SAF
  IN
  SEAS
  NEAS
  ALL_REGIONS
}

"Parameters specific to an HTTP or HTTPS health check."
type http_config {
  "Do not validate the certificate when the health check uses HTTPS."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy."
  expected_body: String
  "The expected HTTP response codes (e.g. \\"200\\") or code ranges (e.g. \\"2xx\\" for all codes starting with 2) of the health check."
  expected_codes: [String]
  "Follow redirects if the origin returns a 3xx status code."
  follow_redirects: Boolean
  header: query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_header
  method: query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_method
  "The endpoint path to health check against."
  path: String
  "Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS."
  port: Int
}

"The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden."
type query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_header {
  Host: [String]
  X_App_ID: [String] @resolveRootField(field: "X-App-ID")
}

"The HTTP method to use for the health check."
enum query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_method {
  GET
  HEAD
}

"The current status of the origin server according to the health check."
enum healthchecks_components_schemas_status {
  unknown
  healthy
  unhealthy
  suspended
}

"Parameters specific to TCP health check."
type tcp_config {
  method: connection_established_const
  "Port number to connect to for the health check. Defaults to 80."
  port: Int
}

enum connection_established_const @typescript(type: "\\"connection_established\\"") @example(value: "\\"connection_established\\"") {
  connection_established @enum(value: "\\"connection_established\\"")
}

type health_checks_list_health_checks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union health_checks_health_check_preview_details_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_health_check_preview_details_4xx_response") = healthchecks_components_schemas_single_response | health_checks_health_check_preview_details_4xx_response

type healthchecks_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: healthchecks
  "Whether the API call was successful"
  success: Boolean!
}

type health_checks_health_check_preview_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_health_check_details_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_health_check_details_4xx_response") = healthchecks_components_schemas_single_response | health_checks_health_check_details_4xx_response

type health_checks_health_check_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union keyless_ssl_for_a_zone_list_keyless_ssl_configurations_response @statusCodeTypeName(statusCode: 200, typeName: "keyless_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "keyless_ssl_for_a_zone_list_keyless_ssl_configurations_4xx_response") = keyless_response_collection | keyless_ssl_for_a_zone_list_keyless_ssl_configurations_4xx_response

type keyless_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [keyless_certificate]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type keyless_ssl_for_a_zone_list_keyless_ssl_configurations_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union keyless_ssl_for_a_zone_get_keyless_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keyless_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "keyless_ssl_for_a_zone_get_keyless_ssl_configuration_4xx_response") = keyless_response_single | keyless_ssl_for_a_zone_get_keyless_ssl_configuration_4xx_response

type keyless_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type keyless_ssl_for_a_zone_get_keyless_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logpush_jobs_list_fields_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_field_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_list_fields_4xx_response") = logpush_field_response_collection | logpush_jobs_list_fields_4xx_response

type logpush_field_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_logpush_jobs_list_fields_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_logpush_jobs_list_fields_oneOf_0_allOf_1_result {
  key: String
}

type logpush_jobs_list_fields_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar dataset @regexp(pattern: "^[a-zA-Z0-9_\\\\-]*$") @typescript(type: "string")

union logpush_jobs_list_logpush_jobs_for_a_dataset_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_job_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_list_logpush_jobs_for_a_dataset_4xx_response") = logpush_job_response_collection | logpush_jobs_list_logpush_jobs_for_a_dataset_4xx_response

type logpush_job_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
}

type logpush_jobs_list_logpush_jobs_for_a_dataset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logpush_jobs_list_logpush_jobs_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_job_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_list_logpush_jobs_4xx_response") = logpush_job_response_collection | logpush_jobs_list_logpush_jobs_4xx_response

type logpush_jobs_list_logpush_jobs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logpush_jobs_get_logpush_job_details_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_job_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_get_logpush_job_details_4xx_response") = logpush_job_response_single | logpush_jobs_get_logpush_job_details_4xx_response

type logpush_job_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type logpush_jobs_get_logpush_job_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logs_received_get_log_retention_flag_response @statusCodeTypeName(statusCode: 200, typeName: "flag_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logs_received_get_log_retention_flag_4xx_response") = flag_response | logs_received_get_log_retention_flag_4xx_response

type flag_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_logs_received_get_log_retention_flag_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_logs_received_get_log_retention_flag_oneOf_0_allOf_1_result {
  flag: Boolean
}

type logs_received_get_log_retention_flag_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logs_received_get_logs_ray_i_ds_response @statusCodeTypeName(statusCode: 200, typeName: "String_container") @statusCodeTypeName(statusCode: "4xx", typeName: "logs_received_get_logs_ray_i_ds_4xx_response") = String_container | logs_received_get_logs_ray_i_ds_4xx_response

type logs_received_get_logs_ray_i_ds_4xx_response {
  String: String @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Ray identifier."
scalar ray_identifier @length(min: null, max: 16)

union logs_received_get_logs_received_response @statusCodeTypeName(statusCode: 200, typeName: "String_container") @statusCodeTypeName(statusCode: "4xx", typeName: "logs_received_get_logs_received_4xx_response") = String_container | logs_received_get_logs_received_4xx_response

type logs_received_get_logs_received_4xx_response {
  String: String @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logs_received_list_fields_response @statusCodeTypeName(statusCode: 200, typeName: "fields_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logs_received_list_fields_4xx_response") = fields_response | logs_received_list_fields_4xx_response

type fields_response {
  key: String
}

type logs_received_list_fields_4xx_response {
  key: String
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_authenticated_origin_pulls_list_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_certificate_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_list_certificates_4xx_response") = components_schemas_certificate_response_collection | zone_level_authenticated_origin_pulls_list_certificates_4xx_response

type components_schemas_certificate_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [zone_authenticated_origin_pull]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type zone_authenticated_origin_pull {
  "The zone's leaf certificate."
  certificate: String
  "When the certificate from the authority expires."
  expires_on: DateTime
  "Certificate identifier tag."
  id: zone_authenticated_origin_pull_components_schemas_identifier!
  "The certificate authority that issued the certificate."
  issuer: String
  "The type of hash used for the certificate."
  signature: String
  status: zone_authenticated_origin_pull_components_schemas_status
  "This is the time the certificate was uploaded."
  uploaded_on: DateTime
  "Indicates whether zone-level authenticated origin pulls is enabled."
  enabled: Boolean
  "The zone's private key."
  private_key: String
}

"Certificate identifier tag."
scalar zone_authenticated_origin_pull_components_schemas_identifier @length(min: null, max: 36)

"Status of the certificate activation."
enum zone_authenticated_origin_pull_components_schemas_status {
  initializing
  pending_deployment
  pending_deletion
  active
  deleted
  deployment_timed_out
  deletion_timed_out
}

type zone_level_authenticated_origin_pulls_list_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union per_hostname_authenticated_origin_pull_list_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "hostname_authenticated_origin_pull_components_schemas_certificate_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_list_certificates_4xx_response") = hostname_authenticated_origin_pull_components_schemas_certificate_response_collection | per_hostname_authenticated_origin_pull_list_certificates_4xx_response

type hostname_authenticated_origin_pull_components_schemas_certificate_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [hostname_authenticated_origin_pull]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type hostname_authenticated_origin_pull {
  "Certificate identifier tag."
  cert_id: hostname_authenticated_origin_pull_components_schemas_identifier!
  cert_status: hostname_authenticated_origin_pull_components_schemas_status
  "The time when the certificate was updated."
  cert_updated_at: DateTime
  "The time when the certificate was uploaded."
  cert_uploaded_on: DateTime
  "The hostname certificate."
  certificate: String
  "The time when the certificate was created."
  created_at: DateTime
  "Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association."
  enabled: Boolean
  "The date when the certificate expires."
  expires_on: DateTime
  "The hostname on the origin for which the client certificate uploaded will be used."
  hostname: schemas_hostname!
  "The certificate authority that issued the certificate."
  issuer: String
  "The serial number on the uploaded certificate."
  serial_number: String
  "The type of hash used for the certificate."
  signature: String
  status: hostname_authenticated_origin_pull_components_schemas_status
  "The time when the certificate was updated."
  updated_at: DateTime
  "Certificate identifier tag."
  id: hostname_authenticated_origin_pull_components_schemas_identifier!
  "The hostname certificate's private key."
  private_key: String
}

"Certificate identifier tag."
scalar hostname_authenticated_origin_pull_components_schemas_identifier @length(min: null, max: 36)

"Status of the certificate or the association."
enum hostname_authenticated_origin_pull_components_schemas_status {
  initializing
  pending_deployment
  pending_deletion
  active
  deleted
  deployment_timed_out
  deletion_timed_out
}

"The hostname on the origin for which the client certificate uploaded will be used."
scalar schemas_hostname @length(min: null, max: 255)

type per_hostname_authenticated_origin_pull_list_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate_4xx_response") = components_schemas_certificate_response_single | per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate_4xx_response

type components_schemas_certificate_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_certificateObject
  "Whether the API call was successful"
  success: Boolean!
}

type schemas_certificateObject {
  "The hostname certificate."
  certificate: String
  "The date when the certificate expires."
  expires_on: DateTime
  "Certificate identifier tag."
  id: hostname_authenticated_origin_pull_components_schemas_identifier!
  "The certificate authority that issued the certificate."
  issuer: String
  "The serial number on the uploaded certificate."
  serial_number: String
  "The type of hash used for the certificate."
  signature: String
  status: hostname_authenticated_origin_pull_components_schemas_status
  "The time when the certificate was uploaded."
  uploaded_on: DateTime
}

type per_hostname_authenticated_origin_pull_get_the_hostname_client_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication_response @statusCodeTypeName(statusCode: 200, typeName: "hostname_aop_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication_4xx_response") = hostname_aop_single_response | per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication_4xx_response

type hostname_aop_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: hostname_certid_object
  "Whether the API call was successful"
  success: Boolean!
}

type hostname_certid_object {
  "Certificate identifier tag."
  cert_id: hostname_authenticated_origin_pull_components_schemas_identifier!
  cert_status: hostname_authenticated_origin_pull_components_schemas_status
  "The time when the certificate was updated."
  cert_updated_at: DateTime
  "The time when the certificate was uploaded."
  cert_uploaded_on: DateTime
  "The hostname certificate."
  certificate: String
  "The time when the certificate was created."
  created_at: DateTime
  "Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association."
  enabled: Boolean
  "The date when the certificate expires."
  expires_on: DateTime
  "The hostname on the origin for which the client certificate uploaded will be used."
  hostname: schemas_hostname!
  "The certificate authority that issued the certificate."
  issuer: String
  "The serial number on the uploaded certificate."
  serial_number: String
  "The type of hash used for the certificate."
  signature: String
  status: hostname_authenticated_origin_pull_components_schemas_status
  "The time when the certificate was updated."
  updated_at: DateTime
}

type per_hostname_authenticated_origin_pull_get_the_hostname_status_for_client_authentication_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_response @statusCodeTypeName(statusCode: 200, typeName: "enabled_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_4xx_response") = enabled_response | zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_4xx_response

type enabled_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_oneOf_0_allOf_1_result {
  "Indicates whether zone-level authenticated origin pulls is enabled."
  enabled: Boolean
}

type zone_level_authenticated_origin_pulls_get_enablement_setting_for_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_authenticated_origin_pulls_get_certificate_details_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_get_certificate_details_4xx_response") = certificate_response_single | zone_level_authenticated_origin_pulls_get_certificate_details_4xx_response

type zone_level_authenticated_origin_pulls_get_certificate_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_rules_list_page_rules_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_list_page_rules_4xx_response") = pagerule_response_collection | page_rules_list_page_rules_4xx_response

type pagerule_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [page_rule]
  "Whether the API call was successful"
  success: Boolean!
}

type page_rule {
  "The set of actions to perform if the targets of this rule match the request. Actions can redirect to another URL or override settings, but not both."
  actions: [route]!
  "The timestamp of when the Page Rule was created."
  created_on: DateTime!
  "Identifier"
  id: common_components_schemas_identifier!
  "The timestamp of when the Page Rule was last modified."
  modified_on: DateTime!
  "The priority of the rule, used to define which Page Rule is processed over another. A higher number indicates a higher priority. For example, if you have a catch-all Page Rule (rule A: \`/images/*\`) but want a more specific Page Rule to take precedence (rule B: \`/images/special/*\`), specify a higher priority for rule B so it overrides rule A."
  priority: Int!
  status: page_rule_components_schemas_status!
  "The rule targets to evaluate on each request."
  targets: [url_target]!
}

type route {
  "The timestamp of when the override was last modified."
  modified_on: DateTime
  name: forward_url_const
  value: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value
}

enum forward_url_const @typescript(type: "\\"forward_url\\"") @example(value: "\\"forward_url\\"") {
  forward_url @enum(value: "\\"forward_url\\"")
}

type query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value {
  type: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value_type
  "The URL to redirect the request to.\\nNotes: \${num} refers to the position of '*' in the constraint value."
  url: URL
}

"The response type for the URL redirect."
enum query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value_type {
  temporary
  permanent
}

"The status of the Page Rule."
enum page_rule_components_schemas_status {
  active
  disabled
}

"URL target."
type url_target {
  constraint: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint
  target: url_const
}

"The constraint of a target."
type query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint {
  operator: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_0_operator!
  value: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_1_value
}

"The matches operator can use asterisks and pipes as wildcard and 'or' operators."
enum query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_0_operator {
  matches
  contains
  equals
  not_equal
  not_contain
}

scalar query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_1_value @regexp(pattern: "^(https?://)?(([-a-zA-Z0-9*]*\\\\.)+[-a-zA-Z0-9]{2,20})(:(8080|8443|443|80))?(/[\\\\S]+)?$") @typescript(type: "string")

enum url_const @typescript(type: "\\"url\\"") @example(value: "\\"url\\"") {
  url @enum(value: "\\"url\\"")
}

type page_rules_list_page_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union available_page_rules_settings_list_available_page_rules_settings_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "available_page_rules_settings_list_available_page_rules_settings_4xx_response") = pagerule_settings_response_collection | available_page_rules_settings_list_available_page_rules_settings_4xx_response

type pagerule_settings_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Settings available for the zone."
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
}

type available_page_rules_settings_list_available_page_rules_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_rules_get_a_page_rule_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_get_a_page_rule_4xx_response") = pagerule_response_single | page_rules_get_a_page_rule_4xx_response

type pagerule_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type page_rules_get_a_page_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union railgun_connections_for_a_zone_list_available_railguns_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_railgun_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_for_a_zone_list_available_railguns_4xx_response") = schemas_railgun_response_collection | railgun_connections_for_a_zone_list_available_railguns_4xx_response

type schemas_railgun_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type railgun_connections_for_a_zone_list_available_railguns_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union railgun_connections_for_a_zone_railgun_details_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_for_a_zone_railgun_details_4xx_response") = railgun_response_single | railgun_connections_for_a_zone_railgun_details_4xx_response

type railgun_connections_for_a_zone_railgun_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Railgun connection identifier tag."
scalar railgun_components_schemas_identifier_2 @length(min: null, max: 32)

union railgun_connections_for_a_zone_test_railgun_connection_response @statusCodeTypeName(statusCode: 200, typeName: "test_connection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_for_a_zone_test_railgun_connection_4xx_response") = test_connection_response | railgun_connections_for_a_zone_test_railgun_connection_4xx_response

type test_connection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: test_connection_properties
  "Whether the API call was successful"
  success: Boolean!
}

type test_connection_properties {
  "Hash version of body."
  body_hash: String
  "Size of the body in bytes."
  body_size: String
  "Lists any \`cf-cache-status\` present."
  cf_cache_status: String @resolveRootField(field: "cf-cache-status")
  "Lists any \`cf-ray\` present."
  cf_ray: String @resolveRootField(field: "cf-ray")
  "Lists any \`cf-wan-error\` present."
  cf_wan_error: String @resolveRootField(field: "cf-wan-error")
  "Whether Cloudflare is enabled on the host."
  cloudflare: String
  "Connection closed or open."
  connection_close: Boolean
  "Amount of seconds that the test lasted."
  elapsed_time: String
  "The hostname queried."
  host_name: String
  "The HTTP status response code."
  http_status: Float
  method: query_railgun_connections_for_a_zone_test_railgun_connection_oneOf_0_allOf_1_result_method
  "What headers are missing."
  missing_headers: String
  "Protocol used to test the connection."
  protocol: String
  "Indicates if Railgun is enabled on the queried hostname."
  railgun: String
  "HTTP Status code."
  response_status: String
  "Url of the domain you can compare the connection to."
  url: URL
}

"HTTP Method used to test the connection."
enum query_railgun_connections_for_a_zone_test_railgun_connection_oneOf_0_allOf_1_result_method {
  GET
  POST
}

type railgun_connections_for_a_zone_test_railgun_connection_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union rate_limits_for_a_zone_list_rate_limits_response @statusCodeTypeName(statusCode: 200, typeName: "ratelimit_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "rate_limits_for_a_zone_list_rate_limits_4xx_response") = ratelimit_response_collection | rate_limits_for_a_zone_list_rate_limits_4xx_response

type ratelimit_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [rate_limits]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type rate_limits {
  action: components_schemas_action
  "Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs."
  bypass: [query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_bypass_items]
  "An informative summary of the rate limit. This value is sanitized and any tags will be removed."
  description: components_schemas_description
  "When true, indicates that the rate limit is currently disabled."
  disabled: Boolean
  "The unique identifier of the rate limit."
  id: rate_limits_components_schemas_id!
  match: query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match
  "The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action."
  period: PositiveFloat
  "The threshold that will trigger the configured mitigation action. Configure this value along with the \`period\` property to establish a threshold per period."
  threshold: PositiveFloat
}

"The action to perform when the threshold of matched traffic within the configured period is exceeded."
type components_schemas_action {
  mode: mode
  response: custom_response
  "The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.\\nNotes: If \\"mode\\" is \\"challenge\\", \\"managed_challenge\\", or \\"js_challenge\\", Cloudflare will use the zone's Challenge Passage time and you should not provide this value."
  timeout: PositiveFloat
}

"The action to perform."
enum mode {
  simulate
  ban
  challenge
  js_challenge
  managed_challenge
}

"A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.\\nNotes: If you omit this object, Cloudflare will use the default HTML error page. If \\"mode\\" is \\"challenge\\", \\"managed_challenge\\", or \\"js_challenge\\", Cloudflare will use the zone challenge pages and you should not provide the \\"response\\" object."
type custom_response {
  "The response body to return. The value must conform to the configured content type."
  body: body
  "The content type of the body. Must be one of the following: \`text/plain\`, \`text/xml\`, or \`application/json\`."
  content_type: content_type
}

"The response body to return. The value must conform to the configured content type."
scalar body @length(min: null, max: 10240)

"The content type of the body. Must be one of the following: \`text/plain\`, \`text/xml\`, or \`application/json\`."
scalar content_type @length(min: null, max: 50)

type query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_bypass_items {
  name: url_const
  "The URL to bypass."
  value: String
}

"An informative summary of the rate limit. This value is sanitized and any tags will be removed."
scalar components_schemas_description @length(min: null, max: 1024)

"The unique identifier of the rate limit."
scalar rate_limits_components_schemas_id @length(min: null, max: 32)

type query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match {
  headers: [query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_headers_items]
  request: query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_request
  response: query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_response
}

type query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_headers_items {
  "The name of the response header to match."
  name: String
  op: header_op
  "The value of the response header, which must match exactly."
  value: String
}

"The operator used when matching: \`eq\` means \\"equal\\" and \`ne\` means \\"not equal\\"."
enum header_op {
  eq
  ne
}

type query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_request {
  "The HTTP methods to match. You can specify a subset (for example, \`['POST','PUT']\`) or all methods (\`['_ALL_']\`). This field is optional when creating a rate limit."
  methods: [query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_request_methods_items]
  "The HTTP schemes to match. You can specify one scheme (\`['HTTPS']\`), both schemes (\`['HTTP','HTTPS']\`), or all schemes (\`['_ALL_']\`). This field is optional."
  schemes: [String]
  "The URL pattern to match, composed of a host and a path such as \`example.org/path*\`. Normalization is applied before the pattern is matched. \`*\` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to \`*\` to match all traffic to your zone."
  url: schemas_url
}

"An HTTP method or \`_ALL_\` to indicate all methods."
enum query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_request_methods_items {
  GET
  POST
  PUT
  DELETE
  PATCH
  HEAD
  _ALL_
}

"The URL pattern to match, composed of a host and a path such as \`example.org/path*\`. Normalization is applied before the pattern is matched. \`*\` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to \`*\` to match all traffic to your zone."
scalar schemas_url @length(min: null, max: 1024)

type query_rate_limits_for_a_zone_list_rate_limits_oneOf_0_allOf_1_result_items_allOf_0_match_response {
  "When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.\\nNotes: This field is deprecated. Instead, use response headers and set \\"origin_traffic\\" to \\"false\\" to avoid legacy behaviour interacting with the \\"response_headers\\" property."
  origin_traffic: Boolean
}

type rate_limits_for_a_zone_list_rate_limits_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union rate_limits_for_a_zone_get_a_rate_limit_response @statusCodeTypeName(statusCode: 200, typeName: "ratelimit_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "rate_limits_for_a_zone_get_a_rate_limit_4xx_response") = ratelimit_response_single | rate_limits_for_a_zone_get_a_rate_limit_4xx_response

type ratelimit_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type rate_limits_for_a_zone_get_a_rate_limit_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_all_zone_settings_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_all_zone_settings_4xx_response") = zone_settings_response_collection | zone_settings_get_all_zone_settings_4xx_response

type zone_settings_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [setting]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union setting = Always_Online_Mode | Advanced_DDoS_Protection | Brotli_Compression | Browser_Cache_TTL | Browser_Check | Cloudflare_CNAME_Flattening | Cloudflare_Cache_Level | Challenge_Page_TTL | Development_Mode | Early_Hints | Edge_Cache_TTL | Error_Pages_On | Get_String_Sort | Email_Obfuscation | Hotlink_Protection | IP_Geolocation | IPv62 | WebSockets | Toggle_SHA1_support | TLS1_2_only | Auto_Minify_Assets | Max_Upload | Mobile_Redirect | Mirage_Image_Optimization | Network_Error_Logging | Polish_Image_Optimization | Polish_WebP_Conversion | Prefetch_preload | Privacy_Pass | Response_Buffering | Rocket_Loader | Security_Header | Security_Level | Server_Side_Exclude | SSL | SSL_TLS_Recommender | TLS_Client_Authentication | True_Client_IP_Header | Proxy_Read_Timeout | Web_Application_Firewall | Zone_Minimum_TLS_Version_value | Zone_ciphers_allowed_for_TLS_termination | Enable_TLS_1_3_value_for_a_zone | Enable_Opportunistic_Encryption_for_a_zone | Zone_Enable_Automatic_HTTPS_Rewrites | HTTP2_Value | HTTP3_Value | Origin_Max_HTTP_version | _0_RTT_Value | Pseudo_IPv4_Value | Zone_Enable_Always_Use_HTTPS | Zone_Enable_Onion_Routing | Orange_to_Orange | Image_Resizing | HTTP_2_Edge_Prioritization | Automatic_Platform_Optimization_for_WordPress

"When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
type Always_Online_Mode {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: always_online_const
  "last time this setting was modified."
  modified_on: DateTime
  value: always_online_value
}

enum always_online_const @typescript(type: "\\"always_online\\"") @example(value: "\\"always_online\\"") {
  always_online @enum(value: "\\"always_online\\"")
}

"Value of the zone setting."
enum always_online_value {
  on
  off
}

"Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones."
type Advanced_DDoS_Protection {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: advanced_ddos_const
  "last time this setting was modified."
  modified_on: DateTime
  value: advanced_ddos_value
}

enum advanced_ddos_const @typescript(type: "\\"advanced_ddos\\"") @example(value: "\\"advanced_ddos\\"") {
  advanced_ddos @enum(value: "\\"advanced_ddos\\"")
}

"Value of the zone setting.\\nNotes: Defaults to on for Business+ plans"
enum advanced_ddos_value {
  on
  off
}

"When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
type Brotli_Compression {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: brotli_const
  "last time this setting was modified."
  modified_on: DateTime
  value: brotli_value
}

enum brotli_const @typescript(type: "\\"brotli\\"") @example(value: "\\"brotli\\"") {
  brotli @enum(value: "\\"brotli\\"")
}

"Value of the zone setting."
enum brotli_value {
  off
  on
}

"Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
type Browser_Cache_TTL {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: browser_cache_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: browser_cache_ttl_value
}

enum browser_cache_ttl_const @typescript(type: "\\"browser_cache_ttl\\"") @example(value: "\\"browser_cache_ttl\\"") {
  browser_cache_ttl @enum(value: "\\"browser_cache_ttl\\"")
}

"Value of the zone setting.\\nNotes: Setting a TTL of 0 is equivalent to selecting \`Respect Existing Headers\`"
enum browser_cache_ttl_value {
  _0 @enum(value: "\\"0\\"")
  _30 @enum(value: "30")
  _60 @enum(value: "60")
  _120 @enum(value: "120")
  _300 @enum(value: "300")
  _1200 @enum(value: "1200")
  _1800 @enum(value: "1800")
  _3600 @enum(value: "3600")
  _7200 @enum(value: "7200")
  _10800 @enum(value: "10800")
  _14400 @enum(value: "14400")
  _18000 @enum(value: "18000")
  _28800 @enum(value: "28800")
  _43200 @enum(value: "43200")
  _57600 @enum(value: "57600")
  _72000 @enum(value: "72000")
  _86400 @enum(value: "86400")
  _172800 @enum(value: "172800")
  _259200 @enum(value: "259200")
  _345600 @enum(value: "345600")
  _432000 @enum(value: "432000")
  _691200 @enum(value: "691200")
  _1382400 @enum(value: "1382400")
  _2073600 @enum(value: "2073600")
  _2678400 @enum(value: "2678400")
  _5356800 @enum(value: "5356800")
  _16070400 @enum(value: "16070400")
  _31536000 @enum(value: "31536000")
}

"Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
type Browser_Check {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: browser_check_const
  "last time this setting was modified."
  modified_on: DateTime
  value: browser_check_value
}

enum browser_check_const @typescript(type: "\\"browser_check\\"") @example(value: "\\"browser_check\\"") {
  browser_check @enum(value: "\\"browser_check\\"")
}

"Value of the zone setting."
enum browser_check_value {
  on
  off
}

"Whether or not cname flattening is on."
type Cloudflare_CNAME_Flattening {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: cname_flattening_const
  "last time this setting was modified."
  modified_on: DateTime
  value: cname_flattening_value
}

enum cname_flattening_const @typescript(type: "\\"cname_flattening\\"") @example(value: "\\"cname_flattening\\"") {
  cname_flattening @enum(value: "\\"cname_flattening\\"")
}

"Value of the cname flattening setting."
enum cname_flattening_value {
  flatten_at_root
  flatten_all
}

"Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
type Cloudflare_Cache_Level {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: cache_level_const
  "last time this setting was modified."
  modified_on: DateTime
  value: cache_level_value
}

enum cache_level_const @typescript(type: "\\"cache_level\\"") @example(value: "\\"cache_level\\"") {
  cache_level @enum(value: "\\"cache_level\\"")
}

"Value of the zone setting."
enum cache_level_value {
  aggressive
  basic
  simplified
}

"Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
type Challenge_Page_TTL {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: challenge_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: challenge_ttl_value
}

enum challenge_ttl_const @typescript(type: "\\"challenge_ttl\\"") @example(value: "\\"challenge_ttl\\"") {
  challenge_ttl @enum(value: "\\"challenge_ttl\\"")
}

"Value of the zone setting."
enum challenge_ttl_value {
  _300 @enum(value: "300")
  _900 @enum(value: "900")
  _1800 @enum(value: "1800")
  _2700 @enum(value: "2700")
  _3600 @enum(value: "3600")
  _7200 @enum(value: "7200")
  _10800 @enum(value: "10800")
  _14400 @enum(value: "14400")
  _28800 @enum(value: "28800")
  _57600 @enum(value: "57600")
  _86400 @enum(value: "86400")
  _604800 @enum(value: "604800")
  _2592000 @enum(value: "2592000")
  _31536000 @enum(value: "31536000")
}

"Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
type Development_Mode {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: development_mode_const
  "last time this setting was modified."
  modified_on: DateTime
  value: development_mode_value
  "Value of the zone setting.\\nNotes: The interval (in seconds) from when development mode expires (positive integer) or last expired (negative integer) for the domain. If development mode has never been enabled, this value is false."
  time_remaining: Float
}

enum development_mode_const @typescript(type: "\\"development_mode\\"") @example(value: "\\"development_mode\\"") {
  development_mode @enum(value: "\\"development_mode\\"")
}

"Value of the zone setting."
enum development_mode_value {
  on
  off
}

"When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
type Early_Hints {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: early_hints_const
  "last time this setting was modified."
  modified_on: DateTime
  value: early_hints_value
}

enum early_hints_const @typescript(type: "\\"early_hints\\"") @example(value: "\\"early_hints\\"") {
  early_hints @enum(value: "\\"early_hints\\"")
}

"Value of the zone setting."
enum early_hints_value {
  on
  off
}

"Time (in seconds) that a resource will be ensured to remain on Cloudflare's cache servers."
type Edge_Cache_TTL {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: edge_cache_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: edge_cache_ttl_value
}

enum edge_cache_ttl_const @typescript(type: "\\"edge_cache_ttl\\"") @example(value: "\\"edge_cache_ttl\\"") {
  edge_cache_ttl @enum(value: "\\"edge_cache_ttl\\"")
}

"Value of the zone setting.\\nNotes: The minimum TTL available depends on the plan level of the zone. (Enterprise = 30, Business = 1800, Pro = 3600, Free = 7200)"
enum edge_cache_ttl_value {
  _30 @enum(value: "30")
  _60 @enum(value: "60")
  _300 @enum(value: "300")
  _1200 @enum(value: "1200")
  _1800 @enum(value: "1800")
  _3600 @enum(value: "3600")
  _7200 @enum(value: "7200")
  _10800 @enum(value: "10800")
  _14400 @enum(value: "14400")
  _18000 @enum(value: "18000")
  _28800 @enum(value: "28800")
  _43200 @enum(value: "43200")
  _57600 @enum(value: "57600")
  _72000 @enum(value: "72000")
  _86400 @enum(value: "86400")
  _172800 @enum(value: "172800")
  _259200 @enum(value: "259200")
  _345600 @enum(value: "345600")
  _432000 @enum(value: "432000")
  _518400 @enum(value: "518400")
  _604800 @enum(value: "604800")
}

"Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
type Error_Pages_On {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: origin_error_page_pass_thru_const
  "last time this setting was modified."
  modified_on: DateTime
  value: origin_error_page_pass_thru_value
}

enum origin_error_page_pass_thru_const @typescript(type: "\\"origin_error_page_pass_thru\\"") @example(value: "\\"origin_error_page_pass_thru\\"") {
  origin_error_page_pass_thru @enum(value: "\\"origin_error_page_pass_thru\\"")
}

"Value of the zone setting."
enum origin_error_page_pass_thru_value {
  on
  off
}

"Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
type Get_String_Sort {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: sort_query_string_for_cache_const
  "last time this setting was modified."
  modified_on: DateTime
  value: sort_query_string_for_cache_value
}

enum sort_query_string_for_cache_const @typescript(type: "\\"sort_query_string_for_cache\\"") @example(value: "\\"sort_query_string_for_cache\\"") {
  sort_query_string_for_cache @enum(value: "\\"sort_query_string_for_cache\\"")
}

"Value of the zone setting."
enum sort_query_string_for_cache_value {
  on
  off
}

"Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
type Email_Obfuscation {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: email_obfuscation_const
  "last time this setting was modified."
  modified_on: DateTime
  value: email_obfuscation_value
}

enum email_obfuscation_const @typescript(type: "\\"email_obfuscation\\"") @example(value: "\\"email_obfuscation\\"") {
  email_obfuscation @enum(value: "\\"email_obfuscation\\"")
}

"Value of the zone setting."
enum email_obfuscation_value {
  on
  off
}

"When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
type Hotlink_Protection {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: hotlink_protection_const
  "last time this setting was modified."
  modified_on: DateTime
  value: hotlink_protection_value
}

enum hotlink_protection_const @typescript(type: "\\"hotlink_protection\\"") @example(value: "\\"hotlink_protection\\"") {
  hotlink_protection @enum(value: "\\"hotlink_protection\\"")
}

"Value of the zone setting."
enum hotlink_protection_value {
  on
  off
}

"Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
type IP_Geolocation {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: ip_geolocation_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ip_geolocation_value
}

enum ip_geolocation_const @typescript(type: "\\"ip_geolocation\\"") @example(value: "\\"ip_geolocation\\"") {
  ip_geolocation @enum(value: "\\"ip_geolocation\\"")
}

"Value of the zone setting."
enum ip_geolocation_value {
  on
  off
}

"Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
type IPv62 {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: ipv6_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ipv6_value
}

enum ipv6_const @typescript(type: "\\"ipv6\\"") @example(value: "\\"ipv6\\"") {
  ipv6 @enum(value: "\\"ipv6\\"")
}

"Value of the zone setting."
enum ipv6_value {
  off
  on
}

"WebSockets are open connections sustained between the client and the origin server. Inside a WebSockets connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSockets connection fast. WebSockets are often used for real-time applications such as live chat and gaming. For more information refer to [Can I use Cloudflare with Websockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-Cloudflare-with-WebSockets-)."
type WebSockets {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: websockets_const
  "last time this setting was modified."
  modified_on: DateTime
  value: websockets_value
}

enum websockets_const @typescript(type: "\\"websockets\\"") @example(value: "\\"websockets\\"") {
  websockets @enum(value: "\\"websockets\\"")
}

"Value of the zone setting."
enum websockets_value {
  off
  on
}

"Allow SHA1 support."
type Toggle_SHA1_support {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: sha1_support_const
  "last time this setting was modified."
  modified_on: DateTime
  value: sha1_support_value
}

enum sha1_support_const @typescript(type: "\\"sha1_support\\"") @example(value: "\\"sha1_support\\"") {
  sha1_support @enum(value: "\\"sha1_support\\"")
}

"Value of the zone setting."
enum sha1_support_value {
  off
  on
}

"Only allows TLS1.2."
type TLS1_2_only {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: tls_1_2_only_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_1_2_only_value
}

enum tls_1_2_only_const @typescript(type: "\\"tls_1_2_only\\"") @example(value: "\\"tls_1_2_only\\"") {
  tls_1_2_only @enum(value: "\\"tls_1_2_only\\"")
}

"Value of the zone setting."
enum tls_1_2_only_value {
  off
  on
}

"Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
type Auto_Minify_Assets {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: minify_const
  "last time this setting was modified."
  modified_on: DateTime
  value: minify_value
}

enum minify_const @typescript(type: "\\"minify\\"") @example(value: "\\"minify\\"") {
  minify @enum(value: "\\"minify\\"")
}

"Value of the zone setting."
type minify_value {
  css: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_css
  html: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_html
  js: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_js
}

"Automatically minify all CSS files for your website."
enum query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_css {
  on
  off
}

"Automatically minify all HTML files for your website."
enum query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_html {
  on
  off
}

"Automatically minify all JavaScript files for your website."
enum query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_js {
  on
  off
}

"Maximum size of an allowable upload."
type Max_Upload {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: max_upload_const
  "last time this setting was modified."
  modified_on: DateTime
  value: max_upload_value
}

enum max_upload_const @typescript(type: "\\"max_upload\\"") @example(value: "\\"max_upload\\"") {
  max_upload @enum(value: "\\"max_upload\\"")
}

"Value of the zone setting.\\nNotes: The size depends on the plan level of the zone. (Enterprise = 500, Business = 200, Pro = 100, Free = 100)"
enum max_upload_value {
  _100 @enum(value: "100")
  _200 @enum(value: "200")
  _500 @enum(value: "500")
}

"Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
type Mobile_Redirect {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: mobile_redirect_const
  "last time this setting was modified."
  modified_on: DateTime
  value: mobile_redirect_value
}

enum mobile_redirect_const @typescript(type: "\\"mobile_redirect\\"") @example(value: "\\"mobile_redirect\\"") {
  mobile_redirect @enum(value: "\\"mobile_redirect\\"")
}

"Value of the zone setting."
type mobile_redirect_value {
  "Which subdomain prefix you wish to redirect visitors on mobile devices to (subdomain must already exist)."
  mobile_subdomain: NonEmptyString
  status: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_22_allOf_1_value_status
  "Whether to drop the current page path and redirect to the mobile subdomain URL root, or keep the path and redirect to the same page on the mobile subdomain."
  strip_uri: Boolean
}

"A string that cannot be passed as an empty value"
scalar NonEmptyString

"Whether or not mobile redirect is enabled."
enum query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_22_allOf_1_value_status {
  on
  off
}

"Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
type Mirage_Image_Optimization {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: mirage_const
  "last time this setting was modified."
  modified_on: DateTime
  value: mirage_value
}

enum mirage_const @typescript(type: "\\"mirage\\"") @example(value: "\\"mirage\\"") {
  mirage @enum(value: "\\"mirage\\"")
}

"Value of the zone setting."
enum mirage_value {
  on
  off
}

"Enable Network Error Logging reporting on your zone. (Beta)"
type Network_Error_Logging {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: nel_const
  "last time this setting was modified."
  modified_on: DateTime
  value: nel_value
}

enum nel_const @typescript(type: "\\"nel\\"") @example(value: "\\"nel\\"") {
  nel @enum(value: "\\"nel\\"")
}

"Value of the zone setting."
type nel_value {
  enabled: Boolean
}

"Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
type Polish_Image_Optimization {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: polish_const
  "last time this setting was modified."
  modified_on: DateTime
  value: polish_value
}

enum polish_const @typescript(type: "\\"polish\\"") @example(value: "\\"polish\\"") {
  polish @enum(value: "\\"polish\\"")
}

"Value of the zone setting."
enum polish_value {
  off
  lossless
  lossy
}

"When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
type Polish_WebP_Conversion {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: webp_const
  "last time this setting was modified."
  modified_on: DateTime
  value: webp_value
}

enum webp_const @typescript(type: "\\"webp\\"") @example(value: "\\"webp\\"") {
  webp @enum(value: "\\"webp\\"")
}

"Value of the zone setting."
enum webp_value {
  off
  on
}

"Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
type Prefetch_preload {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: prefetch_preload_const
  "last time this setting was modified."
  modified_on: DateTime
  value: prefetch_preload_value
}

enum prefetch_preload_const @typescript(type: "\\"prefetch_preload\\"") @example(value: "\\"prefetch_preload\\"") {
  prefetch_preload @enum(value: "\\"prefetch_preload\\"")
}

"Value of the zone setting."
enum prefetch_preload_value {
  on
  off
}

"Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
type Privacy_Pass {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: privacy_pass_const
  "last time this setting was modified."
  modified_on: DateTime
  value: privacy_pass_value
}

enum privacy_pass_const @typescript(type: "\\"privacy_pass\\"") @example(value: "\\"privacy_pass\\"") {
  privacy_pass @enum(value: "\\"privacy_pass\\"")
}

"Value of the zone setting."
enum privacy_pass_value {
  on
  off
}

"Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
type Response_Buffering {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: response_buffering_const
  "last time this setting was modified."
  modified_on: DateTime
  value: response_buffering_value
}

enum response_buffering_const @typescript(type: "\\"response_buffering\\"") @example(value: "\\"response_buffering\\"") {
  response_buffering @enum(value: "\\"response_buffering\\"")
}

"Value of the zone setting."
enum response_buffering_value {
  on
  off
}

"Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
type Rocket_Loader {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: rocket_loader_const
  "last time this setting was modified."
  modified_on: DateTime
  value: rocket_loader_value
}

enum rocket_loader_const @typescript(type: "\\"rocket_loader\\"") @example(value: "\\"rocket_loader\\"") {
  rocket_loader @enum(value: "\\"rocket_loader\\"")
}

"Value of the zone setting."
enum rocket_loader_value {
  on
  off
}

"Cloudflare security header for a zone."
type Security_Header {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: security_header_const
  "last time this setting was modified."
  modified_on: DateTime
  value: security_header_value
}

enum security_header_const @typescript(type: "\\"security_header\\"") @example(value: "\\"security_header\\"") {
  security_header @enum(value: "\\"security_header\\"")
}

type security_header_value {
  strict_transport_security: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_31_allOf_1_value_strict_transport_security
}

"Strict Transport Security."
type query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_31_allOf_1_value_strict_transport_security {
  "Whether or not strict transport security is enabled."
  enabled: Boolean
  "Include all subdomains for strict transport security."
  include_subdomains: Boolean
  "Max age in seconds of the strict transport security."
  max_age: Float
  "Whether or not to include 'X-Content-Type-Options: nosniff' header."
  nosniff: Boolean
}

"Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
type Security_Level {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: security_level_const
  "last time this setting was modified."
  modified_on: DateTime
  value: security_level_value
}

enum security_level_const @typescript(type: "\\"security_level\\"") @example(value: "\\"security_level\\"") {
  security_level @enum(value: "\\"security_level\\"")
}

"Value of the zone setting."
enum security_level_value {
  off
  essentially_off
  low
  medium
  high
  under_attack
}

"If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
type Server_Side_Exclude {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: server_side_exclude_const
  "last time this setting was modified."
  modified_on: DateTime
  value: server_side_exclude_value
}

enum server_side_exclude_const @typescript(type: "\\"server_side_exclude\\"") @example(value: "\\"server_side_exclude\\"") {
  server_side_exclude @enum(value: "\\"server_side_exclude\\"")
}

"Value of the zone setting."
enum server_side_exclude_value {
  on
  off
}

"SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
type SSL {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: ssl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ssl_value
}

enum ssl_const @typescript(type: "\\"ssl\\"") @example(value: "\\"ssl\\"") {
  ssl @enum(value: "\\"ssl\\"")
}

"Value of the zone setting.\\nNotes: Depends on the zone's plan level"
enum ssl_value {
  off
  flexible
  full
  strict
}

"Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
type SSL_TLS_Recommender {
  "ssl-recommender enrollment setting."
  enabled: Boolean
  id: ssl_recommender_const
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  "last time this setting was modified."
  modified_on: DateTime
}

enum ssl_recommender_const @typescript(type: "\\"ssl_recommender\\"") @example(value: "\\"ssl_recommender\\"") {
  ssl_recommender @enum(value: "\\"ssl_recommender\\"")
}

"TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
type TLS_Client_Authentication {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: tls_client_auth_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_client_auth_value
}

enum tls_client_auth_const @typescript(type: "\\"tls_client_auth\\"") @example(value: "\\"tls_client_auth\\"") {
  tls_client_auth @enum(value: "\\"tls_client_auth\\"")
}

"value of the zone setting."
enum tls_client_auth_value {
  on
  off
}

"Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
type True_Client_IP_Header {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: true_client_ip_header_const
  "last time this setting was modified."
  modified_on: DateTime
  value: true_client_ip_header_value
}

enum true_client_ip_header_const @typescript(type: "\\"true_client_ip_header\\"") @example(value: "\\"true_client_ip_header\\"") {
  true_client_ip_header @enum(value: "\\"true_client_ip_header\\"")
}

"Value of the zone setting."
enum true_client_ip_header_value {
  on
  off
}

"Maximum time between two read operations from origin."
type Proxy_Read_Timeout {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: proxy_read_timeout_const
  "last time this setting was modified."
  modified_on: DateTime
  "Value of the zone setting.\\nNotes: Value must be between 1 and 6000"
  value: Float
}

enum proxy_read_timeout_const @typescript(type: "\\"proxy_read_timeout\\"") @example(value: "\\"proxy_read_timeout\\"") {
  proxy_read_timeout @enum(value: "\\"proxy_read_timeout\\"")
}

"The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
type Web_Application_Firewall {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: waf_const
  "last time this setting was modified."
  modified_on: DateTime
  value: waf_value
}

enum waf_const @typescript(type: "\\"waf\\"") @example(value: "\\"waf\\"") {
  waf @enum(value: "\\"waf\\"")
}

"Value of the zone setting."
enum waf_value {
  on
  off
}

"Only accepts HTTPS requests that use at least the TLS protocol version specified. For example, if TLS 1.1 is selected, TLS 1.0 connections will be rejected, while 1.1, 1.2, and 1.3 (if enabled) will be permitted."
type Zone_Minimum_TLS_Version_value {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: min_tls_version_const
  "last time this setting was modified."
  modified_on: DateTime
  value: min_tls_version_value
}

enum min_tls_version_const @typescript(type: "\\"min_tls_version\\"") @example(value: "\\"min_tls_version\\"") {
  min_tls_version @enum(value: "\\"min_tls_version\\"")
}

"Value of the zone setting."
enum min_tls_version_value {
  _1_0 @enum(value: "\\"1.0\\"")
  _1_1 @enum(value: "\\"1.1\\"")
  _1_2 @enum(value: "\\"1.2\\"")
  _1_3 @enum(value: "\\"1.3\\"")
}

"An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
type Zone_ciphers_allowed_for_TLS_termination {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: ciphers_const
  "last time this setting was modified."
  modified_on: DateTime
  "Value of the zone setting."
  value: [String]
}

enum ciphers_const @typescript(type: "\\"ciphers\\"") @example(value: "\\"ciphers\\"") {
  ciphers @enum(value: "\\"ciphers\\"")
}

"Enables Crypto TLS 1.3 feature for a zone."
type Enable_TLS_1_3_value_for_a_zone {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: tls_1_3_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_1_3_value
}

enum tls_1_3_const @typescript(type: "\\"tls_1_3\\"") @example(value: "\\"tls_1_3\\"") {
  tls_1_3 @enum(value: "\\"tls_1_3\\"")
}

"Value of the zone setting.\\nNotes: Default value depends on the zone's plan level."
enum tls_1_3_value {
  on
  off
  zrt
}

"Enables the Opportunistic Encryption feature for a zone."
type Enable_Opportunistic_Encryption_for_a_zone {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: opportunistic_encryption_const
  "last time this setting was modified."
  modified_on: DateTime
  value: opportunistic_encryption_value
}

enum opportunistic_encryption_const @typescript(type: "\\"opportunistic_encryption\\"") @example(value: "\\"opportunistic_encryption\\"") {
  opportunistic_encryption @enum(value: "\\"opportunistic_encryption\\"")
}

"Value of the zone setting.\\nNotes: Default value depends on the zone's plan level."
enum opportunistic_encryption_value {
  on
  off
}

"Enable the Automatic HTTPS Rewrites feature for this zone."
type Zone_Enable_Automatic_HTTPS_Rewrites {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: automatic_https_rewrites_const
  "last time this setting was modified."
  modified_on: DateTime
  value: automatic_https_rewrites_value
}

enum automatic_https_rewrites_const @typescript(type: "\\"automatic_https_rewrites\\"") @example(value: "\\"automatic_https_rewrites\\"") {
  automatic_https_rewrites @enum(value: "\\"automatic_https_rewrites\\"")
}

"Value of the zone setting.\\nNotes: Default value depends on the zone's plan level."
enum automatic_https_rewrites_value {
  on
  off
}

"HTTP2 enabled for this zone."
type HTTP2_Value {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: http2_const
  "last time this setting was modified."
  modified_on: DateTime
  value: http2_value
}

enum http2_const @typescript(type: "\\"http2\\"") @example(value: "\\"http2\\"") {
  http2 @enum(value: "\\"http2\\"")
}

"Value of the HTTP2 setting."
enum http2_value {
  on
  off
}

"HTTP3 enabled for this zone."
type HTTP3_Value {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: http3_const
  "last time this setting was modified."
  modified_on: DateTime
  value: http3_value
}

enum http3_const @typescript(type: "\\"http3\\"") @example(value: "\\"http3\\"") {
  http3 @enum(value: "\\"http3\\"")
}

"Value of the HTTP3 setting."
enum http3_value {
  on
  off
}

"The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.)."
type Origin_Max_HTTP_version {
  id: origin_max_http_version_const!
  "last time this setting was modified."
  modified_on: DateTime
}

enum origin_max_http_version_const @typescript(type: "\\"origin_max_http_version\\"") @example(value: "\\"origin_max_http_version\\"") {
  origin_max_http_version @enum(value: "\\"origin_max_http_version\\"")
}

"0-RTT session resumption enabled for this zone."
type _0_RTT_Value {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: _0rtt_const
  "last time this setting was modified."
  modified_on: DateTime
  value: _0rtt_value
}

enum _0rtt_const @typescript(type: "\\"0rtt\\"") @example(value: "\\"0rtt\\"") {
  _0rtt @enum(value: "\\"0rtt\\"")
}

"Value of the 0-RTT setting."
enum _0rtt_value {
  on
  off
}

"The value set for the Pseudo IPv4 setting."
type Pseudo_IPv4_Value {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: pseudo_ipv4_const
  "last time this setting was modified."
  modified_on: DateTime
  value: pseudo_ipv4_value
}

enum pseudo_ipv4_const @typescript(type: "\\"pseudo_ipv4\\"") @example(value: "\\"pseudo_ipv4\\"") {
  pseudo_ipv4 @enum(value: "\\"pseudo_ipv4\\"")
}

"Value of the Pseudo IPv4 setting."
enum pseudo_ipv4_value {
  off
  add_header
  overwrite_header
}

"Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
type Zone_Enable_Always_Use_HTTPS {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: always_use_https_const
  "last time this setting was modified."
  modified_on: DateTime
  value: always_use_https_value
}

enum always_use_https_const @typescript(type: "\\"always_use_https\\"") @example(value: "\\"always_use_https\\"") {
  always_use_https @enum(value: "\\"always_use_https\\"")
}

"Value of the zone setting."
enum always_use_https_value {
  on
  off
}

"Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
type Zone_Enable_Onion_Routing {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: opportunistic_onion_const
  "last time this setting was modified."
  modified_on: DateTime
  value: opportunistic_onion_value
}

enum opportunistic_onion_const @typescript(type: "\\"opportunistic_onion\\"") @example(value: "\\"opportunistic_onion\\"") {
  opportunistic_onion @enum(value: "\\"opportunistic_onion\\"")
}

"Value of the zone setting.\\nNotes: Default value depends on the zone's plan level."
enum opportunistic_onion_value {
  on
  off
}

"Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
type Orange_to_Orange {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: orange_to_orange_const
  "last time this setting was modified."
  modified_on: DateTime
  value: orange_to_orange_value
}

enum orange_to_orange_const @typescript(type: "\\"orange_to_orange\\"") @example(value: "\\"orange_to_orange\\"") {
  orange_to_orange @enum(value: "\\"orange_to_orange\\"")
}

"Value of the zone setting."
enum orange_to_orange_value {
  on
  off
}

"Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
type Image_Resizing {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: image_resizing_const
  "last time this setting was modified."
  modified_on: DateTime
  value: image_resizing_value
}

enum image_resizing_const @typescript(type: "\\"image_resizing\\"") @example(value: "\\"image_resizing\\"") {
  image_resizing @enum(value: "\\"image_resizing\\"")
}

"Whether the feature is enabled, disabled, or enabled in \`open proxy\` mode."
enum image_resizing_value {
  on
  off
  open
}

"HTTP/2 Edge Prioritization optimises the delivery of resources served through HTTP/2 to improve page load performance. It also supports fine control of content delivery when used in conjunction with Workers."
type HTTP_2_Edge_Prioritization {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: h2_prioritization_const
  "last time this setting was modified."
  modified_on: DateTime
  value: h2_prioritization_value
}

enum h2_prioritization_const @typescript(type: "\\"h2_prioritization\\"") @example(value: "\\"h2_prioritization\\"") {
  h2_prioritization @enum(value: "\\"h2_prioritization\\"")
}

"Value of the zone setting."
enum h2_prioritization_value {
  on
  off
  custom
}

"[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts."
type Automatic_Platform_Optimization_for_WordPress {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean
  id: automatic_platform_optimization_const
  "last time this setting was modified."
  modified_on: DateTime
  value: automatic_platform_optimization
}

enum automatic_platform_optimization_const @typescript(type: "\\"automatic_platform_optimization\\"") @example(value: "\\"automatic_platform_optimization\\"") {
  automatic_platform_optimization @enum(value: "\\"automatic_platform_optimization\\"")
}

type automatic_platform_optimization {
  "Indicates whether or not [cache by device type](https://developers.cloudflare.com/automatic-platform-optimization/reference/cache-device-type/) is enabled."
  cache_by_device_type: Boolean!
  "Indicates whether or not Cloudflare proxy is enabled."
  cf: Boolean!
  "Indicates whether or not Automatic Platform Optimization is enabled."
  enabled: Boolean!
  "An array of hostnames where Automatic Platform Optimization for WordPress is activated."
  hostnames: [Hostname]!
  "Indicates whether or not site is powered by WordPress."
  wordpress: Boolean!
  "Indicates whether or not [Cloudflare for WordPress plugin](https://wordpress.org/plugins/cloudflare/) is installed."
  wp_plugin: Boolean!
}

type zone_settings_get_all_zone_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union zone_settings_get_0_rtt_session_resumption_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_0_rtt_session_resumption_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_0_rtt_session_resumption_setting_4xx_response") = zone_settings_get_0_rtt_session_resumption_setting_200_response | zone_settings_get_0_rtt_session_resumption_setting_4xx_response

type zone_settings_get_0_rtt_session_resumption_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "0-RTT session resumption enabled for this zone."
  result: _0_RTT_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_0_rtt_session_resumption_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_advanced_ddos_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_advanced_ddos_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_advanced_ddos_setting_4xx_response") = zone_settings_get_advanced_ddos_setting_200_response | zone_settings_get_advanced_ddos_setting_4xx_response

type zone_settings_get_advanced_ddos_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones."
  result: Advanced_DDoS_Protection
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_advanced_ddos_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_always_online_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_always_online_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_always_online_setting_4xx_response") = zone_settings_get_always_online_setting_200_response | zone_settings_get_always_online_setting_4xx_response

type zone_settings_get_always_online_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
  result: Always_Online_Mode
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_always_online_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_always_use_https_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_always_use_https_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_always_use_https_setting_4xx_response") = zone_settings_get_always_use_https_setting_200_response | zone_settings_get_always_use_https_setting_4xx_response

type zone_settings_get_always_use_https_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
  result: Zone_Enable_Always_Use_HTTPS
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_always_use_https_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_automatic_https_rewrites_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_automatic_https_rewrites_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_automatic_https_rewrites_setting_4xx_response") = zone_settings_get_automatic_https_rewrites_setting_200_response | zone_settings_get_automatic_https_rewrites_setting_4xx_response

type zone_settings_get_automatic_https_rewrites_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable the Automatic HTTPS Rewrites feature for this zone."
  result: Zone_Enable_Automatic_HTTPS_Rewrites
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_automatic_https_rewrites_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_automatic_platform_optimization_for_word_press_settings_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_automatic_platform_optimization_for_word_press_settings_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_automatic_platform_optimization_for_word_press_settings_4xx_response") = zone_settings_get_automatic_platform_optimization_for_word_press_settings_200_response | zone_settings_get_automatic_platform_optimization_for_word_press_settings_4xx_response

type zone_settings_get_automatic_platform_optimization_for_word_press_settings_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: automatic_platform_optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_automatic_platform_optimization_for_word_press_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_brotli_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_brotli_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_brotli_setting_4xx_response") = zone_settings_get_brotli_setting_200_response | zone_settings_get_brotli_setting_4xx_response

type zone_settings_get_brotli_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
  result: Brotli_Compression
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_brotli_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_browser_cache_ttl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_browser_cache_ttl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_browser_cache_ttl_setting_4xx_response") = zone_settings_get_browser_cache_ttl_setting_200_response | zone_settings_get_browser_cache_ttl_setting_4xx_response

type zone_settings_get_browser_cache_ttl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
  result: Browser_Cache_TTL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_browser_cache_ttl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_browser_check_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_browser_check_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_browser_check_setting_4xx_response") = zone_settings_get_browser_check_setting_200_response | zone_settings_get_browser_check_setting_4xx_response

type zone_settings_get_browser_check_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
  result: Browser_Check
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_browser_check_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_cache_level_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_cache_level_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_cache_level_setting_4xx_response") = zone_settings_get_cache_level_setting_200_response | zone_settings_get_cache_level_setting_4xx_response

type zone_settings_get_cache_level_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
  result: Cloudflare_Cache_Level
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_cache_level_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_challenge_ttl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_challenge_ttl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_challenge_ttl_setting_4xx_response") = zone_settings_get_challenge_ttl_setting_200_response | zone_settings_get_challenge_ttl_setting_4xx_response

type zone_settings_get_challenge_ttl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
  result: Challenge_Page_TTL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_challenge_ttl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_ciphers_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_ciphers_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_ciphers_setting_4xx_response") = zone_settings_get_ciphers_setting_200_response | zone_settings_get_ciphers_setting_4xx_response

type zone_settings_get_ciphers_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
  result: Zone_ciphers_allowed_for_TLS_termination
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_ciphers_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_development_mode_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_development_mode_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_development_mode_setting_4xx_response") = zone_settings_get_development_mode_setting_200_response | zone_settings_get_development_mode_setting_4xx_response

type zone_settings_get_development_mode_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
  result: Development_Mode
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_development_mode_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_early_hints_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_early_hints_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_early_hints_setting_4xx_response") = zone_settings_get_early_hints_setting_200_response | zone_settings_get_early_hints_setting_4xx_response

type zone_settings_get_early_hints_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
  result: Early_Hints
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_early_hints_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_email_obfuscation_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_email_obfuscation_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_email_obfuscation_setting_4xx_response") = zone_settings_get_email_obfuscation_setting_200_response | zone_settings_get_email_obfuscation_setting_4xx_response

type zone_settings_get_email_obfuscation_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
  result: Email_Obfuscation
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_email_obfuscation_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_http__2_edge_prioritization_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_http__2_edge_prioritization_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_http__2_edge_prioritization_setting_4xx_response") = zone_settings_get_http__2_edge_prioritization_setting_200_response | zone_settings_get_http__2_edge_prioritization_setting_4xx_response

type zone_settings_get_http__2_edge_prioritization_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP/2 Edge Prioritization optimises the delivery of resources served through HTTP/2 to improve page load performance. It also supports fine control of content delivery when used in conjunction with Workers."
  result: HTTP_2_Edge_Prioritization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_http__2_edge_prioritization_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_hotlink_protection_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_hotlink_protection_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_hotlink_protection_setting_4xx_response") = zone_settings_get_hotlink_protection_setting_200_response | zone_settings_get_hotlink_protection_setting_4xx_response

type zone_settings_get_hotlink_protection_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
  result: Hotlink_Protection
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_hotlink_protection_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_h_t_t_p_2_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_h_t_t_p_2_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_h_t_t_p_2_setting_4xx_response") = zone_settings_get_h_t_t_p_2_setting_200_response | zone_settings_get_h_t_t_p_2_setting_4xx_response

type zone_settings_get_h_t_t_p_2_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP2 enabled for this zone."
  result: HTTP2_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_h_t_t_p_2_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_h_t_t_p_3_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_h_t_t_p_3_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_h_t_t_p_3_setting_4xx_response") = zone_settings_get_h_t_t_p_3_setting_200_response | zone_settings_get_h_t_t_p_3_setting_4xx_response

type zone_settings_get_h_t_t_p_3_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP3 enabled for this zone."
  result: HTTP3_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_h_t_t_p_3_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_image_resizing_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_image_resizing_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_image_resizing_setting_4xx_response") = zone_settings_get_image_resizing_setting_200_response | zone_settings_get_image_resizing_setting_4xx_response

type zone_settings_get_image_resizing_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
  result: Image_Resizing
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_image_resizing_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_ip_geolocation_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_ip_geolocation_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_ip_geolocation_setting_4xx_response") = zone_settings_get_ip_geolocation_setting_200_response | zone_settings_get_ip_geolocation_setting_4xx_response

type zone_settings_get_ip_geolocation_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
  result: IP_Geolocation
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_ip_geolocation_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_i_pv6_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_i_pv6_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_i_pv6_setting_4xx_response") = zone_settings_get_i_pv6_setting_200_response | zone_settings_get_i_pv6_setting_4xx_response

type zone_settings_get_i_pv6_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
  result: IPv62
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_i_pv6_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_minimum_tls_version_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_minimum_tls_version_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_minimum_tls_version_setting_4xx_response") = zone_settings_get_minimum_tls_version_setting_200_response | zone_settings_get_minimum_tls_version_setting_4xx_response

type zone_settings_get_minimum_tls_version_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Only accepts HTTPS requests that use at least the TLS protocol version specified. For example, if TLS 1.1 is selected, TLS 1.0 connections will be rejected, while 1.1, 1.2, and 1.3 (if enabled) will be permitted."
  result: Zone_Minimum_TLS_Version_value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_minimum_tls_version_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_minify_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_minify_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_minify_setting_4xx_response") = zone_settings_get_minify_setting_200_response | zone_settings_get_minify_setting_4xx_response

type zone_settings_get_minify_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
  result: Auto_Minify_Assets
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_minify_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_mirage_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_mirage_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_mirage_setting_4xx_response") = zone_settings_get_mirage_setting_200_response | zone_settings_get_mirage_setting_4xx_response

type zone_settings_get_mirage_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
  result: Mirage_Image_Optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_mirage_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_mobile_redirect_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_mobile_redirect_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_mobile_redirect_setting_4xx_response") = zone_settings_get_mobile_redirect_setting_200_response | zone_settings_get_mobile_redirect_setting_4xx_response

type zone_settings_get_mobile_redirect_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
  result: Mobile_Redirect
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_mobile_redirect_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_network_error_logging_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_network_error_logging_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_network_error_logging_setting_4xx_response") = zone_settings_get_network_error_logging_setting_200_response | zone_settings_get_network_error_logging_setting_4xx_response

type zone_settings_get_network_error_logging_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable Network Error Logging reporting on your zone. (Beta)"
  result: Network_Error_Logging
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_network_error_logging_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_opportunistic_encryption_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_opportunistic_encryption_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_opportunistic_encryption_setting_4xx_response") = zone_settings_get_opportunistic_encryption_setting_200_response | zone_settings_get_opportunistic_encryption_setting_4xx_response

type zone_settings_get_opportunistic_encryption_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables the Opportunistic Encryption feature for a zone."
  result: Enable_Opportunistic_Encryption_for_a_zone
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_opportunistic_encryption_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_opportunistic_onion_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_opportunistic_onion_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_opportunistic_onion_setting_4xx_response") = zone_settings_get_opportunistic_onion_setting_200_response | zone_settings_get_opportunistic_onion_setting_4xx_response

type zone_settings_get_opportunistic_onion_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
  result: Zone_Enable_Onion_Routing
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_opportunistic_onion_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_orange_to_orange__o_2_o_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_orange_to_orange__o_2_o_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_orange_to_orange__o_2_o_4xx_response") = zone_settings_get_orange_to_orange__o_2_o_200_response | zone_settings_get_orange_to_orange__o_2_o_4xx_response

type zone_settings_get_orange_to_orange__o_2_o_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
  result: Orange_to_Orange
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_orange_to_orange__o_2_o_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_enable_error_pages_on_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_enable_error_pages_on_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_enable_error_pages_on_setting_4xx_response") = zone_settings_get_enable_error_pages_on_setting_200_response | zone_settings_get_enable_error_pages_on_setting_4xx_response

type zone_settings_get_enable_error_pages_on_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
  result: Error_Pages_On
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_enable_error_pages_on_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_origin_max_http_version_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_origin_max_http_version_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_origin_max_http_version_setting_4xx_response") = zone_settings_get_origin_max_http_version_setting_200_response | zone_settings_get_origin_max_http_version_setting_4xx_response

type zone_settings_get_origin_max_http_version_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_settings_get_origin_max_http_version_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_zone_settings_get_origin_max_http_version_setting_oneOf_0_allOf_1_result {
  id: origin_max_http_version_const!
  "last time this setting was modified."
  modified_on: DateTime
  value: origin_max_http_version_value!
}

"Value of the Origin Max HTTP version setting (Note that the default value for Enterprise is \\"1\\")."
enum origin_max_http_version_value {
  _1 @enum(value: "\\"1\\"")
  _2 @enum(value: "\\"2\\"")
}

type zone_settings_get_origin_max_http_version_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_polish_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_polish_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_polish_setting_4xx_response") = zone_settings_get_polish_setting_200_response | zone_settings_get_polish_setting_4xx_response

type zone_settings_get_polish_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
  result: Polish_Image_Optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_polish_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_prefetch_preload_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_prefetch_preload_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_prefetch_preload_setting_4xx_response") = zone_settings_get_prefetch_preload_setting_200_response | zone_settings_get_prefetch_preload_setting_4xx_response

type zone_settings_get_prefetch_preload_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
  result: Prefetch_preload
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_prefetch_preload_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_privacy_pass_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_privacy_pass_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_privacy_pass_setting_4xx_response") = zone_settings_get_privacy_pass_setting_200_response | zone_settings_get_privacy_pass_setting_4xx_response

type zone_settings_get_privacy_pass_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
  result: Privacy_Pass
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_privacy_pass_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_proxy_read_timeout_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_proxy_read_timeout_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_proxy_read_timeout_setting_4xx_response") = zone_settings_get_proxy_read_timeout_setting_200_response | zone_settings_get_proxy_read_timeout_setting_4xx_response

type zone_settings_get_proxy_read_timeout_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Maximum time between two read operations from origin."
  result: Proxy_Read_Timeout
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_proxy_read_timeout_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_pseudo_i_pv4_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_pseudo_i_pv4_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_pseudo_i_pv4_setting_4xx_response") = zone_settings_get_pseudo_i_pv4_setting_200_response | zone_settings_get_pseudo_i_pv4_setting_4xx_response

type zone_settings_get_pseudo_i_pv4_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The value set for the Pseudo IPv4 setting."
  result: Pseudo_IPv4_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_pseudo_i_pv4_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_response_buffering_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_response_buffering_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_response_buffering_setting_4xx_response") = zone_settings_get_response_buffering_setting_200_response | zone_settings_get_response_buffering_setting_4xx_response

type zone_settings_get_response_buffering_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
  result: Response_Buffering
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_response_buffering_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_rocket_loader_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_rocket_loader_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_rocket_loader_setting_4xx_response") = zone_settings_get_rocket_loader_setting_200_response | zone_settings_get_rocket_loader_setting_4xx_response

type zone_settings_get_rocket_loader_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
  result: Rocket_Loader
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_rocket_loader_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_security_header__hsts_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_security_header__hsts_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_security_header__hsts_setting_4xx_response") = zone_settings_get_security_header__hsts_setting_200_response | zone_settings_get_security_header__hsts_setting_4xx_response

type zone_settings_get_security_header__hsts_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare security header for a zone."
  result: Security_Header
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_security_header__hsts_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_security_level_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_security_level_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_security_level_setting_4xx_response") = zone_settings_get_security_level_setting_200_response | zone_settings_get_security_level_setting_4xx_response

type zone_settings_get_security_level_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
  result: Security_Level
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_security_level_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_server_side_exclude_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_server_side_exclude_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_server_side_exclude_setting_4xx_response") = zone_settings_get_server_side_exclude_setting_200_response | zone_settings_get_server_side_exclude_setting_4xx_response

type zone_settings_get_server_side_exclude_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
  result: Server_Side_Exclude
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_server_side_exclude_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_enable_query_string_sort_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_enable_query_string_sort_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_enable_query_string_sort_setting_4xx_response") = zone_settings_get_enable_query_string_sort_setting_200_response | zone_settings_get_enable_query_string_sort_setting_4xx_response

type zone_settings_get_enable_query_string_sort_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
  result: Get_String_Sort
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_enable_query_string_sort_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_ssl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_ssl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_ssl_setting_4xx_response") = zone_settings_get_ssl_setting_200_response | zone_settings_get_ssl_setting_4xx_response

type zone_settings_get_ssl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
  result: SSL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_ssl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_ssl__tls_recommender_enrollment_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_ssl__tls_recommender_enrollment_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_ssl__tls_recommender_enrollment_4xx_response") = zone_settings_get_ssl__tls_recommender_enrollment_200_response | zone_settings_get_ssl__tls_recommender_enrollment_4xx_response

type zone_settings_get_ssl__tls_recommender_enrollment_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
  result: SSL_TLS_Recommender
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_ssl__tls_recommender_enrollment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_tls_1__3_setting_enabled_for_a_zone_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_tls_1__3_setting_enabled_for_a_zone_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_tls_1__3_setting_enabled_for_a_zone_4xx_response") = zone_settings_get_tls_1__3_setting_enabled_for_a_zone_200_response | zone_settings_get_tls_1__3_setting_enabled_for_a_zone_4xx_response

type zone_settings_get_tls_1__3_setting_enabled_for_a_zone_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables Crypto TLS 1.3 feature for a zone."
  result: Enable_TLS_1_3_value_for_a_zone
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_tls_1__3_setting_enabled_for_a_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_tls_client_auth_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_tls_client_auth_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_tls_client_auth_setting_4xx_response") = zone_settings_get_tls_client_auth_setting_200_response | zone_settings_get_tls_client_auth_setting_4xx_response

type zone_settings_get_tls_client_auth_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
  result: TLS_Client_Authentication
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_tls_client_auth_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_true_client_ip_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_true_client_ip_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_true_client_ip_setting_4xx_response") = zone_settings_get_true_client_ip_setting_200_response | zone_settings_get_true_client_ip_setting_4xx_response

type zone_settings_get_true_client_ip_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
  result: True_Client_IP_Header
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_true_client_ip_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_web_application_firewall__waf_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_web_application_firewall__waf_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_web_application_firewall__waf_setting_4xx_response") = zone_settings_get_web_application_firewall__waf_setting_200_response | zone_settings_get_web_application_firewall__waf_setting_4xx_response

type zone_settings_get_web_application_firewall__waf_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
  result: Web_Application_Firewall
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_web_application_firewall__waf_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_web_p_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_web_p_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_web_p_setting_4xx_response") = zone_settings_get_web_p_setting_200_response | zone_settings_get_web_p_setting_4xx_response

type zone_settings_get_web_p_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
  result: Polish_WebP_Conversion
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_web_p_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_settings_get_web_sockets_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_get_web_sockets_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_get_web_sockets_setting_4xx_response") = zone_settings_get_web_sockets_setting_200_response | zone_settings_get_web_sockets_setting_4xx_response

type zone_settings_get_web_sockets_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "WebSockets are open connections sustained between the client and the origin server. Inside a WebSockets connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSockets connection fast. WebSockets are often used for real-time applications such as live chat and gaming. For more information refer to [Can I use Cloudflare with Websockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-Cloudflare-with-WebSockets-)."
  result: WebSockets
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_get_web_sockets_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union certificate_packs_list_certificate_packs_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_pack_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_list_certificate_packs_4xx_response") = certificate_pack_response_collection | certificate_packs_list_certificate_packs_4xx_response

type certificate_pack_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type certificate_packs_list_certificate_packs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union certificate_packs_get_certificate_pack_quotas_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_pack_quota_response") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_get_certificate_pack_quotas_4xx_response") = certificate_pack_quota_response | certificate_packs_get_certificate_pack_quotas_4xx_response

type certificate_pack_quota_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_certificate_packs_get_certificate_pack_quotas_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_certificate_packs_get_certificate_pack_quotas_oneOf_0_allOf_1_result {
  advanced: quota
}

type quota {
  "Quantity Allocated."
  allocated: Int
  "Quantity Used."
  used: Int
}

type certificate_packs_get_certificate_pack_quotas_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union certificate_packs_get_certificate_pack_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_pack_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_get_certificate_pack_4xx_response") = certificate_pack_response_single | certificate_packs_get_certificate_pack_4xx_response

type certificate_pack_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type certificate_packs_get_certificate_pack_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ssl__tls_mode_recommendation_ssl__tls_recommendation_response @statusCodeTypeName(statusCode: 200, typeName: "ssl__tls_mode_recommendation_ssl__tls_recommendation_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ssl__tls_mode_recommendation_ssl__tls_recommendation_4xx_response") = ssl__tls_mode_recommendation_ssl__tls_recommendation_200_response | ssl__tls_mode_recommendation_ssl__tls_recommendation_4xx_response

type ssl__tls_mode_recommendation_ssl__tls_recommendation_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_ssl__tls_mode_recommendation_ssl__tls_recommendation_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_ssl__tls_mode_recommendation_ssl__tls_recommendation_oneOf_0_allOf_1_result {
  "Identifier of a recommedation result."
  id: String
  modified_on: DateTime
  value: components_schemas_value
}

enum components_schemas_value {
  flexible
  full
  strict
}

type ssl__tls_mode_recommendation_ssl__tls_recommendation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union universal_ssl_settings_for_a_zone_universal_ssl_settings_details_response @statusCodeTypeName(statusCode: 200, typeName: "ssl_universal_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "universal_ssl_settings_for_a_zone_universal_ssl_settings_details_4xx_response") = ssl_universal_settings_response | universal_ssl_settings_for_a_zone_universal_ssl_settings_details_4xx_response

type ssl_universal_settings_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: universal
  "Whether the API call was successful"
  success: Boolean!
}

type universal {
  "Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no dedicated certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.\\n\\nBy disabling Universal SSL, you understand that the following Cloudflare settings and preferences will result in visitors being unable to visit your domain unless you have uploaded a custom certificate or purchased a dedicated certificate.\\n\\n* HSTS\\n* Always Use HTTPS\\n* Opportunistic Encryption\\n* Onion Routing\\n* Any Page Rules redirecting traffic to HTTPS\\n\\nSimilarly, any HTTP redirect to HTTPS at the origin while the Cloudflare proxy is enabled will result in users being unable to visit your site without a valid certificate at Cloudflare's edge.\\n\\nIf you do not have a valid custom or dedicated certificate at Cloudflare's edge and are unsure if any of the above Cloudflare settings are enabled, or if any HTTP redirects exist at your origin, we advise leaving Universal SSL enabled for your domain."
  enabled: Boolean
}

type universal_ssl_settings_for_a_zone_universal_ssl_settings_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ssl_verification_ssl_verification_details_response @statusCodeTypeName(statusCode: 200, typeName: "ssl_verification_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ssl_verification_ssl_verification_details_4xx_response") = ssl_verification_response_collection | ssl_verification_ssl_verification_details_4xx_response

type ssl_verification_response_collection {
  result: [verification]
}

type verification {
  "Certificate Authority is manually reviewing the order."
  brand_check: Boolean
  "Certificate Pack UUID."
  cert_pack_uuid: String!
  certificate_status: certificate_status!
  signature: schemas_signature
  validation_method: schemas_validation_method
  verification_info: verification_info
  "Status of the required verification information, omitted if verification status is unknown."
  verification_status: Boolean
  verification_type: verification_type
}

"Current status of certificate."
enum certificate_status {
  initializing
  authorizing
  active
  expired
  issuing
  timing_out
  pending_deployment
}

"Certificate's signature algorithm."
enum schemas_signature {
  ECDSAWithSHA256
  SHA1WithRSA
  SHA256WithRSA
}

"Validation method in use for a certificate pack order."
enum schemas_validation_method {
  http
  cname
  txt
}

"Certificate's required verification information."
enum verification_info {
  record_name
  record_value
  http_url
  http_body
  cname
  cname_target
  txt_name
  txt_value
}

"Method of verification."
enum verification_type {
  cname
  meta_tag @enum(value: "\\"meta tag\\"")
}

type ssl_verification_ssl_verification_details_4xx_response {
  result: Void
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_list_waiting_rooms_response @statusCodeTypeName(statusCode: 200, typeName: "waitingroom_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_list_waiting_rooms_4xx_response") = waitingroom_components_schemas_response_collection | waiting_room_list_waiting_rooms_4xx_response

type waitingroom_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [waitingroom]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type waitingroom {
  cookie_attributes: cookie_attributes
  created_on: DateTime
  "Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:\\n1. {{\`waitTimeKnown\`}} Acts like a boolean value that indicates the behavior to take when wait time is not available, for instance when queue_all is **true**. \\n2. {{\`waitTimeFormatted\`}} Estimated wait time for the user. For example, five minutes. Alternatively, you can use: \\n3. {{\`waitTime\`}} Number of minutes of estimated wait for a user.\\n4. {{\`waitTimeHours\`}} Number of hours of estimated wait for a user (\`Math.floor(waitTime/60)\`). \\n5. {{\`waitTimeHourMinutes\`}} Number of minutes above the \`waitTimeHours\` value (\`waitTime%60\`). \\n6. {{\`queueIsFull\`}} Changes to **true** when no more people can be added to the queue.\\n\\nTo view the full list of variables, look at the \`cfWaitingRoom\` object described under the \`json_response_enabled\` property in other Waiting Room API calls."
  custom_page_html: String
  default_template_language: default_template_language
  "A note that you can use to add more details about the waiting room."
  description: String
  "Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If \`true\`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If \`false\`, a user's session cookie will be automatically renewed on every request."
  disable_session_renewal: Boolean
  "The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique."
  host: String
  id: String!
  "Only available for the Waiting Room Advanced subscription. If \`true\`, requests to the waiting room with the header \`Accept: application/json\` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property \`cfWaitingRoom\` which is an object containing the following fields:\\n1. \`inWaitingRoom\`: Boolean indicating if the user is in the waiting room (always **true**).\\n2. \`waitTimeKnown\`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.\\n3. \`waitTime\`: Valid only when \`waitTimeKnown\` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When \`queueingMethod\` is **random**, this is set to \`waitTime50Percentile\`.\\n4. \`waitTime25Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).\\n5. \`waitTime50Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before \`waitTime50Percentile\` and half are expected to be let in after it.\\n6. \`waitTime75Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).\\n7. \`waitTimeFormatted\`: String displaying the \`waitTime\` formatted in English for users. If \`waitTimeKnown\` is **false**, \`waitTimeFormatted\` will display **unavailable**.\\n8. \`queueIsFull\`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.\\n9. \`queueAll\`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.\\n10. \`lastUpdated\`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after \`refreshIntervalSeconds\` past this time. If the user makes a request too soon, it will be ignored and \`lastUpdated\` will not change.\\n11. \`refreshIntervalSeconds\`: Integer indicating the number of seconds after \`lastUpdated\` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the \`queueingMethod\` is \`reject\`, there is no specified refresh time — it will always be **zero**.\\n12. \`queueingMethod\`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.\\n13. \`isFIFOQueue\`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.\\n14. \`isRandomQueue\`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.\\n15. \`isPassthroughQueue\`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when \`queueAll\` is **true** or \`isEventPrequeueing\` is **true** because in all other cases requests will go directly to the origin.\\n16. \`isRejectQueue\`: Boolean indicating if the waiting room uses a reject queue.\\n17. \`isEventActive\`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties \`prequeue_start_time\`, \`event_start_time\`, and \`event_end_time\` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.\\n18. \`isEventPrequeueing\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.\\n19. \`timeUntilEventStart\`: Valid only when \`isEventPrequeueing\` is **true**. Integer indicating the number of minutes until the event starts.\\n20. \`timeUntilEventStartFormatted\`: String displaying the \`timeUntilEventStart\` formatted in English for users. If \`isEventPrequeueing\` is **false**, \`timeUntilEventStartFormatted\` will display **unavailable**.\\n21. \`timeUntilEventEnd\`: Valid only when \`isEventActive\` is **true**. Integer indicating the number of minutes until the event ends.\\n22. \`timeUntilEventEndFormatted\`: String displaying the \`timeUntilEventEnd\` formatted in English for users. If \`isEventActive\` is **false**, \`timeUntilEventEndFormatted\` will display **unavailable**.\\n23. \`shuffleAtEventStart\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.\\n\\nAn example cURL to a waiting room could be:\\n\\n\\tcurl -X GET \\"https://example.com/waitingroom\\" \\\\\\n\\t\\t-H \\"Accept: application/json\\"\\n\\nIf \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **fifo** and no event is active could be:\\n\\n\\t{\\n\\t\\t\\"cfWaitingRoom\\": {\\n\\t\\t\\t\\"inWaitingRoom\\": true,\\n\\t\\t\\t\\"waitTimeKnown\\": true,\\n\\t\\t\\t\\"waitTime\\": 10,\\n\\t\\t\\t\\"waitTime25Percentile\\": 0,\\n\\t\\t\\t\\"waitTime50Percentile\\": 0,\\n\\t\\t\\t\\"waitTime75Percentile\\": 0,\\n\\t\\t\\t\\"waitTimeFormatted\\": \\"10 minutes\\",\\n\\t\\t\\t\\"queueIsFull\\": false,\\n\\t\\t\\t\\"queueAll\\": false,\\n\\t\\t\\t\\"lastUpdated\\": \\"2020-08-03T23:46:00.000Z\\",\\n\\t\\t\\t\\"refreshIntervalSeconds\\": 20,\\n\\t\\t\\t\\"queueingMethod\\": \\"fifo\\",\\n\\t\\t\\t\\"isFIFOQueue\\": true,\\n\\t\\t\\t\\"isRandomQueue\\": false,\\n\\t\\t\\t\\"isPassthroughQueue\\": false,\\n\\t\\t\\t\\"isRejectQueue\\": false,\\n\\t\\t\\t\\"isEventActive\\": false,\\n\\t\\t\\t\\"isEventPrequeueing\\": false,\\n\\t\\t\\t\\"timeUntilEventStart\\": 0,\\n\\t\\t\\t\\"timeUntilEventStartFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"timeUntilEventEnd\\": 0,\\n\\t\\t\\t\\"timeUntilEventEndFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"shuffleAtEventStart\\": false\\n\\t\\t}\\n\\t}\\n\\nIf \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **random** and an event is active could be:\\n\\n\\t{\\n\\t\\t\\"cfWaitingRoom\\": {\\n\\t\\t\\t\\"inWaitingRoom\\": true,\\n\\t\\t\\t\\"waitTimeKnown\\": true,\\n\\t\\t\\t\\"waitTime\\": 10,\\n\\t\\t\\t\\"waitTime25Percentile\\": 5,\\n\\t\\t\\t\\"waitTime50Percentile\\": 10,\\n\\t\\t\\t\\"waitTime75Percentile\\": 15,\\n\\t\\t\\t\\"waitTimeFormatted\\": \\"5 minutes to 15 minutes\\",\\n\\t\\t\\t\\"queueIsFull\\": false,\\n\\t\\t\\t\\"queueAll\\": false,\\n\\t\\t\\t\\"lastUpdated\\": \\"2020-08-03T23:46:00.000Z\\",\\n\\t\\t\\t\\"refreshIntervalSeconds\\": 20,\\n\\t\\t\\t\\"queueingMethod\\": \\"random\\",\\n\\t\\t\\t\\"isFIFOQueue\\": false,\\n\\t\\t\\t\\"isRandomQueue\\": true,\\n\\t\\t\\t\\"isPassthroughQueue\\": false,\\n\\t\\t\\t\\"isRejectQueue\\": false,\\n\\t\\t\\t\\"isEventActive\\": true,\\n\\t\\t\\t\\"isEventPrequeueing\\": false,\\n\\t\\t\\t\\"timeUntilEventStart\\": 0,\\n\\t\\t\\t\\"timeUntilEventStartFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"timeUntilEventEnd\\": 15,\\n\\t\\t\\t\\"timeUntilEventEndFormatted\\": \\"15 minutes\\",\\n\\t\\t\\t\\"shuffleAtEventStart\\": true\\n\\t\\t}\\n\\t}."
  json_response_enabled: Boolean
  modified_on: DateTime
  "A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String
  "Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world."
  new_users_per_minute: PositiveInt
  "An ISO 8601 timestamp that marks when the next event will begin queueing."
  next_event_prequeue_start_time: DateTime
  "An ISO 8601 timestamp that marks when the next event will start."
  next_event_start_time: DateTime
  "Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported."
  path: String
  "If queue_all is \`true\`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable."
  queue_all: Boolean
  queueing_method: queueing_method
  "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route."
  session_duration: PositiveInt
  "Suspends or allows traffic going to the waiting room. If set to \`true\`, the traffic will not go to the waiting room."
  suspended: Boolean
  "Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world."
  total_active_users: PositiveInt
}

"Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position."
type cookie_attributes {
  samesite: query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_samesite
  secure: query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_secure
}

"Configures the SameSite attribute on the waiting room cookie. Value \`auto\` will be translated to \`lax\` or \`none\` depending if **Always Use HTTPS** is enabled. Note that when using value \`none\`, the secure attribute cannot be set to \`never\`."
enum query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_samesite {
  auto
  lax
  none
  strict
}

"Configures the Secure attribute on the waiting room cookie. Value \`always\` indicates that the Secure attribute will be set in the Set-Cookie header, \`never\` indicates that the Secure attribute will not be set, and \`auto\` will set the Secure attribute depending if **Always Use HTTPS** is enabled."
enum query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_secure {
  auto
  always
  never
}

"The language of the default page template. If no default_template_language is provided, then \`en-US\` (English) will be used."
enum default_template_language {
  en_US @enum(value: "\\"en-US\\"")
  es_ES @enum(value: "\\"es-ES\\"")
  de_DE @enum(value: "\\"de-DE\\"")
  fr_FR @enum(value: "\\"fr-FR\\"")
  it_IT @enum(value: "\\"it-IT\\"")
  ja_JP @enum(value: "\\"ja-JP\\"")
  ko_KR @enum(value: "\\"ko-KR\\"")
  pt_BR @enum(value: "\\"pt-BR\\"")
  zh_CN @enum(value: "\\"zh-CN\\"")
  zh_TW @enum(value: "\\"zh-TW\\"")
  nl_NL @enum(value: "\\"nl-NL\\"")
  pl_PL @enum(value: "\\"pl-PL\\"")
  id_ID @enum(value: "\\"id-ID\\"")
  tr_TR @enum(value: "\\"tr-TR\\"")
  ar_EG @enum(value: "\\"ar-EG\\"")
}

"Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if \`queue_all\` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:\\n1. \`fifo\` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.\\n2. \`random\`: Random queue where customers gain access randomly, regardless of arrival time.\\n3. \`passthrough\`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with \`suspended\`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.\\n4. \`reject\`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses \`reject\`, and its events override this with \`fifo\`, \`random\`, or \`passthrough\`. When this queueing method is enabled and neither \`queueAll\` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**."
enum queueing_method {
  fifo
  random
  passthrough
  reject
}

type waiting_room_list_waiting_rooms_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waiting_room_waiting_room_details_response @statusCodeTypeName(statusCode: 200, typeName: "waitingroom_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_waiting_room_details_4xx_response") = waitingroom_components_schemas_single_response | waiting_room_waiting_room_details_4xx_response

type waitingroom_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: waitingroom
  "Whether the API call was successful"
  success: Boolean!
}

type waiting_room_waiting_room_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_list_events_response @statusCodeTypeName(statusCode: 200, typeName: "event_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_list_events_4xx_response") = event_response_collection | waiting_room_list_events_4xx_response

type event_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [event_result]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type event_result {
  created_on: DateTime
  "If set, the event will override the waiting room's \`custom_page_html\` property while it is active. If null, the event will inherit it."
  custom_page_html: String
  "A note that you can use to add more details about the event."
  description: String
  "If set, the event will override the waiting room's \`disable_session_renewal\` property while it is active. If null, the event will inherit it."
  disable_session_renewal: Boolean
  "An ISO 8601 timestamp that marks the end of the event."
  event_end_time: DateTime
  "An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before \`event_end_time\`."
  event_start_time: DateTime
  id: String!
  modified_on: DateTime
  "A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String
  "If set, the event will override the waiting room's \`new_users_per_minute\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`total_active_users\` property is also set."
  new_users_per_minute: PositiveInt
  "An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before \`event_start_time\`."
  prequeue_start_time: DateTime
  "If set, the event will override the waiting room's \`queueing_method\` property while it is active. If null, the event will inherit it."
  queueing_method: String
  "If set, the event will override the waiting room's \`session_duration\` property while it is active. If null, the event will inherit it."
  session_duration: PositiveInt
  "If enabled, users in the prequeue will be shuffled randomly at the \`event_start_time\`. Requires that \`prequeue_start_time\` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the \`queueing_method\` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary."
  shuffle_at_event_start: Boolean
  "Suspends or allows an event. If set to \`true\`, the event is ignored and traffic will be handled based on the waiting room configuration."
  suspended: Boolean
  "If set, the event will override the waiting room's \`total_active_users\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`new_users_per_minute\` property is also set."
  total_active_users: PositiveInt
}

type waiting_room_list_events_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waiting_room_event_details_response @statusCodeTypeName(statusCode: 200, typeName: "event_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_event_details_4xx_response") = event_response | waiting_room_event_details_4xx_response

type event_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: event_result
  "Whether the API call was successful"
  success: Boolean!
}

type waiting_room_event_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_preview_active_event_details_response @statusCodeTypeName(statusCode: 200, typeName: "event_details_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_preview_active_event_details_4xx_response") = event_details_response | waiting_room_preview_active_event_details_4xx_response

type event_details_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: event_details_result
  "Whether the API call was successful"
  success: Boolean!
}

type event_details_result {
  created_on: DateTime
  custom_page_html: String
  "A note that you can use to add more details about the event."
  description: String
  disable_session_renewal: Boolean
  "An ISO 8601 timestamp that marks the end of the event."
  event_end_time: DateTime
  "An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before \`event_end_time\`."
  event_start_time: DateTime
  id: String!
  modified_on: DateTime
  "A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String
  new_users_per_minute: Int
  "An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before \`event_start_time\`."
  prequeue_start_time: DateTime
  queueing_method: String
  session_duration: Int
  "If enabled, users in the prequeue will be shuffled randomly at the \`event_start_time\`. Requires that \`prequeue_start_time\` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the \`queueing_method\` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary."
  shuffle_at_event_start: Boolean
  "Suspends or allows an event. If set to \`true\`, the event is ignored and traffic will be handled based on the waiting room configuration."
  suspended: Boolean
  total_active_users: Int
}

type waiting_room_preview_active_event_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_list_waiting_room_rules_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_list_waiting_room_rules_4xx_response") = schemas_rules_response_collection | waiting_room_list_waiting_room_rules_4xx_response

type schemas_rules_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [rule_result]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type rule_result {
  action: rule_action
  "The description of the rule."
  description: String
  "When set to true, the rule is enabled."
  enabled: Boolean
  "Criteria defining when there is a match for the current rule."
  expression: String
  "The ID of the rule."
  id: String!
  last_updated: DateTime
  "The version of the rule."
  version: String
}

enum rule_action @typescript(type: "\\"bypass_waiting_room\\"") @example(value: "\\"bypass_waiting_room\\"") {
  bypass_waiting_room @enum(value: "\\"bypass_waiting_room\\"")
}

type waiting_room_list_waiting_room_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waiting_room_get_waiting_room_status_response @statusCodeTypeName(statusCode: 200, typeName: "status_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_get_waiting_room_status_4xx_response") = status_response | waiting_room_get_waiting_room_status_4xx_response

type status_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_waiting_room_get_waiting_room_status_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_waiting_room_get_waiting_room_status_oneOf_0_allOf_1_result {
  estimated_queued_users: Int
  estimated_total_active_users: Int
  event_id: String
  max_estimated_time_minutes: Int
  status: waitingroom_components_schemas_status
}

enum waitingroom_components_schemas_status {
  event_prequeueing
  not_queueing
  queueing
}

type waiting_room_get_waiting_room_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union web3_hostname_list_web3_hostnames_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_list_web3_hostnames_4xx_response") = components_schemas_collection_response | web3_hostname_list_web3_hostnames_4xx_response

type components_schemas_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [web3_hostname]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type web3_hostname {
  created_on: DateTime
  "An optional description of the hostname."
  description: web3_hostname_components_schemas_description
  "DNSLink value used if the target is ipfs."
  dnslink: String
  "Identifier"
  id: common_components_schemas_identifier!
  modified_on: DateTime
  "The hostname that will point to the target gateway via CNAME."
  name: web3_hostname_components_schemas_name
  status: web3_hostname_components_schemas_status
  target: components_schemas_target
}

"An optional description of the hostname."
scalar web3_hostname_components_schemas_description @length(min: null, max: 500)

"The hostname that will point to the target gateway via CNAME."
scalar web3_hostname_components_schemas_name @length(min: null, max: 255)

"Status of the hostname's activation."
enum web3_hostname_components_schemas_status {
  active
  pending
  deleting
  error
}

"Target gateway of the hostname."
enum components_schemas_target {
  ethereum
  ipfs
  ipfs_universal_path
  polygon
}

type web3_hostname_list_web3_hostnames_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union web3_hostname_web3_hostname_details_response @statusCodeTypeName(statusCode: 200, typeName: "web3_hostname_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_web3_hostname_details_4xx_response") = web3_hostname_components_schemas_single_response | web3_hostname_web3_hostname_details_4xx_response

type web3_hostname_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: web3_hostname
  "Whether the API call was successful"
  success: Boolean!
}

type web3_hostname_web3_hostname_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union web3_hostname_ipfs_universal_path_gateway_content_list_details_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_details_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_ipfs_universal_path_gateway_content_list_details_4xx_response") = content_list_details_response | web3_hostname_ipfs_universal_path_gateway_content_list_details_4xx_response

type content_list_details_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: content_list_details
  "Whether the API call was successful"
  success: Boolean!
}

type content_list_details {
  action: content_list_action
}

enum content_list_action @typescript(type: "\\"block\\"") @example(value: "\\"block\\"") {
  block @enum(value: "\\"block\\"")
}

type web3_hostname_ipfs_universal_path_gateway_content_list_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_entry_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_4xx_response") = content_list_entry_collection_response | web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_4xx_response

type content_list_entry_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_oneOf_0_allOf_1_result {
  "Content list entries."
  entries: [content_list_entry]
}

"Content list entry to be blocked."
type content_list_entry {
  "CID or content path of content to block."
  content: content_list_entry_content
  created_on: DateTime
  "An optional description of the content list entry."
  description: content_list_entry_description
  "Identifier"
  id: common_components_schemas_identifier!
  modified_on: DateTime
  type: content_list_entry_type
}

"CID or content path of content to block."
scalar content_list_entry_content @length(min: null, max: 500)

"An optional description of the content list entry."
scalar content_list_entry_description @length(min: null, max: 500)

"Type of content list entry to block."
enum content_list_entry_type {
  cid
  content_path
}

type web3_hostname_list_ipfs_universal_path_gateway_content_list_entries_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union web3_hostname_ipfs_universal_path_gateway_content_list_entry_details_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_entry_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_ipfs_universal_path_gateway_content_list_entry_details_4xx_response") = content_list_entry_single_response | web3_hostname_ipfs_universal_path_gateway_content_list_entry_details_4xx_response

type content_list_entry_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: content_list_entry
  "Whether the API call was successful"
  success: Boolean!
}

type web3_hostname_ipfs_universal_path_gateway_content_list_entry_details_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_binding__deprecated_list_bindings_response @statusCodeTypeName(statusCode: 200, typeName: "worker_binding__deprecated_list_bindings_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_binding__deprecated_list_bindings_4xx_response") = worker_binding__deprecated_list_bindings_200_response | worker_binding__deprecated_list_bindings_4xx_response

type worker_binding__deprecated_list_bindings_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [binding]
  "Whether the API call was successful"
  success: Boolean!
}

union binding = kv_namespace_binding | wasm_module_binding

type kv_namespace_binding {
  "A JavaScript variable name for the binding."
  name: String!
  "Namespace identifier tag."
  namespace_id: namespace_identifier!
  type: kv_namespace_const!
}

enum kv_namespace_const @typescript(type: "\\"kv_namespace\\"") @example(value: "\\"kv_namespace\\"") {
  kv_namespace @enum(value: "\\"kv_namespace\\"")
}

type wasm_module_binding {
  "A JavaScript variable name for the binding."
  name: String!
  type: wasm_module_const!
}

enum wasm_module_const @typescript(type: "\\"wasm_module\\"") @example(value: "\\"wasm_module\\"") {
  wasm_module @enum(value: "\\"wasm_module\\"")
}

type worker_binding__deprecated_list_bindings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union api_shield_settings_retrieve_information_about_specific_configuration_properties_response @statusCodeTypeName(statusCode: 200, typeName: "single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_settings_retrieve_information_about_specific_configuration_properties_4xx_response") = single_response | api_shield_settings_retrieve_information_about_specific_configuration_properties_4xx_response

type single_response {
  errors: [JSON]
  messages: [JSON]
  result: configuration
  "Whether the API call was successful"
  success: Boolean!
}

type configuration {
  auth_id_characteristics: [query_api_shield_settings_retrieve_information_about_specific_configuration_properties_oneOf_0_allOf_1_result_auth_id_characteristics_items]
}

type query_api_shield_settings_retrieve_information_about_specific_configuration_properties_oneOf_0_allOf_1_result_auth_id_characteristics_items {
  "The name of the characteristic field, i.e., the header or cookie name."
  name: characteristics_components_schemas_name!
  type: schemas_type!
}

"The name of the characteristic field, i.e., the header or cookie name."
scalar characteristics_components_schemas_name @length(min: null, max: 128)

"The type of characteristic."
enum schemas_type {
  header
  cookie
}

type api_shield_settings_retrieve_information_about_specific_configuration_properties_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_response @statusCodeTypeName(statusCode: 200, typeName: "schema_response_discovery") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_4xx_response") = schema_response_discovery | api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_4xx_response

type schema_response_discovery {
  errors: [JSON]
  messages: [JSON]
  result: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result {
  schemas: [openapi]
  timestamp: String
}

"A OpenAPI 3.0.0 compliant schema."
type openapi {
  info: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_info
  openapi: String
  paths: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths
  servers: [query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_servers_items]
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_info {
  title: String
  version: String
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths {
  _0__Further_paths____: JSON @resolveRootField(field: "... Further paths ...")
  _api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_ @resolveRootField(field: "/api/v1/users/{var1}")
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_ {
  get: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get {
  parameters: [query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items]
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items {
  in: String
  name: String
  required: Boolean
  schema: query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items_schema
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items_schema {
  type: String
}

type query_api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_oneOf_0_allOf_1_result_schemas_items_servers_items {
  url: String
}

type api_shield_endpoint_management_retrieve_api_discovery_results_for_a_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_response @statusCodeTypeName(statusCode: 200, typeName: "collection_response_paginated") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_4xx_response") = collection_response_paginated | api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_4xx_response

type collection_response_paginated {
  errors: [JSON]
  messages: [JSON]
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
  result_info: JSON
}

type api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: JSON
}

union api_shield_endpoint_management_retrieve_information_about_an_operation_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_retrieve_information_about_an_operation_4xx_response") = schemas_single_response | api_shield_endpoint_management_retrieve_information_about_an_operation_4xx_response

type schemas_single_response {
  errors: [JSON]
  messages: [JSON]
  result: api_shield
  "Whether the API call was successful"
  success: Boolean!
}

type api_shield {
  endpoint: endpoint!
  features: features
  "RFC3986-compliant host."
  host: Hostname!
  last_updated: DateTime!
  method: method!
  "The ID that identifies the API operation."
  operation_id: JSON!
}

scalar endpoint @regexp(pattern: "^/.*$") @typescript(type: "string")

type features {
  thresholds: query_api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_oneOf_0_anyOf_0_allOf_0_allOf_1_result_items_allOf_0_allOf_0_features_anyOf_0_thresholds
}

type query_api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_oneOf_0_anyOf_0_allOf_0_allOf_1_result_items_allOf_0_allOf_0_features_anyOf_0_thresholds {
  "The total number of auth-ids seen across this calculation."
  auth_id_tokens: Int
  "The number of data points used for the threshold suggestion calculation."
  data_points: Int
  last_updated: DateTime
  "The p50 quantile of requests (in period_seconds)."
  p50: Int
  "The p90 quantile of requests (in period_seconds)."
  p90: Int
  "The p99 quantile of requests (in period_seconds)."
  p99: Int
  "The period over which this threshold is suggested."
  period_seconds: Int
  "The estimated number of requests covered by these calculations."
  requests: Int
  "The suggested threshold in requests done by the same auth_id or period_seconds."
  suggested_threshold: Int
}

"The HTTP method used to access the endpoint."
enum method {
  GET
  POST
  HEAD
  OPTIONS
  PUT
  DELETE
  CONNECT
  PATCH
  TRACE
}

type api_shield_endpoint_management_retrieve_information_about_an_operation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_response @statusCodeTypeName(statusCode: 200, typeName: "schema_response_with_thresholds") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_4xx_response") = schema_response_with_thresholds | api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_4xx_response

type schema_response_with_thresholds {
  errors: [JSON]
  messages: [JSON]
  result: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result {
  schemas: [openapiwiththresholds]
  timestamp: String
}

"A OpenAPI 3.0.0 compliant schema."
type openapiwiththresholds {
  info: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_info
  openapi: String
  paths: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths
  servers: [query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_servers_items]
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_info {
  title: String
  version: String
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths {
  _0__Further_paths____: JSON @resolveRootField(field: "... Further paths ...")
  _api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_ @resolveRootField(field: "/api/v1/users/{var1}")
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE_ {
  get: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get {
  parameters: [query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items]
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items {
  in: String
  name: String
  required: Boolean
  schema: query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items_schema
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_paths_api_v1_users__LEFT_CURLY_BRACE_var1_RIGHT_CURLY_BRACE__get_parameters_items_schema {
  type: String
}

type query_api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_oneOf_0_allOf_1_result_schemas_items_servers_items {
  url: String
}

type api_shield_endpoint_management_retrieve_operations_and_features_as_open_api_schemas_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_a_zone_list_ip_access_rules_response @statusCodeTypeName(statusCode: 200, typeName: "rule_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_zone_list_ip_access_rules_4xx_response") = rule_collection_response | ip_access_rules_for_a_zone_list_ip_access_rules_4xx_response

type ip_access_rules_for_a_zone_list_ip_access_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waf_rules_list_waf_rules_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rules_list_waf_rules_4xx_response") = rule_response_collection | waf_rules_list_waf_rules_4xx_response

type rule_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [components_schemas_rule]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union components_schemas_rule = Anomaly_detection_WAF_rule | Traditional_deny_WAF_rule | Traditional_allow_WAF_rule

"When triggered, anomaly detection WAF rules contribute to an overall threat score that will determine if a request is considered malicious. You can configure the total scoring threshold through the 'sensitivity' property of the WAF package."
type Anomaly_detection_WAF_rule {
  "The public description of the WAF rule."
  description: String
  group: query_waf_rules_list_waf_rules_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_allOf_0_group
  "The unique identifier of the WAF rule."
  id: rule_components_schemas_identifier_2!
  "The unique identifier of a WAF package."
  package_id: package_components_schemas_identifier!
  "The order in which the individual WAF rule is executed within its rule group."
  priority: String
  "Defines the available modes for the current WAF rule. Applies to anomaly detection WAF rules."
  allowed_modes: [mode_anomaly]
  mode: mode_anomaly
}

"The rule group to which the current WAF rule belongs."
type query_waf_rules_list_waf_rules_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_allOf_0_group {
  "The unique identifier of the rule group."
  id: group_components_schemas_identifier!
  "The name of the rule group."
  name: String
}

"The unique identifier of the WAF rule."
scalar rule_components_schemas_identifier_2 @length(min: null, max: 32)

"When set to \`on\`, the current WAF rule will be used when evaluating the request. Applies to anomaly detection WAF rules."
enum mode_anomaly {
  on
  off
}

"When triggered, traditional WAF rules cause the firewall to immediately act upon the request based on the configuration of the rule. A 'deny' rule will immediately respond to the request based on the configured rule action/mode (for example, 'block') and no other rules will be processed."
type Traditional_deny_WAF_rule {
  "The public description of the WAF rule."
  description: String
  group: query_waf_rules_list_waf_rules_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_allOf_0_group
  "The unique identifier of the WAF rule."
  id: rule_components_schemas_identifier_2!
  "The unique identifier of a WAF package."
  package_id: package_components_schemas_identifier!
  "The order in which the individual WAF rule is executed within its rule group."
  priority: String
  "The list of possible actions of the WAF rule when it is triggered."
  allowed_modes: [mode_deny_traditional]
  default_mode: default_mode
  mode: mode_deny_traditional
}

"The action that the current WAF rule will perform when triggered. Applies to traditional (deny) WAF rules."
enum mode_deny_traditional {
  default
  disable
  simulate
  block
  challenge
}

"The default action/mode of a rule."
enum default_mode {
  disable
  simulate
  block
  challenge
}

"When triggered, traditional WAF rules cause the firewall to immediately act on the request based on the rule configuration. An 'allow' rule will immediately allow the request and no other rules will be processed."
type Traditional_allow_WAF_rule {
  "The public description of the WAF rule."
  description: String
  group: query_waf_rules_list_waf_rules_oneOf_0_allOf_1_result_items_oneOf_0_allOf_0_allOf_0_group
  "The unique identifier of the WAF rule."
  id: rule_components_schemas_identifier_2!
  "The unique identifier of a WAF package."
  package_id: package_components_schemas_identifier!
  "The order in which the individual WAF rule is executed within its rule group."
  priority: String
  "Defines the available modes for the current WAF rule."
  allowed_modes: [mode_allow_traditional]
  mode: mode_allow_traditional
}

"When set to \`on\`, the current rule will be used when evaluating the request. Applies to traditional (allow) WAF rules."
enum mode_allow_traditional {
  on
  off
}

type waf_rules_list_waf_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waf_rules_get_a_waf_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rules_get_a_waf_rule_4xx_response") = rule_response_single | waf_rules_get_a_waf_rule_4xx_response

type waf_rules_get_a_waf_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union managed_transforms_list_managed_transforms_response @statusCodeTypeName(statusCode: 200, typeName: "managed_transforms_list_managed_transforms_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "managed_transforms_list_managed_transforms_4xx_response") = managed_transforms_list_managed_transforms_200_response | managed_transforms_list_managed_transforms_4xx_response

type managed_transforms_list_managed_transforms_200_response {
  managed_request_headers: [request_model]
  managed_response_headers: [request_model]
}

type request_model {
  "When true, the Managed Transform is enabled."
  enabled: Boolean
  "Human-readable identifier of the Managed Transform."
  id: String
}

type managed_transforms_list_managed_transforms_4xx_response {
  managed_request_headers: [request_model]
  managed_response_headers: [request_model]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_shield_get_page_shield_settings_response @statusCodeTypeName(statusCode: 200, typeName: "page_shield_get_page_shield_settings_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_get_page_shield_settings_4xx_response") = page_shield_get_page_shield_settings_200_response | page_shield_get_page_shield_settings_4xx_response

type page_shield_get_page_shield_settings_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: get_zone_settings_response
  "Whether the API call was successful"
  success: Boolean!
}

type get_zone_settings_response {
  "When true, indicates that Page Shield is enabled."
  enabled: Boolean
  "The timestamp of when Page Shield was last updated."
  updated_at: DateTime
  "When true, CSP reports will be sent to https://csp-reporting.cloudflare.com/cdn-cgi/script_monitor/report"
  use_cloudflare_reporting_endpoint: Boolean
  "When true, the paths associated with connections URLs will also be analyzed."
  use_connection_url_path: Boolean
}

type page_shield_get_page_shield_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_shield_list_page_shield_connections_response @statusCodeTypeName(statusCode: 200, typeName: "list_zone_connections_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_list_page_shield_connections_4xx_response") = list_zone_connections_response | page_shield_list_page_shield_connections_4xx_response

type list_zone_connections_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [connection]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type connection {
  added_at: String
  domain_reported_malicious: JSON
  first_page_url: String
  first_seen_at: String
  host: String
  id: String
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
}

type page_shield_list_page_shield_connections_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union page_shield_get_a_page_shield_connection_response @statusCodeTypeName(statusCode: 200, typeName: "get_zone_connection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_get_a_page_shield_connection_4xx_response") = get_zone_connection_response | page_shield_get_a_page_shield_connection_4xx_response

type get_zone_connection_response {
  added_at: String
  domain_reported_malicious: JSON
  first_page_url: String
  first_seen_at: String
  host: String
  id: String
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
}

type page_shield_get_a_page_shield_connection_4xx_response {
  added_at: String
  domain_reported_malicious: JSON
  first_page_url: String
  first_seen_at: String
  host: String
  id: String
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"The ID of the resource."
scalar script_monitor_components_schemas_id @length(min: 32, max: 32)

union page_shield_list_page_shield_scripts_response @statusCodeTypeName(statusCode: 200, typeName: "list_zone_scripts_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_list_page_shield_scripts_4xx_response") = list_zone_scripts_response | page_shield_list_page_shield_scripts_4xx_response

type list_zone_scripts_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [script]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type script {
  added_at: String
  domain_reported_malicious: JSON
  fetched_at: String
  first_page_url: String
  first_seen_at: String
  hash: String
  host: String
  id: String
  js_integrity_score: Int
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
}

type page_shield_list_page_shield_scripts_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union page_shield_get_a_page_shield_script_response @statusCodeTypeName(statusCode: 200, typeName: "get_zone_script_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_get_a_page_shield_script_4xx_response") = get_zone_script_response | page_shield_get_a_page_shield_script_4xx_response

type get_zone_script_response {
  added_at: String
  domain_reported_malicious: JSON
  fetched_at: String
  first_page_url: String
  first_seen_at: String
  hash: String
  host: String
  id: String
  js_integrity_score: Int
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
  versions: [components_schemas_version]
}

"The version of the analyzed script."
type components_schemas_version {
  "The timestamp of when the script was last fetched."
  fetched_at: String
  "The computed hash of the analyzed script."
  hash: hash
  "The integrity score of the JavaScript content."
  js_integrity_score: PositiveInt
}

"The computed hash of the analyzed script."
scalar hash @length(min: 64, max: 64)

type page_shield_get_a_page_shield_script_4xx_response {
  added_at: String
  domain_reported_malicious: JSON
  fetched_at: String
  first_page_url: String
  first_seen_at: String
  hash: String
  host: String
  id: String
  js_integrity_score: Int
  last_seen_at: String
  page_urls: [String]
  url: String
  url_contains_cdn_cgi_path: JSON
  versions: [components_schemas_version]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_list_zone_rulesets_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_list_zone_rulesets_4xx_response") = rulesets_response | zone_rulesets_list_zone_rulesets_4xx_response

type zone_rulesets_list_zone_rulesets_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_error_responses_get_custom_error_responses_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_ruleset") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_error_responses_get_custom_error_responses_4xx_response") = components_schemas_ruleset | custom_error_responses_get_custom_error_responses_4xx_response

type components_schemas_ruleset {
  description: JSON
  id: String
  kind: String
  name: String
  phase: String
  "The rules in the ruleset."
  rules: [custom_error_responses_components_schemas_rule]
}

type custom_error_responses_components_schemas_rule {
  action: String
  action_parameters: action_parameters_serve_error
  description: String
  expression: String
  id: String
  version: String
}

"The action parameters for the serve_error action."
type action_parameters_serve_error {
  "The new content for the response error."
  content: String
  "The content-type of the response error."
  content_type: String
  "The HTTP status code of the response error."
  status_code: Float
}

type custom_error_responses_get_custom_error_responses_4xx_response {
  description: JSON
  id: String
  kind: String
  name: String
  phase: String
  "The rules in the ruleset."
  rules: [custom_error_responses_components_schemas_rule]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union transform_rules_list_transform_rules_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_ruleset") @statusCodeTypeName(statusCode: "4xx", typeName: "transform_rules_list_transform_rules_4xx_response") = schemas_ruleset | transform_rules_list_transform_rules_4xx_response

type schemas_ruleset {
  description: JSON
  id: String
  kind: String
  name: String
  phase: String
  "The rules in the ruleset."
  rules: [transform_rules_components_schemas_rule]
}

type transform_rules_components_schemas_rule {
  action: String
  action_parameters: action_parameters_rewrite
  description: String
  expression: String
  id: String
  version: String
}

"The configuration parameters for the rewrite action."
type action_parameters_rewrite {
  uri: query_transform_rules_list_transform_rules_oneOf_0_rules_items_action_parameters_uri
}

"The URI rewrite configuration to rewrite the URI path, the query string, or both."
type query_transform_rules_list_transform_rules_oneOf_0_rules_items_action_parameters_uri {
  "The new URI path sent to the origin."
  path: JSON
  "The new query string sent to the origin."
  query: JSON
}

type transform_rules_list_transform_rules_4xx_response {
  description: JSON
  id: String
  kind: String
  name: String
  phase: String
  "The rules in the ruleset."
  rules: [transform_rules_components_schemas_rule]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"The phase where the ruleset is executed."
enum schemas_phase {
  http_request_transform
  http_request_late_transform
  http_response_headers_transform
}

union zone_rulesets_get_a_zone_entry_point_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_get_a_zone_entry_point_ruleset_4xx_response") = ruleset_response | zone_rulesets_get_a_zone_entry_point_ruleset_4xx_response

type zone_rulesets_get_a_zone_entry_point_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response") = rulesets_response | zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response

type zone_rulesets_list_a_zone_entry_point_ruleset_SINGLE_QUOTE__s_versions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_get_a_zone_entry_point_ruleset_version_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_get_a_zone_entry_point_ruleset_version_4xx_response") = ruleset_response | zone_rulesets_get_a_zone_entry_point_ruleset_version_4xx_response

type zone_rulesets_get_a_zone_entry_point_ruleset_version_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_get_a_zone_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_get_a_zone_ruleset_4xx_response") = ruleset_response | zone_rulesets_get_a_zone_ruleset_4xx_response

type zone_rulesets_get_a_zone_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions_response @statusCodeTypeName(statusCode: 200, typeName: "rulesets_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions_4xx_response") = rulesets_response | zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions_4xx_response

type zone_rulesets_list_a_zone_ruleset_SINGLE_QUOTE__s_versions_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_get_a_zone_ruleset_version_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_get_a_zone_ruleset_version_4xx_response") = ruleset_response | zone_rulesets_get_a_zone_ruleset_version_4xx_response

type zone_rulesets_get_a_zone_ruleset_version_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union url_normalization_get_url_normalization_settings_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_model") @statusCodeTypeName(statusCode: "4xx", typeName: "url_normalization_get_url_normalization_settings_4xx_response") = schemas_response_model | url_normalization_get_url_normalization_settings_4xx_response

type schemas_response_model {
  "The scope of the URL normalization."
  scope: String
  "The type of URL normalization performed by Cloudflare."
  type: String
}

type url_normalization_get_url_normalization_settings_4xx_response {
  "The scope of the URL normalization."
  scope: String
  "The type of URL normalization performed by Cloudflare."
  type: String
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_filters__deprecated_list_filters_response @statusCodeTypeName(statusCode: 200, typeName: "filter_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_filters__deprecated_list_filters_4xx_response") = filter_response_collection | worker_filters__deprecated_list_filters_4xx_response

type filter_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [filters]
  "Whether the API call was successful"
  success: Boolean!
}

type filters {
  enabled: Boolean!
  "Identifier"
  id: common_components_schemas_identifier!
  pattern: String!
}

type worker_filters__deprecated_list_filters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_routes_list_routes_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_collection2") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_routes_list_routes_4xx_response") = route_response_collection2 | worker_routes_list_routes_4xx_response

type route_response_collection2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [routes]
  "Whether the API call was successful"
  success: Boolean!
}

type routes {
  "Identifier"
  id: common_components_schemas_identifier!
  pattern: String!
  script: schemas_script_name!
}

scalar schemas_script_name @regexp(pattern: "^[a-z0-9_][a-z0-9-_]*$") @typescript(type: "string")

type worker_routes_list_routes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_routes_get_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single2") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_routes_get_route_4xx_response") = route_response_single2 | worker_routes_get_route_4xx_response

type route_response_single2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: routes
  "Whether the API call was successful"
  success: Boolean!
}

type worker_routes_get_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_aggregate_analytics_get_current_aggregated_analytics_response @statusCodeTypeName(statusCode: 200, typeName: "analytics_aggregate_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_aggregate_analytics_get_current_aggregated_analytics_4xx_response") = analytics_aggregate_components_schemas_response_collection | spectrum_aggregate_analytics_get_current_aggregated_analytics_4xx_response

type analytics_aggregate_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
}

type spectrum_aggregate_analytics_get_current_aggregated_analytics_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_analytics__by_time_get_analytics_by_time_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_analytics__by_time_get_analytics_by_time_4xx_response") = api_response_single | spectrum_analytics__by_time_get_analytics_by_time_4xx_response

type spectrum_analytics__by_time_get_analytics_by_time_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_analytics__summary_get_analytics_summary_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_analytics__summary_get_analytics_summary_4xx_response") = api_response_single | spectrum_analytics__summary_get_analytics_summary_4xx_response

type spectrum_analytics__summary_get_analytics_summary_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_applications_list_spectrum_applications_response @statusCodeTypeName(statusCode: 200, typeName: "app_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_applications_list_spectrum_applications_4xx_response") = app_components_schemas_response_collection | spectrum_applications_list_spectrum_applications_4xx_response

type app_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type spectrum_applications_list_spectrum_applications_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union spectrum_applications_get_spectrum_application_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_applications_get_spectrum_application_configuration_4xx_response") = schemas_response_single | spectrum_applications_get_spectrum_application_configuration_4xx_response

type spectrum_applications_get_spectrum_application_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Application identifier."
scalar app_id @length(min: null, max: 32)

type Mutation {
  "Remove an account as a member of a particular address map."
  ip_address_management_address_maps_remove_an_account_membership_from_an_address_map(
    "Identifier"
    account_identifier1: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_remove_an_account_membership_from_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier1}/addressing/address_maps/{args.address_map_identifier}/accounts/{args.account_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Add an account as a member of a particular address map."
  ip_address_management_address_maps_add_an_account_membership_to_an_address_map(
    "Identifier"
    account_identifier1: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_add_an_account_membership_to_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier1}/addressing/address_maps/{args.address_map_identifier}/accounts/{args.account_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new address map under the account."
  ip_address_management_address_maps_create_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: ip_address_management_address_maps_create_address_map_request_Input
  ): ip_address_management_address_maps_create_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a particular address map owned by the account."
  ip_address_management_address_maps_delete_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_delete_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify the description or default SNI for an address map owned by the account."
  ip_address_management_address_maps_update_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    input: ip_address_management_address_maps_update_address_map_request_Input
  ): ip_address_management_address_maps_update_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Remove an IP from a particular address map."
  ip_address_management_address_maps_remove_an_ip_from_an_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "An IPv4 or IPv6 address."
    ip_address: String!
  ): ip_address_management_address_maps_remove_an_ip_from_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}/ips/{args.ip_address}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Add an IP from a prefix owned by the account to a particular address map."
  ip_address_management_address_maps_add_an_ip_to_an_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "An IPv4 or IPv6 address."
    ip_address: String!
  ): ip_address_management_address_maps_add_an_ip_to_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}/ips/{args.ip_address}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Remove a zone as a member of a particular address map."
  ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}/zones/{args.zone_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Add a zone as a member of a particular address map."
  ip_address_management_address_maps_add_a_zone_membership_to_an_address_map(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    address_map_identifier: common_components_schemas_identifier
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): ip_address_management_address_maps_add_a_zone_membership_to_an_address_map_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/address_maps/{args.address_map_identifier}/zones/{args.zone_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Submit LOA document (pdf format) under the account."
  ip_address_management_prefixes_upload_loa_document(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: ip_address_management_prefixes_upload_loa_document_request_Input
  ): ip_address_management_prefixes_upload_loa_document_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/loa_documents", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Add a prefix under the account."
  ip_address_management_prefixes_add_prefix(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: ip_address_management_prefixes_add_prefix_request_Input
  ): ip_address_management_prefixes_add_prefix_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an unapproved prefix owned by the account."
  ip_address_management_prefixes_delete_prefix(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
  ): ip_address_management_prefixes_delete_prefix_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify the description for a prefix owned by the account."
  ip_address_management_prefixes_update_prefix_description(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
    input: ip_address_management_prefixes_update_prefix_description_request_Input
  ): ip_address_management_prefixes_update_prefix_description_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Advertise or withdraw BGP route for a prefix."
  ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
    input: ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_request_Input
  ): ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}/bgp/status", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new account delegation for a given IP prefix."
  ip_address_management_prefix_delegation_create_prefix_delegation(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
    input: ip_address_management_prefix_delegation_create_prefix_delegation_request_Input
  ): ip_address_management_prefix_delegation_create_prefix_delegation_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}/delegations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an account delegation for a given IP prefix."
  ip_address_management_prefix_delegation_delete_prefix_delegation(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    prefix_identifier: common_components_schemas_identifier
    "Delegation identifier tag."
    delegation_identifier: delegation_identifier
  ): ip_address_management_prefix_delegation_delete_prefix_delegation_response @httpOperation(path: "/accounts/{args.account_identifier}/addressing/prefixes/{args.prefix_identifier}/delegations/{args.delegation_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create a Cloudflare Tunnel in an account."
  cloudflare_tunnel_create_cloudflare_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: cloudflare_tunnel_create_cloudflare_tunnel_request_Input
  ): cloudflare_tunnel_create_cloudflare_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Cloudflare Tunnel from an account."
  cloudflare_tunnel_delete_cloudflare_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: JSON
  ): cloudflare_tunnel_delete_cloudflare_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a Cloudflare Tunnel in an account."
  cloudflare_tunnel_update_cloudflare_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: cloudflare_tunnel_update_cloudflare_tunnel_request_Input
  ): cloudflare_tunnel_update_cloudflare_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Add or update a configuration for a cloudflared tunnel."
  cloudflare_tunnel_configuration_put_configuration(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: cloudflare_tunnel_configuration_put_configuration_request_Input
  ): cloudflare_tunnel_configuration_put_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}/configurations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Remove stale connection resources from a Cloudflare Tunnel."
  cloudflare_tunnel_clean_up_cloudflare_tunnel_connections(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: JSON
  ): cloudflare_tunnel_clean_up_cloudflare_tunnel_connections_response @httpOperation(path: "/accounts/{args.account_identifier}/cfd_tunnel/{args.tunnel_id}/connections", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the configuration of an existing custom page."
  custom_pages_for_an_account_update_a_custom_page(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: custom_pages_components_schemas_identifier_2
    input: custom_pages_for_an_account_update_a_custom_page_request_Input
  ): custom_pages_for_an_account_update_a_custom_page_response @httpOperation(path: "/accounts/{args.account_identifier}/custom_pages/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Run traceroutes from Cloudflare colos."
  diagnostics_traceroute(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: diagnostics_traceroute_request_Input
  ): diagnostics_traceroute_response @httpOperation(path: "/accounts/{args.account_identifier}/diagnostics/traceroute", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Validates whether this pattern is a valid regular expression. Rejects it if the regular expression is too complex or can match an unbounded-length string. Your regex will be rejected if it uses the Kleene Star -- be sure to bound the maximum number of characters that can be matched."
  dlp_pattern_validation_validate_pattern(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: validate_pattern_Input
  ): dlp_pattern_validation_validate_pattern_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/patterns/validate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a set of DLP custom profiles."
  dlp_profiles_create_custom_profiles(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: create_custom_profiles_Input
  ): dlp_profiles_create_custom_profiles_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/custom", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a DLP custom profile."
  dlp_profiles_delete_custom_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
  ): dlp_profiles_delete_custom_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/custom/{args.profile_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a DLP custom profile."
  dlp_profiles_update_custom_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
    input: Update_custom_profile_Input
  ): dlp_profiles_update_custom_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/custom/{args.profile_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates a DLP predefined profile. Only supports enabling/disabling entries."
  dlp_profiles_update_predefined_profile(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The ID for this profile"
    profile_id: String!
    input: Update_predefined_profile_Input
  ): dlp_profiles_update_predefined_profile_response @httpOperation(path: "/accounts/{args.account_identifier}/dlp/profiles/predefined/{args.profile_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a configured DNS Firewall Cluster."
  dns_firewall_create_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: dns_firewall_create_dns_firewall_cluster_request_Input
  ): dns_firewall_create_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured DNS Firewall Cluster."
  dns_firewall_delete_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall_delete_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify a DNS Firewall Cluster configuration."
  dns_firewall_update_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: schemas_dns_firewall_Input
  ): dns_firewall_update_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/dns_firewall/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a destination address to forward your emails to. Destination addresses need to be verified before they can be used."
  email_routing_destination_addresses_create_a_destination_address(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: create_destination_address_properties_Input
  ): email_routing_destination_addresses_create_a_destination_address_response @httpOperation(path: "/accounts/{args.account_identifier}/email/routing/addresses", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a specific destination address."
  email_routing_destination_addresses_delete_destination_address(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Destination address identifier."
    destination_address_identifier: destination_address_identifier
  ): email_routing_destination_addresses_delete_destination_address_response @httpOperation(path: "/accounts/{args.account_identifier}/email/routing/addresses/{args.destination_address_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a new IP Access rule for an account. The rule will apply to all zones in the account.\\n\\nNote: To create an IP Access rule that applies to a single zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints."
  ip_access_rules_for_an_account_create_an_ip_access_rule(account_identifier: JSON!, input: ip_access_rules_for_an_account_create_an_ip_access_rule_request_Input): ip_access_rules_for_an_account_create_an_ip_access_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/firewall/access_rules/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing IP Access rule defined at the account level.\\n\\nNote: This operation will affect all zones in the account."
  ip_access_rules_for_an_account_delete_an_ip_access_rule(account_identifier: JSON!, identifier: JSON!): ip_access_rules_for_an_account_delete_an_ip_access_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an IP Access rule defined at the account level.\\n\\nNote: This operation will affect all zones in the account."
  ip_access_rules_for_an_account_update_an_ip_access_rule(account_identifier: JSON!, identifier: JSON!, input: schemas_rule_Input): ip_access_rules_for_an_account_update_an_ip_access_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Upload an image via URL with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request."
  cloudflare_images_upload_an_image_via_url(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    input: image_basic_upload_via_url_Input
  ): cloudflare_images_upload_an_image_via_url_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images."
  cloudflare_images_create_authenticated_direct_upload_url(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    input: schemas_direct_upload_request_Input
  ): cloudflare_images_create_authenticated_direct_upload_url_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/direct_upload", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Specify variants that allow you to resize images for different use cases."
  cloudflare_images_variants_create_a_variant(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: variant_generation_request_Input
  ): cloudflare_images_variants_create_a_variant_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/variants", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deleting a variant purges the cache for all images associated with the variant."
  cloudflare_images_variants_delete_a_variant(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: variants_components_schemas_identifier!
  ): cloudflare_images_variants_delete_a_variant_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/variants/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updating a variant purges the cache for all images associated with the variant."
  cloudflare_images_variants_update_a_variant(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: variants_components_schemas_identifier!
    input: variant_patch_request_Input
  ): cloudflare_images_variants_update_a_variant_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/variants/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache."
  cloudflare_images_delete_image(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    "Image unique identifier."
    identifier: images_components_schemas_identifier
  ): cloudflare_images_delete_image_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update image access control. On access control change, all copies of the image are purged from cache."
  cloudflare_images_update_image(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    "Image unique identifier."
    identifier: images_components_schemas_identifier
    input: image_patch_request_Input
  ): cloudflare_images_update_image_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v1/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the \`draft: true\` property is not present."
  cloudflare_images_create_authenticated_direct_upload_url_v_2(
    "Account identifier tag."
    account_identifier: images_components_schemas_account_identifier
    input: direct_upload_request_v2_Input
  ): cloudflare_images_create_authenticated_direct_upload_url_v_2_response @httpOperation(path: "/accounts/{args.account_identifier}/images/v2/direct_upload", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create Miscategorization"
  miscategorization_create_miscategorization(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: miscategorization_Input
  ): miscategorization_create_miscategorization_response @httpOperation(path: "/accounts/{args.account_identifier}/intel/miscategorization", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a configured monitor."
  account_load_balancer_monitors_create_monitor(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: account_load_balancer_monitors_create_monitor_request_Input
  ): account_load_balancer_monitors_create_monitor_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured monitor."
  account_load_balancer_monitors_delete_monitor(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_monitors_delete_monitor_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Apply changes to an existing monitor, overwriting the supplied properties."
  account_load_balancer_monitors_patch_monitor(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_monitors_patch_monitor_request_Input
  ): account_load_balancer_monitors_patch_monitor_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Modify a configured monitor."
  account_load_balancer_monitors_update_monitor(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_monitors_update_monitor_request_Input
  ): account_load_balancer_monitors_update_monitor_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results."
  account_load_balancer_monitors_preview_monitor(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_monitors_preview_monitor_request_Input
  ): account_load_balancer_monitors_preview_monitor_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/monitors/{args.identifier}/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending \`name\`. Returns the list of affected pools. Supports the standard pagination query parameters, either \`limit\`/\`offset\` or \`per_page\`/\`page\`."
  account_load_balancer_pools_patch_pools(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: account_load_balancer_pools_patch_pools_request_Input
  ): account_load_balancer_pools_patch_pools_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new pool."
  account_load_balancer_pools_create_pool(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: account_load_balancer_pools_create_pool_request_Input
  ): account_load_balancer_pools_create_pool_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured pool."
  account_load_balancer_pools_delete_pool(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): account_load_balancer_pools_delete_pool_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Apply changes to an existing pool, overwriting the supplied properties."
  account_load_balancer_pools_patch_pool(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_pools_patch_pool_request_Input
  ): account_load_balancer_pools_patch_pool_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Modify a configured pool."
  account_load_balancer_pools_update_pool(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_pools_update_pool_request_Input
  ): account_load_balancer_pools_update_pool_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results."
  account_load_balancer_pools_preview_pool(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
    input: account_load_balancer_pools_preview_pool_request_Input
  ): account_load_balancer_pools_preview_pool_response @httpOperation(path: "/accounts/{args.account_identifier}/load_balancers/pools/{args.identifier}/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates multiple interconnects associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_interconnects_update_multiple_interconnects(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_interconnects_update_multiple_interconnects_request_Input
  ): magic_interconnects_update_multiple_interconnects_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/cf_interconnects", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates a specific interconnect associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_interconnects_update_interconnect(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
    input: components_schemas_tunnel_update_request_Input
  ): magic_interconnects_update_interconnect_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/cf_interconnects/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates new GRE tunnels. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_gre_tunnels_create_gre_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_gre_tunnels_create_gre_tunnels_request_Input
  ): magic_gre_tunnels_create_gre_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates multiple GRE tunnels. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_gre_tunnels_update_multiple_gre_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_gre_tunnels_update_multiple_gre_tunnels_request_Input
  ): magic_gre_tunnels_update_multiple_gre_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Disables and removes a specific static GRE tunnel. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_gre_tunnels_delete_gre_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_gre_tunnels_delete_gre_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a specific GRE tunnel. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_gre_tunnels_update_gre_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
    input: tunnel_update_request_Input
  ): magic_gre_tunnels_update_gre_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/gre_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates new IPsec tunnels associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_i_psec_tunnels_create_i_psec_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_i_psec_tunnels_create_i_psec_tunnels_request_Input
  ): magic_i_psec_tunnels_create_i_psec_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update multiple IPsec tunnels associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_i_psec_tunnels_update_multiple_i_psec_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_i_psec_tunnels_update_multiple_i_psec_tunnels_request_Input
  ): magic_i_psec_tunnels_update_multiple_i_psec_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Disables and removes a specific static IPsec Tunnel associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_i_psec_tunnels_delete_i_psec_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_i_psec_tunnels_delete_i_psec_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a specific IPsec tunnel associated with an account. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes."
  magic_i_psec_tunnels_update_i_psec_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
    input: schemas_tunnel_update_request_Input
  ): magic_i_psec_tunnels_update_i_psec_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels/{args.tunnel_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use \`?validate_only=true\` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place."
  magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    tunnel_identifier: common_components_schemas_identifier
  ): magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/ipsec_tunnels/{args.tunnel_identifier}/psk_generate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a new Magic static route. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes."
  magic_static_routes_create_routes(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: magic_static_routes_create_routes_request_Input
  ): magic_static_routes_create_routes_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update multiple Magic static routes. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes. Only fields for a route that need to be changed need be provided."
  magic_static_routes_update_many_routes(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: route_update_many_request_Input
  ): magic_static_routes_update_many_routes_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Disable and remove a specific Magic static route."
  magic_static_routes_delete_route(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    route_identifier: common_components_schemas_identifier
  ): magic_static_routes_delete_route_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes/{args.route_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a specific Magic static route. Use \`?validate_only=true\` as an optional query parameter to run validation only without persisting changes."
  magic_static_routes_update_route(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    route_identifier: common_components_schemas_identifier
    input: route_update_request_Input
  ): magic_static_routes_update_route_response @httpOperation(path: "/accounts/{args.account_identifier}/magic/routes/{args.route_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Add a user to the list of members for this account."
  account_members_add_member(account_identifier: JSON!, input: create_Input): account_members_add_member_response @httpOperation(path: "/accounts/{args.account_identifier}/members", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Remove a member from an account."
  account_members_remove_member(account_identifier: JSON!, identifier: JSON!): account_members_remove_member_response @httpOperation(path: "/accounts/{args.account_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify an account member."
  account_members_update_member(account_identifier: JSON!, identifier: JSON!, input: schemas_member_Input): account_members_update_member_response @httpOperation(path: "/accounts/{args.account_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete an existing network monitoring configuration."
  magic_network_monitoring_configuration_delete_account_configuration(account_identifier: String!): magic_network_monitoring_configuration_delete_account_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update fields in an existing network monitoring configuration."
  magic_network_monitoring_configuration_update_account_configuration_fields(account_identifier: String!): magic_network_monitoring_configuration_update_account_configuration_fields_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new network monitoring configuration."
  magic_network_monitoring_configuration_create_account_configuration(account_identifier: String!): magic_network_monitoring_configuration_create_account_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update an existing network monitoring configuration, requires the entire configuration to be updated at once."
  magic_network_monitoring_configuration_update_an_entire_account_configuration(account_identifier: String!): magic_network_monitoring_configuration_update_an_entire_account_configuration_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/config", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create network monitoring rules for account."
  magic_network_monitoring_rules_create_rules(account_identifier: String!): [magic_network_monitoring_rules_create_rules_response] @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update network monitoring rules for account."
  magic_network_monitoring_rules_update_rules(account_identifier: String!): [magic_network_monitoring_rules_update_rules_response] @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete a network monitoring rule for account."
  magic_network_monitoring_rules_delete_rule(account_identifier: String!, rule_identifier: String!): magic_network_monitoring_rules_delete_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a network monitoring rule for account."
  magic_network_monitoring_rules_update_rule(account_identifier: String!, rule_identifier: String!): magic_network_monitoring_rules_update_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update advertisement for rule."
  magic_network_monitoring_rules_update_advertisement_for_rule(account_identifier: String!, rule_identifier: String!): magic_network_monitoring_rules_update_advertisement_for_rule_response @httpOperation(path: "/accounts/{args.account_identifier}/mnm/rules/{args.rule_identifier}/advertisement", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Make a new project."
  pages_project_create_project(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: projects_Input
  ): pages_project_create_project_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Destroy a project by name."
  pages_project_delete_project(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
  ): pages_project_delete_project_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Set new attributes for an existing project. Modify environment variables. To delete an environment variable, set the key to null."
  pages_project_update_project(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    input: project_patch_Input
  ): pages_project_update_project_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Start a new deployment from production. The repo/account must have been authorized through the Pages UI dash before."
  pages_deployment_create_deployment(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
  ): pages_deployment_create_deployment_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Destroy a deployment."
  pages_deployment_delete_deployment(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
  ): pages_deployment_delete_deployment_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Retry a previous deployment."
  pages_deployment_retry_deployment(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
  ): pages_deployment_retry_deployment_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}/retry", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Rollback the production deployment to a previous deploy. You can only rollback to succesful builds on production."
  pages_deployment_rollback_deployment(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    "Identifier"
    deployment_identifier: common_components_schemas_identifier
  ): pages_deployment_rollback_deployment_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/deployments/{args.deployment_identifier}/rollback", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Add a new domain for the Pages project."
  pages_domains_add_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    input: domains_post_Input
  ): pages_domains_add_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/domains", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a domain."
  pages_domains_delete_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    domain_name: domain_name!
  ): pages_domains_delete_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/domains/{args.domain_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Retry the validation status of a single domain."
  pages_domains_patch_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    project_name: project_name!
    domain_name: domain_name!
  ): pages_domains_patch_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/pages/projects/{args.project_name}/domains/{args.domain_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create new PCAP request for account."
  magic_pcap_collection_create_pcap_request(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: pcaps_request_pcap_Input
  ): magic_pcap_collection_create_pcap_request_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Adds an AWS or GCP bucket to use with full packet captures."
  magic_pcap_collection_add_buckets_for_full_packet_captures(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: pcaps_ownership_request_Input
  ): magic_pcap_collection_add_buckets_for_full_packet_captures_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/ownership", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Validates buckets added to the packet captures API."
  magic_pcap_collection_validate_buckets_for_full_packet_captures(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: pcaps_ownership_validate_request_Input
  ): magic_pcap_collection_validate_buckets_for_full_packet_captures_response @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/ownership/validate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes buckets added to the packet captures API."
  magic_pcap_collection_delete_buckets_for_full_packet_captures(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/pcaps/ownership/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a new R2 bucket."
  r_2_bucket_create_bucket(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: String
  ): r_2_bucket_create_bucket_response @httpOperation(path: "/accounts/{args.account_identifier}/r2/buckets", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing R2 bucket."
  r_2_bucket_delete_bucket(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    bucket_name: bucket_name!
  ): r_2_bucket_delete_bucket_response @httpOperation(path: "/accounts/{args.account_identifier}/r2/buckets/{args.bucket_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create Railgun"
  account_railguns_create_railgun(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: account_railguns_create_railgun_request_Input
  ): account_railguns_create_railgun_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Disable and delete a Railgun. This will immediately disable the Railgun for any connected zones."
  account_railguns_delete_a_railgun(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): account_railguns_delete_a_railgun_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a Railgun."
  account_railguns_update_railgun(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
    input: schemas_railgun_Input
  ): account_railguns_update_railgun_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Associates a zone to the Railgun."
  railgun_connections_create_connection(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    railgun_identifier: railgun_components_schemas_identifier
    input: connection_single_request_Input
  ): railgun_connections_create_connection_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.railgun_identifier}/connections", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Disable and remove the connection to a zone."
  railgun_connections_delete_connection(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    railgun_identifier: railgun_components_schemas_identifier
    "Connection identifier tag."
    identifier: connection_components_schemas_identifier
  ): railgun_connections_delete_connection_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.railgun_identifier}/connections/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Enable or disable a connection."
  railgun_connections_update_connection(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    railgun_identifier: railgun_components_schemas_identifier
    "Connection identifier tag."
    identifier: connection_components_schemas_identifier
    input: schemas_connection_Input
  ): railgun_connections_update_connection_response @httpOperation(path: "/accounts/{args.account_identifier}/railguns/{args.railgun_identifier}/connections/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "List domains handled by Registrar."
  registrar_domains_list_domains(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: registrar_domains_list_domains_request_Input
  ): registrar_domains_list_domains_response @httpOperation(path: "/accounts/{args.account_identifier}/registrar/domains", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update individual domain."
  registrar_domains_update_domain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Domain name."
    domain_name: String!
    input: registrar_domains_update_domain_request_Input
  ): registrar_domains_update_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/registrar/domains/{args.domain_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new list of the specified type."
  lists_create_a_list(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: lists_create_a_list_request_Input
  ): lists_create_a_list_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a specific list and all its items."
  lists_delete_a_list(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
  ): lists_delete_a_list_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the description of a list."
  lists_update_a_list(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
    input: lists_update_a_list_request_Input
  ): lists_update_a_list_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Removes one or more items from a list.\\n\\nThis operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`."
  lists_delete_list_items(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
    input: lists_delete_list_items_request_Input
  ): lists_delete_list_items_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}/items", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Appends new items to the list.\\n\\nThis operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`."
  lists_create_list_items(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
    input: [mutationInput_lists_create_list_items_input_items_Input]
  ): lists_create_list_items_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}/items", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Removes all existing items from the list and adds the provided items to the list.\\n\\nThis operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned \`operation_id\`."
  lists_update_all_list_items(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "The unique ID of the list."
    list_id: list_id
    input: [mutationInput_lists_create_list_items_input_items_Input]
  ): lists_update_all_list_items_response @httpOperation(path: "/accounts/{args.account_identifier}/rules/lists/{args.list_id}/items", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create ACL."
  secondary_dns__acl_create_acl(account_identifier: String!, input: secondary_dns__acl_create_acl_request_Input): secondary_dns__acl_create_acl_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/acls", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete ACL."
  secondary_dns__acl_delete_acl(account_identifier: String!, identifier: String!): secondary_dns__acl_delete_acl_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/acls/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify ACL."
  secondary_dns__acl_update_acl(account_identifier: String!, identifier: String!, input: acl_Input): secondary_dns__acl_update_acl_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/acls/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create Peer."
  secondary_dns__peer_create_peer(account_identifier: String!, input: secondary_dns__peer_create_peer_request_Input): secondary_dns__peer_create_peer_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/peers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Peer."
  secondary_dns__peer_delete_peer(account_identifier: String!, identifier: String!): secondary_dns__peer_delete_peer_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/peers/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify Peer."
  secondary_dns__peer_update_peer(account_identifier: String!, identifier: String!, input: peer_Input): secondary_dns__peer_update_peer_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/peers/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create TSIG."
  secondary_dns__tsig_create_tsig(account_identifier: String!, input: secondary_dns__tsig_create_tsig_request_Input): secondary_dns__tsig_create_tsig_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/tsigs", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete TSIG."
  secondary_dns__tsig_delete_tsig(account_identifier: String!, identifier: String!): secondary_dns__tsig_delete_tsig_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/tsigs/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify TSIG."
  secondary_dns__tsig_update_tsig(account_identifier: String!, identifier: String!, input: tsig_Input): secondary_dns__tsig_update_tsig_response @httpOperation(path: "/accounts/{args.account_identifier}/secondary_dns/tsigs/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a namespace under the given title. A 400 is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced."
  workers_kv_namespace_create_a_namespace(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: create_rename_namespace_body_Input
  ): workers_kv_namespace_create_a_namespace_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes the namespace corresponding to the given ID."
  workers_kv_namespace_remove_a_namespace(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
  ): workers_kv_namespace_remove_a_namespace_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modifies a namespace's title."
  workers_kv_namespace_rename_a_namespace(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    input: create_rename_namespace_body_Input
  ): workers_kv_namespace_rename_a_namespace_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Remove multiple KV pairs from the Namespace. Body should be an array of up to 10,000 keys to be removed."
  workers_kv_namespace_delete_multiple_key_value_pairs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    input: [key_name_bulk]
  ): workers_kv_namespace_delete_multiple_key_value_pairs_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/bulk", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither expiration nor expiration_ttl is specified, the key-value pair will never expire. If both are set, \`expiration_ttl\` is used and \`expiration\` is ignored. The entire request size must be 100 megabytes or less."
  workers_kv_namespace_write_multiple_key_value_pairs(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    input: [mutationInput_workers_kv_namespace_write_multiple_key_value_pairs_input_items_Input]
  ): workers_kv_namespace_write_multiple_key_value_pairs_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/bulk", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Remove a KV pair from the Namespace. Use URL-encoding to use special characters (e.g. :, !, %) in the key name."
  workers_kv_namespace_delete_key_value_pair(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
    key_name: key_name!
  ): workers_kv_namespace_delete_key_value_pair_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/values/{args.key_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Write a value identified by a key. Use URL-encoding to use special characters (e.g. :, !, %) in the key name. Body should be the value to be stored along with json metadata to be associated with the key/value pair. Existing values, expirations and metadata will be overwritten. If neither \`expiration\` nor \`expiration_ttl\` is specified, the key-value pair will never expire. If both are set, \`expiration_ttl\` is used and \`expiration\` is ignored."
  workers_kv_namespace_write_key_value_pair_with_metadata(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Namespace identifier tag."
    namespace_identifier: namespace_identifier
    "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL."
    key_name: key_name!
    input: workers_kv_namespace_write_key_value_pair_with_metadata_request_Input
  ): workers_kv_namespace_write_key_value_pair_with_metadata_response @httpOperation(path: "/accounts/{args.account_identifier}/storage/kv/namespaces/{args.namespace_identifier}/values/{args.key_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Initiates a video upload using the TUS protocol. On success, the server responds with a status code 201 (created) and includes a \`location\` header to indicate where the content should be uploaded. Refer to https://tus.io for protocol details."
  stream_videos_initiate_video_uploads_using_tus(
    Tus_Resumable: tus_resumable!
    "A user-defined identifier for the media creator."
    Upload_Creator: creator!
    "Indicates the size of the entire upload in bytes. The value must be a non-negative integer."
    Upload_Length: NonNegativeInt!
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/stream", operationSpecificHeaders: "{\\"Tus-Resumable\\":\\"{args.Tus_Resumable}\\",\\"Upload-Creator\\":\\"{args.Upload_Creator}\\",\\"Upload-Length\\":\\"{args.Upload_Length}\\",\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Clips a video based on the specified start and end times provided in seconds."
  stream_video_clipping_clip_videos_given_a_start_and_end_time(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    input: videoClipStandard_Input
  ): stream_video_clipping_clip_videos_given_a_start_and_end_time_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/clip", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Uploads a video to Stream from a provided URL."
  stream_videos_upload_videos_from_a_url(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    input: video_copy_request_Input
  ): stream_videos_upload_videos_from_a_url_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/copy", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a direct upload that allows video uploads without an API key."
  stream_videos_upload_videos_via_direct_upload_ur_ls(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    input: direct_upload_request_Input
  ): stream_videos_upload_videos_via_direct_upload_ur_ls_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/direct_upload", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates an RSA private key in PEM and JWK formats. Key files are only displayed once after creation. Keys are created, used, and deleted independently of videos, and every key can sign any video."
  stream_signing_keys_create_signing_keys(
    "Identifier"
    account_identifier: common_components_schemas_identifier
  ): stream_signing_keys_create_signing_keys_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/keys", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes signing keys and revokes all signed URLs generated with the key."
  stream_signing_keys_delete_signing_keys(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    identifier: String!
  ): stream_signing_keys_delete_signing_keys_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/keys/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream."
  stream_live_inputs_create_a_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: create_input_request_Input
  ): stream_live_inputs_create_a_live_input_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls."
  stream_live_inputs_delete_a_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a specified live input."
  stream_live_inputs_update_a_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
    input: update_input_request_Input
  ): stream_live_inputs_update_a_live_input_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs."
  stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
    input: create_output_request_Input
  ): stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}/outputs", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an output and removes it from the associated live input."
  stream_live_inputs_delete_an_output(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
    "A unique identifier for the output."
    output_identifier: output_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}/outputs/{args.output_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the state of an output."
  stream_live_inputs_update_an_output(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for a live input."
    live_input_identifier: live_input_identifier
    "A unique identifier for the output."
    output_identifier: output_identifier
    input: update_output_request_Input
  ): stream_live_inputs_update_an_output_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/live_inputs/{args.live_input_identifier}/outputs/{args.output_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates watermark profiles using a single \`HTTP POST multipart/form-data\` request."
  stream_watermark_profile_create_watermark_profiles_via_basic_upload(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    input: watermark_basic_upload_Input
  ): stream_watermark_profile_create_watermark_profiles_via_basic_upload_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/watermarks", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a watermark profile."
  stream_watermark_profile_delete_watermark_profiles(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "The unique identifier for a watermark profile."
    identifier: watermarks_components_schemas_identifier
  ): stream_watermark_profile_delete_watermark_profiles_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/watermarks/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Deletes a webhook."
  stream_webhook_delete_webhooks(
    "Account identifier tag."
    account_identifier: webhook_components_schemas_account_identifier
  ): stream_webhook_delete_webhooks_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/webhook", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a webhook notification."
  stream_webhook_create_webhooks(
    "Account identifier tag."
    account_identifier: webhook_components_schemas_account_identifier
    input: webhook_request_Input
  ): stream_webhook_create_webhooks_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/webhook", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes a video and its copies from Cloudflare Stream."
  stream_videos_delete_video(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "A Cloudflare-generated unique identifier for a media item."
    identifier: videos_components_schemas_identifier
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Asssociates videos with a token ID and contract address to transfer admin rights on a video. If a change in ownership of the ERC-721 token happens on the Ethereum blockchain, the new token owner can claim control of the video."
  stream_videos_associate_videos_to_nf_ts(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "A Cloudflare-generated unique identifier for a media item."
    identifier: videos_components_schemas_identifier
    input: nft_Input
  ): stream_videos_associate_videos_to_nf_ts_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a signed URL token for a video. If a body is not provided in the request, a token is created with default values."
  stream_videos_create_signed_url_tokens_for_videso(
    "The account identifier tag."
    account_identifier: components_schemas_account_identifier
    "A Cloudflare-generated unique identifier for a media item."
    identifier: videos_components_schemas_identifier
    input: signed_token_request_Input
  ): stream_videos_create_signed_url_tokens_for_videso_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.identifier}/token", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Removes the captions or subtitles from a video."
  stream_subtitles__captions_delete_captions_or_subtitles(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for the media file."
    video_identifier: schemas_video_identifier
    "The language tag in BCP 47 format."
    language: String
  ): stream_subtitles__captions_delete_captions_or_subtitles_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.video_identifier}/captions/{args.language}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Uploads the caption or subtitle file to the endpoint for a specific BCP47 language. One caption or subtitle file per language is allowed."
  stream_subtitles__captions_upload_captions_or_subtitles(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for the media file."
    video_identifier: schemas_video_identifier
    "The language tag in BCP 47 format."
    language: String
    input: caption_basic_upload_Input
  ): stream_subtitles__captions_upload_captions_or_subtitles_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.video_identifier}/captions/{args.language}", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a download for a video when a video is ready to view."
  stream_m_p_4_downloads_create_downloads(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "A unique identifier for the MP4 file."
    video_identifier: video_identifier
  ): stream_m_p_4_downloads_create_downloads_response @httpOperation(path: "/accounts/{args.account_identifier}/stream/{args.video_identifier}/downloads", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates an account subscription."
  account_subscriptions_create_subscription(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: subscription_v2_Input
  ): account_subscriptions_create_subscription_response @httpOperation(path: "/accounts/{args.account_identifier}/subscriptions", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an account's subscription."
  account_subscriptions_delete_subscription(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Subscription identifier tag."
    subscription_identifier: subscription_v2_components_schemas_identifier
  ): account_subscriptions_delete_subscription_response @httpOperation(path: "/accounts/{args.account_identifier}/subscriptions/{args.subscription_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an account subscription."
  account_subscriptions_update_subscription(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Subscription identifier tag."
    subscription_identifier: subscription_v2_components_schemas_identifier
    input: subscription_v2_Input
  ): account_subscriptions_update_subscription_response @httpOperation(path: "/accounts/{args.account_identifier}/subscriptions/{args.subscription_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete an existing route from the account's routing table."
  tunnel_route_delete_route(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    ip_network_encoded: String!
    input: tunnel_route_delete_route_request_Input
  ): tunnel_route_delete_route_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/routes/network/{args.ip_network_encoded}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update an existing route in the account's routing table for the given tunnel."
  tunnel_route_update_route(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    ip_network_encoded: String!
    input: tunnel_route_update_route_request_Input
  ): tunnel_route_update_route_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/routes/network/{args.ip_network_encoded}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Add a new route to the account's routing table for the given tunnel."
  tunnel_route_create_route(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    ip_network_encoded: String!
    input: tunnel_route_create_route_request_Input
  ): tunnel_route_create_route_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/routes/network/{args.ip_network_encoded}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Add a new virtual network to the account."
  tunnel_virtual_network_create_virtual_network(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: tunnel_virtual_network_create_virtual_network_request_Input
  ): tunnel_virtual_network_create_virtual_network_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/virtual_networks", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an existing virtual network from the account."
  tunnel_virtual_network_delete_virtual_network(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the virtual network."
    vnet_id: vnet_id
  ): tunnel_virtual_network_delete_virtual_network_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/virtual_networks/{args.vnet_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update an existing virtual network in the account."
  tunnel_virtual_network_update_virtual_network(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the virtual network."
    vnet_id: vnet_id
    input: tunnel_virtual_network_update_virtual_network_request_Input
  ): tunnel_virtual_network_update_virtual_network_response @httpOperation(path: "/accounts/{args.account_identifier}/teamnet/virtual_networks/{args.vnet_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create an Argo Tunnel in an account."
  argo_tunnel_create_argo_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: argo_tunnel_create_argo_tunnel_request_Input
  ): argo_tunnel_create_argo_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/tunnels", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an Argo Tunnel from an account."
  argo_tunnel_delete_argo_tunnel(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: JSON
  ): argo_tunnel_delete_argo_tunnel_response @httpOperation(path: "/accounts/{args.account_identifier}/tunnels/{args.tunnel_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Remove stale connection resources from an Argo Tunnel."
  argo_tunnel_clean_up_argo_tunnel_connections(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "UUID of the tunnel."
    tunnel_id: tunnel_id
    input: JSON
  ): argo_tunnel_clean_up_argo_tunnel_connections_response @httpOperation(path: "/accounts/{args.account_identifier}/tunnels/{args.tunnel_id}/connections", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create a configured DNS Firewall Cluster."
  dns_firewall__legacy_create_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: dns_firewall__legacy_create_dns_firewall_cluster_request_Input
  ): dns_firewall__legacy_create_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured DNS Firewall Cluster."
  dns_firewall__legacy_delete_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): dns_firewall__legacy_delete_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify a DNS Firewall Cluster configuration."
  dns_firewall__legacy_update_dns_firewall_cluster(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: schemas_virtual_dns_Input
  ): dns_firewall__legacy_update_dns_firewall_cluster_response @httpOperation(path: "/accounts/{args.account_identifier}/virtual_dns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates Worker Account Settings for an account."
  worker_account_settings_create_worker_account_settings(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: String
  ): worker_account_settings_create_worker_account_settings_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/account-settings", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Attaches a worker to a zone and hostname."
  worker_domain_attach_to_domain(account_identifier: String!, input: worker_domain_attach_to_domain_request_Input): worker_domain_attach_to_domain_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/domains", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Detaches a worker from a zone and hostname."
  worker_domain_detach_from_domain(
    account_identifier: String!
    "Identifer of the Worker Domain."
    domain_identifier: String!
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/workers/domains/{args.domain_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a new queue."
  queue_create_queue(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: queue_create_queue_request_Input
  ): queue_create_queue_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a queue."
  queue_delete_queue(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
  ): queue_delete_queue_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a queue."
  queue_update_queue(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
    input: queue_update_queue_request_Input
  ): queue_update_queue_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new consumer for a queue."
  queue_create_queue_consumer(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
    input: queue_create_queue_consumer_request_Input
  ): queue_create_queue_consumer_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}/consumers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes the consumer for a queue."
  queue_delete_queue_consumer(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
    consumer_name: String!
  ): queue_delete_queue_consumer_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}/consumers/{args.consumer_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the consumer for a queue, or creates one if it does not exist."
  queue_update_queue_consumer(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    name: String!
    consumer_name: String!
    input: queue_update_queue_consumer_request_Input
  ): queue_update_queue_consumer_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/queues/{args.name}/consumers/{args.consumer_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete your worker. This call has no response body on a successful delete.\\n\\n**Query paramaters**:\\n\\n1.  \`force\`: boolean;   If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script."
  worker_script_delete_worker(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): JSON @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Upload a worker module."
  worker_script_upload_worker_module(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
    input: worker_script_upload_worker_module_request_Input
  ): worker_script_upload_worker_module_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates Cron Triggers for a Worker."
  worker_cron_trigger_update_cron_triggers(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
    input: String
  ): worker_cron_trigger_update_cron_triggers_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/schedules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Starts a tail that receives logs and exception from a Worker."
  worker_tail_logs_start_tail(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
  ): worker_tail_logs_start_tail_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/tails", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a tail from a Worker."
  worker_tail_logs_delete_tail(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
    "Identifier for the tail."
    id: String!
  ): worker_tail_logs_delete_tail_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/tails/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the Usage Model for a given Worker. Requires a Workers Paid subscription."
  worker_script_update_usage_model(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    script_name: script_name!
    input: String
  ): worker_script_update_usage_model_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/scripts/{args.script_name}/usage-model", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a Workers subdomain for an account."
  worker_subdomain_create_subdomain(
    "Identifier"
    account_identifier: common_components_schemas_identifier
    input: String
  ): worker_subdomain_create_subdomain_response @httpOperation(path: "/accounts/{args.account_identifier}/workers/subdomain", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a ruleset at the account level."
  account_rulesets_create_an_account_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    input: create_ruleset_Input
  ): account_rulesets_create_an_account_ruleset_response @httpOperation(path: "/accounts/{args.account_id}/rulesets", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates an account entry point ruleset, creating a new version."
  account_rulesets_update_an_account_entry_point_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_phase: phase!
    input: update_ruleset_Input
  ): account_rulesets_update_an_account_entry_point_ruleset_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/phases/{args.ruleset_phase}/entrypoint", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes all versions of an existing account ruleset."
  account_rulesets_delete_an_account_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): JSON @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an account ruleset, creating a new version."
  account_rulesets_update_an_account_ruleset(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    input: update_ruleset_Input
  ): account_rulesets_update_an_account_ruleset_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a new rule to an account ruleset. The rule will be added to the end of the existing list of rules in the ruleset."
  account_rulesets_create_an_account_ruleset_rule(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    input: create_update_rule_Input
  ): account_rulesets_create_an_account_ruleset_rule_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing rule from an account ruleset."
  account_rulesets_delete_an_account_ruleset_rule(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    "The unique ID of the rule."
    rule_id: String!
  ): account_rulesets_delete_an_account_ruleset_rule_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing rule in an account ruleset."
  account_rulesets_update_an_account_ruleset_rule(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    "The unique ID of the rule."
    rule_id: String!
    input: create_update_rule_Input
  ): account_rulesets_update_an_account_ruleset_rule_response @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Deletes an existing version of an account ruleset."
  account_rulesets_delete_an_account_ruleset_version(
    "Identifier"
    account_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    ruleset_version: version!
  ): JSON @httpOperation(path: "/accounts/{args.account_id}/rulesets/{args.ruleset_id}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update an existing account."
  accounts_update_account(identifier: JSON!, input: components_schemas_account_Input): accounts_update_account_response @httpOperation(path: "/accounts/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a custom link to the App Launcher. Bookmark applications are not protected by Access."
  access_applications_add_a_bookmark_application(identifier: String!, input: access_applications_add_a_bookmark_application_request_Input): access_applications_add_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/apps", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an application from Access."
  access_applications_delete_an_access_application(identifier: String!, app_id: String!): access_applications_delete_an_access_application_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a Bookmark application."
  access_applications_update_a_bookmark_application(identifier: String!, app_id: String!, input: access_applications_update_a_bookmark_application_request_Input): access_applications_update_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Revokes all service tokens used by an application."
  access_applications_revoke_service_tokens(identifier: String!, app_id: String!): access_applications_revoke_service_tokens_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.app_id}/revoke_tokens", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an Access policy."
  access_policies_delete_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): access_policies_delete_an_access_policy_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a configured Access policy."
  access_policies_update_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
    input: access_policies_update_an_access_policy_request_Input
  ): access_policies_update_an_access_policy_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes a short-lived certificate CA."
  access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Generates a new short-lived certificate CA and public key."
  access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a new Access policy for an application."
  access_policies_create_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid: components_schemas_uuid!
    input: access_policies_create_an_access_policy_request_Input
  ): access_policies_create_an_access_policy_response @httpOperation(path: "/accounts/{args.identifier}/access/apps/{args.uuid}/policies", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a Bookmark application."
  access_bookmark_applications__deprecated_delete_a_bookmark_application(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_bookmark_applications__deprecated_delete_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/bookmarks/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create a new Bookmark application."
  access_bookmark_applications__deprecated_create_a_bookmark_application(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_bookmark_applications__deprecated_create_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/bookmarks/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates a configured Bookmark application."
  access_bookmark_applications__deprecated_update_a_bookmark_application(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_bookmark_applications__deprecated_update_a_bookmark_application_response @httpOperation(path: "/accounts/{args.identifier}/access/bookmarks/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a new mTLS root certificate to Access."
  access_m_tls_authentication_add_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: access_m_tls_authentication_add_an_m_tls_certificate_request_Input
  ): access_m_tls_authentication_add_an_m_tls_certificate_response @httpOperation(path: "/accounts/{args.identifier}/access/certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an mTLS certificate."
  access_m_tls_authentication_delete_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_m_tls_authentication_delete_an_m_tls_certificate_response @httpOperation(path: "/accounts/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured mTLS certificate."
  access_m_tls_authentication_update_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: access_m_tls_authentication_update_an_m_tls_certificate_request_Input
  ): access_m_tls_authentication_update_an_m_tls_certificate_response @httpOperation(path: "/accounts/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new Access group."
  access_groups_create_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: access_groups_create_an_access_group_request_Input
  ): access_groups_create_an_access_group_response @httpOperation(path: "/accounts/{args.identifier}/access/groups", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an Access group."
  access_groups_delete_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
  ): access_groups_delete_an_access_group_response @httpOperation(path: "/accounts/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured Access group."
  access_groups_update_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
    input: access_groups_update_an_access_group_request_Input
  ): access_groups_update_an_access_group_response @httpOperation(path: "/accounts/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a new identity provider to Access."
  access_identity_providers_add_an_access_identity_provider(identifier: String!, input: access_identity_providers_add_an_access_identity_provider_request_Input): access_identity_providers_add_an_access_identity_provider_response @httpOperation(path: "/accounts/{args.identifier}/access/identity_providers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an identity provider from Access."
  access_identity_providers_delete_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
  ): access_identity_providers_delete_an_access_identity_provider_response @httpOperation(path: "/accounts/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured identity provider."
  access_identity_providers_update_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
    input: access_identity_providers_update_an_access_identity_provider_request_Input
  ): access_identity_providers_update_an_access_identity_provider_response @httpOperation(path: "/accounts/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates the Access key rotation settings for an account."
  access_key_configuration_update_the_access_key_configuration(identifier: String!, input: access_key_configuration_update_the_access_key_configuration_request_Input): access_key_configuration_update_the_access_key_configuration_response @httpOperation(path: "/accounts/{args.identifier}/access/keys", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Perfoms a key rotation for an account."
  access_key_configuration_rotate_access_keys(identifier: String!): access_key_configuration_rotate_access_keys_response @httpOperation(path: "/accounts/{args.identifier}/access/keys/rotate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Sets up a Zero Trust organization for your account."
  zero_trust_organization_create_your_zero_trust_organization(identifier: String!, input: zero_trust_organization_create_your_zero_trust_organization_request_Input): zero_trust_organization_create_your_zero_trust_organization_response @httpOperation(path: "/accounts/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates the configuration for your Zero Trust organization."
  zero_trust_organization_update_your_zero_trust_organization(identifier: String!, input: zero_trust_organization_update_your_zero_trust_organization_request_Input): zero_trust_organization_update_your_zero_trust_organization_response @httpOperation(path: "/accounts/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Revokes a user's access across all applications."
  zero_trust_organization_revoke_all_access_tokens_for_a_user(identifier: String!, input: zero_trust_organization_revoke_all_access_tokens_for_a_user_request_Input): zero_trust_organization_revoke_all_access_tokens_for_a_user_response @httpOperation(path: "/accounts/{args.identifier}/access/organizations/revoke_user", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Removes a user from a Zero Trust seat when both \`access_seat\` and \`gateway_seat\` are set to false."
  zero_trust_seats_update_a_user_seat(identifier: String!, input: [seat_Input]): zero_trust_seats_update_a_user_seat_response @httpOperation(path: "/accounts/{args.identifier}/access/seats", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to rotate the Client Secret or create a new service token."
  access_service_tokens_create_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: access_service_tokens_create_a_service_token_request_Input
  ): access_service_tokens_create_a_service_token_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a service token."
  access_service_tokens_delete_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_service_tokens_delete_a_service_token_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured service token."
  access_service_tokens_update_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: access_service_tokens_update_a_service_token_request_Input
  ): access_service_tokens_update_a_service_token_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Refreshes the expiration of a service token."
  access_service_tokens_refresh_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_service_tokens_refresh_a_service_token_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens/{args.uuid}/refresh", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Generates a new Client Secret for a service token and revokes the old one."
  access_service_tokens_rotate_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): access_service_tokens_rotate_a_service_token_response @httpOperation(path: "/accounts/{args.identifier}/access/service_tokens/{args.uuid}/rotate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a new webhook destination."
  notification_webhooks_create_a_webhook(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: notification_webhooks_create_a_webhook_request_Input
  ): notification_webhooks_create_a_webhook_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/webhooks", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured webhook destination."
  notification_webhooks_delete_a_webhook(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): notification_webhooks_delete_a_webhook_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/webhooks/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a webhook destination."
  notification_webhooks_update_a_webhook(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: notification_webhooks_update_a_webhook_request_Input
  ): notification_webhooks_update_a_webhook_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/destinations/webhooks/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new Notification policy."
  notification_policies_create_a_notification_policy(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: notification_policies_create_a_notification_policy_request_Input
  ): notification_policies_create_a_notification_policy_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/policies", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Notification policy."
  notification_policies_delete_a_notification_policy(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): notification_policies_delete_a_notification_policy_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a Notification policy."
  notification_policies_update_a_notification_policy(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: notification_policies_update_a_notification_policy_request_Input
  ): notification_policies_update_a_notification_policy_response @httpOperation(path: "/accounts/{args.identifier}/alerting/v3/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Add Account Custom Nameserver"
  account_level_custom_nameservers_add_account_custom_nameserver(
    "Account identifier tag."
    identifier: custom_ns_components_schemas_identifier
    input: Custom_NS_Input_Input
  ): account_level_custom_nameservers_add_account_custom_nameserver_response @httpOperation(path: "/accounts/{args.identifier}/custom_ns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Verify Account Custom Nameserver Glue Records"
  account_level_custom_nameservers_verify_account_custom_nameserver_glue_records(
    "Account identifier tag."
    identifier: custom_ns_components_schemas_identifier
  ): account_level_custom_nameservers_verify_account_custom_nameserver_glue_records_response @httpOperation(path: "/accounts/{args.identifier}/custom_ns/verify", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Account Custom Nameserver"
  account_level_custom_nameservers_delete_account_custom_nameserver(
    "Account identifier tag."
    identifier: custom_ns_components_schemas_identifier
    "The FQDN of the name server."
    ns_name: Hostname!
  ): account_level_custom_nameservers_delete_account_custom_nameserver_response @httpOperation(path: "/accounts/{args.identifier}/custom_ns/{args.ns_name}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update the default device settings policy for an account."
  devices_update_default_device_settings_policy(identifier: String!, input: devices_update_default_device_settings_policy_request_Input): devices_update_default_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a device settings policy to be applied to certain devices matching the criteria."
  devices_create_device_settings_policy(identifier: String!, input: devices_create_device_settings_policy_request_Input): devices_create_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Set the list of routes excluded from the WARP client's tunnel."
  devices_set_split_tunnel_exclude_list(identifier: String!, input: [split_tunnel_Input]): devices_set_split_tunnel_exclude_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/exclude", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set the list of domains to bypass Gateway for DNS resolution and instead use the specified server."
  devices_set_local_domain_fallback_list(identifier: String!, input: [fallback_domain_Input]): devices_set_local_domain_fallback_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/fallback_domains", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set the list of routes included in the WARP client's tunnel."
  devices_set_split_tunnel_include_list(identifier: String!, input: [split_tunnel_include_Input]): devices_set_split_tunnel_include_list_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/include", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete a device settings policy. Returns the remaining policies for the account."
  devices_delete_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
  ): devices_delete_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a device settings policy."
  devices_update_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
    input: devices_update_device_settings_policy_request_Input
  ): devices_update_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Set the list of routes excluded from the WARP client's tunnel for one specific device settings policy."
  devices_set_split_tunnel_exclude_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
    input: [split_tunnel_Input]
  ): devices_set_split_tunnel_exclude_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/exclude", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set the list of domains to bypass Gateway for DNS resolution and instead use the specified server."
  devices_set_local_domain_fallback_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
    input: [fallback_domain_Input]
  ): devices_set_local_domain_fallback_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/fallback_domains", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set the list of routes included in the WARP client's tunnel for one specific device settings policy."
  devices_set_split_tunnel_include_list_for_a_device_settings_policy(
    identifier: String!
    "UUID"
    uuid: uuid
    input: [split_tunnel_include_Input]
  ): devices_set_split_tunnel_include_list_for_a_device_settings_policy_response @httpOperation(path: "/accounts/{args.identifier}/devices/policy/{args.uuid}/include", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new Device Posture Rule."
  device_posture_rules_create_device_posture_rule(identifier: String!, input: device_posture_rules_create_device_posture_rule_request_Input): device_posture_rules_create_device_posture_rule_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a new Device Posture Integration."
  device_posture_integrations_create_device_posture_integration(identifier: String!, input: device_posture_integrations_create_device_posture_integration_request_Input): device_posture_integrations_create_device_posture_integration_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/integration", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Device Posture Integration."
  device_posture_integrations_delete_device_posture_integration(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_integrations_components_schemas_uuid!
  ): device_posture_integrations_delete_device_posture_integration_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/integration/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a Device Posture Integration."
  device_posture_integrations_update_device_posture_integration(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_integrations_components_schemas_uuid!
    input: device_posture_integrations_update_device_posture_integration_request_Input
  ): device_posture_integrations_update_device_posture_integration_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/integration/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Delete a Device Posture Rule."
  device_posture_rules_delete_device_posture_rule(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_rules_components_schemas_uuid!
  ): device_posture_rules_delete_device_posture_rule_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a Device Posture Rule."
  device_posture_rules_update_device_posture_rule(
    identifier: String!
    "API uuid tag."
    uuid: device_posture_rules_components_schemas_uuid!
    input: device_posture_rules_update_device_posture_rule_request_Input
  ): device_posture_rules_update_device_posture_rule_response @httpOperation(path: "/accounts/{args.identifier}/devices/posture/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Revoke a list of devices."
  devices_revoke_devices(
    identifier: String!
    "A list of device ids to revoke."
    input: [uuid]
  ): devices_revoke_devices_response @httpOperation(path: "/accounts/{args.identifier}/devices/revoke", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates the current device settings for Zero Trust account."
  zero_trust_accounts_update_device_settings_for_the_zero_trust_account(identifier: String!, input: gateway_account_device_settings_Input): zero_trust_accounts_update_device_settings_for_the_zero_trust_account_response @httpOperation(path: "/accounts/{args.identifier}/devices/settings", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Unrevoke a list of devices."
  devices_unrevoke_devices(
    identifier: String!
    "A list of device ids to unrevoke."
    input: [uuid]
  ): devices_unrevoke_devices_response @httpOperation(path: "/accounts/{args.identifier}/devices/unrevoke", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create Zero Trust account with existing cloudflare account."
  zero_trust_accounts_create_zero_trust_account(identifier: String!, input: zero_trust_accounts_create_zero_trust_account_request_Input): zero_trust_accounts_create_zero_trust_account_response @httpOperation(path: "/accounts/{args.identifier}/gateway", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates the current Zero Trust account configuration."
  zero_trust_accounts_update_zero_trust_account_configuration(identifier: String!, input: gateway_account_settings_Input): zero_trust_accounts_update_zero_trust_account_configuration_response @httpOperation(path: "/accounts/{args.identifier}/gateway/configuration", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new Zero Trust List."
  zero_trust_lists_create_zero_trust_list(identifier: String!, input: zero_trust_lists_create_zero_trust_list_request_Input): zero_trust_lists_create_zero_trust_list_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Zero Trust List."
  zero_trust_lists_delete_zero_trust_list(
    identifier: String!
    "API Resource UUID tag."
    uuid: lists_components_schemas_uuid!
  ): zero_trust_lists_delete_zero_trust_list_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Append or remove an item from a configured Zero Trust List."
  zero_trust_lists_patch_zero_trust_list(
    identifier: String!
    "API Resource UUID tag."
    uuid: lists_components_schemas_uuid!
    input: zero_trust_lists_patch_zero_trust_list_request_Input
  ): zero_trust_lists_patch_zero_trust_list_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update a configured Zero Trust List."
  zero_trust_lists_update_zero_trust_list(
    identifier: String!
    "API Resource UUID tag."
    uuid: lists_components_schemas_uuid!
    input: zero_trust_lists_update_zero_trust_list_request_Input
  ): zero_trust_lists_update_zero_trust_list_response @httpOperation(path: "/accounts/{args.identifier}/gateway/lists/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new Zero Trust Gateway Location."
  zero_trust_gateway_locations_create_zero_trust_gateway_location(identifier: String!, input: zero_trust_gateway_locations_create_zero_trust_gateway_location_request_Input): zero_trust_gateway_locations_create_zero_trust_gateway_location_response @httpOperation(path: "/accounts/{args.identifier}/gateway/locations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Zero Trust Gateway Location."
  zero_trust_gateway_locations_delete_zero_trust_gateway_location(identifier: String!, uuid: String!): zero_trust_gateway_locations_delete_zero_trust_gateway_location_response @httpOperation(path: "/accounts/{args.identifier}/gateway/locations/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a configured Zero Trust Gateway Location."
  zero_trust_gateway_locations_update_zero_trust_gateway_location(identifier: String!, uuid: String!, input: zero_trust_gateway_locations_update_zero_trust_gateway_location_request_Input): zero_trust_gateway_locations_update_zero_trust_gateway_location_response @httpOperation(path: "/accounts/{args.identifier}/gateway/locations/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates the current logging settings for the Zero Trust accounty."
  zero_trust_accounts_update_logging_settings_for_the_zero_trust_account(identifier: String!, input: gateway_account_logging_settings_Input): zero_trust_accounts_update_logging_settings_for_the_zero_trust_account_response @httpOperation(path: "/accounts/{args.identifier}/gateway/logging", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new Zero Trust Gateway Proxy Endpoint."
  zero_trust_gateway_proxy_endpoints_create_proxy_endpoint(identifier: String!, input: zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_request_Input): zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_response @httpOperation(path: "/accounts/{args.identifier}/gateway/proxy_endpoints", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Zero Trust Gateway Proxy Endpoint."
  zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint(identifier: String!, uuid: String!): zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint_response @httpOperation(path: "/accounts/{args.identifier}/gateway/proxy_endpoints/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a new Zero Trust Gateway Proxy Endpoint."
  zero_trust_gateway_proxy_endpoints_update_proxy_endpoint(identifier: String!, uuid: String!, input: zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_request_Input): zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_response @httpOperation(path: "/accounts/{args.identifier}/gateway/proxy_endpoints/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new Zero Trust Gateway Rule."
  zero_trust_gateway_rules_create_zero_trust_gateway_rule(identifier: String!, input: zero_trust_gateway_rules_create_zero_trust_gateway_rule_request_Input): zero_trust_gateway_rules_create_zero_trust_gateway_rule_response @httpOperation(path: "/accounts/{args.identifier}/gateway/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a Zero Trust Gateway Rule."
  zero_trust_gateway_rules_delete_zero_trust_gateway_rule(
    identifier: String!
    "API Resource UUID tag."
    uuid: rules_components_schemas_uuid!
  ): zero_trust_gateway_rules_delete_zero_trust_gateway_rule_response @httpOperation(path: "/accounts/{args.identifier}/gateway/rules/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a configured Zero Trust Gateway Rule."
  zero_trust_gateway_rules_update_zero_trust_gateway_rule(
    identifier: String!
    "API Resource UUID tag."
    uuid: rules_components_schemas_uuid!
    input: zero_trust_gateway_rules_update_zero_trust_gateway_rule_request_Input
  ): zero_trust_gateway_rules_update_zero_trust_gateway_rule_response @httpOperation(path: "/accounts/{args.identifier}/gateway/rules/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create an Origin CA certificate. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests))."
  origin_ca_create_certificate(input: origin_ca_create_certificate_request_Input): origin_ca_create_certificate_response @httpOperation(path: "/certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Revoke an existing Origin CA certificate by its serial number. Use your Origin CA Key as your User Service Key when calling this endpoint ([see above](#requests))."
  origin_ca_revoke_certificate(
    "The x509 serial number of the Origin CA certificate."
    identifier: String
  ): origin_ca_revoke_certificate_response @httpOperation(path: "/certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Remove the associated member from an account."
  user_SINGLE_QUOTE__s_account_memberships_delete_membership(
    "Membership identifier tag."
    identifier: membership_components_schemas_identifier
  ): user_SINGLE_QUOTE__s_account_memberships_delete_membership_response @httpOperation(path: "/memberships/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Accept or reject this account invitation."
  user_SINGLE_QUOTE__s_account_memberships_update_membership(
    "Membership identifier tag."
    identifier: membership_components_schemas_identifier
    input: user_SINGLE_QUOTE__s_account_memberships_update_membership_request_Input
  ): user_SINGLE_QUOTE__s_account_memberships_update_membership_response @httpOperation(path: "/memberships/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Update an existing Organization."
  organizations__deprecated_edit_organization(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: organizations__deprecated_edit_organization_request_Input
  ): organizations__deprecated_edit_organization_response @httpOperation(path: "/organizations/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Invite a User to become a Member of an Organization."
  organization_invites_create_invitation(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    input: organization_invites_create_invitation_request_Input
  ): organization_invites_create_invitation_response @httpOperation(path: "/organizations/{args.organization_identifier}/invites", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Cancel an existing invitation."
  organization_invites_cancel_invitation(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Invite identifier tag."
    identifier: invite_components_schemas_identifier
  ): organization_invites_cancel_invitation_response @httpOperation(path: "/organizations/{args.organization_identifier}/invites/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Change the Roles of a Pending Invite."
  organization_invites_edit_invitation_roles(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Invite identifier tag."
    identifier: invite_components_schemas_identifier
    input: organization_invites_edit_invitation_roles_request_Input
  ): organization_invites_edit_invitation_roles_response @httpOperation(path: "/organizations/{args.organization_identifier}/invites/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Remove a member from an organization."
  organization_members_remove_member(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): organization_members_remove_member_response @httpOperation(path: "/organizations/{args.organization_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Change the Roles of an Organization's Member."
  organization_members_edit_member_roles(
    "Organization identifier tag."
    organization_identifier: organization_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: organization_members_edit_member_roles_request_Input
  ): organization_members_edit_member_roles_response @httpOperation(path: "/organizations/{args.organization_identifier}/members/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create Railgun"
  organization_railgun_create_railgun(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    input: organization_railgun_create_railgun_request_Input
  ): organization_railgun_create_railgun_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Disable and delete a Railgun. This will immediately disable the Railgun for any connected zones."
  organization_railgun_delete_railgun(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): organization_railgun_delete_railgun_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Enable or disable a Railgun for all zones connected to it."
  organization_railgun_enable_or_disable_a_railgun(
    "Identifier"
    organization_identifier: common_components_schemas_identifier
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
    input: organization_railgun_enable_or_disable_a_railgun_request_Input
  ): organization_railgun_enable_or_disable_a_railgun_response @httpOperation(path: "/organizations/{args.organization_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Get a list of datasets."
  radar_datasets_get_dataset_download_url(input: radar_datasets_get_dataset_download_url_request_Input): radar_datasets_get_dataset_download_url_response @httpOperation(path: "/radar/datasets/download", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST) @httpOperation(path: "/radar/reports/datasets/download", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create Railgun"
  railgun_create_railgun(input: railgun_create_railgun_request_Input): railgun_create_railgun_response @httpOperation(path: "/railguns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Disable and delete a Railgun. This will immediately disable that Railgun for any connected zones."
  railgun_delete_a_railgun(
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
  ): railgun_delete_a_railgun_response @httpOperation(path: "/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Enable or disable a Railgun for all zones connected to it."
  railgun_enable_or_disable_a_railgun(
    "Railgun identifier tag."
    identifier: railgun_components_schemas_identifier
    input: railgun_enable_or_disable_a_railgun_request_Input
  ): railgun_enable_or_disable_a_railgun_response @httpOperation(path: "/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Edit part of your user details."
  user_edit_user(input: user_edit_user_request_Input): user_edit_user_response @httpOperation(path: "/user", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Creates a new IP Access rule for all zones owned by the current user.\\n\\nNote: To create an IP Access rule that applies to a specific zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints."
  ip_access_rules_for_a_user_create_an_ip_access_rule(input: ip_access_rules_for_a_user_create_an_ip_access_rule_request_Input): ip_access_rules_for_a_user_create_an_ip_access_rule_response @httpOperation(path: "/user/firewall/access_rules/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an IP Access rule at the user level.\\n\\nNote: Deleting a user-level rule will affect all zones owned by the user."
  ip_access_rules_for_a_user_delete_an_ip_access_rule(
    "The unique identifier of the IP Access rule."
    identifier: rule_components_schemas_identifier
  ): ip_access_rules_for_a_user_delete_an_ip_access_rule_response @httpOperation(path: "/user/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an IP Access rule defined at the user level. You can only update the rule action (\`mode\` parameter) and notes."
  ip_access_rules_for_a_user_update_an_ip_access_rule(
    "The unique identifier of the IP Access rule."
    identifier: rule_components_schemas_identifier
    input: ip_access_rules_for_a_user_update_an_ip_access_rule_request_Input
  ): ip_access_rules_for_a_user_update_an_ip_access_rule_response @httpOperation(path: "/user/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Responds to an invitation."
  user_SINGLE_QUOTE__s_invites_respond_to_invitation(
    "Invite identifier tag."
    identifier: invite_components_schemas_identifier
    input: user_SINGLE_QUOTE__s_invites_respond_to_invitation_request_Input
  ): user_SINGLE_QUOTE__s_invites_respond_to_invitation_response @httpOperation(path: "/user/invites/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a configured monitor."
  load_balancer_monitors_create_monitor(input: load_balancer_monitors_create_monitor_request_Input): load_balancer_monitors_create_monitor_response @httpOperation(path: "/user/load_balancers/monitors", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured monitor."
  load_balancer_monitors_delete_monitor(identifier: String!): load_balancer_monitors_delete_monitor_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Apply changes to an existing monitor, overwriting the supplied properties."
  load_balancer_monitors_patch_monitor(identifier: String!, input: load_balancer_monitors_patch_monitor_request_Input): load_balancer_monitors_patch_monitor_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Modify a configured monitor."
  load_balancer_monitors_update_monitor(identifier: String!, input: load_balancer_monitors_update_monitor_request_Input): load_balancer_monitors_update_monitor_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results."
  load_balancer_monitors_preview_monitor(identifier: String!, input: load_balancer_monitors_preview_monitor_request_Input): load_balancer_monitors_preview_monitor_response @httpOperation(path: "/user/load_balancers/monitors/{args.identifier}/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending \`name\`. Returns the list of affected pools. Supports the standard pagination query parameters, either \`limit\`/\`offset\` or \`per_page\`/\`page\`."
  load_balancer_pools_patch_pools(input: load_balancer_pools_patch_pools_request_Input): load_balancer_pools_patch_pools_response @httpOperation(path: "/user/load_balancers/pools", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new pool."
  load_balancer_pools_create_pool(input: load_balancer_pools_create_pool_request_Input): load_balancer_pools_create_pool_response @httpOperation(path: "/user/load_balancers/pools", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured pool."
  load_balancer_pools_delete_pool(identifier: String!): load_balancer_pools_delete_pool_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Apply changes to an existing pool, overwriting the supplied properties."
  load_balancer_pools_patch_pool(identifier: String!, input: load_balancer_pools_patch_pool_request_Input): load_balancer_pools_patch_pool_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Modify a configured pool."
  load_balancer_pools_update_pool(identifier: String!, input: load_balancer_pools_update_pool_request_Input): load_balancer_pools_update_pool_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results."
  load_balancer_pools_preview_pool(identifier: String!, input: load_balancer_pools_preview_pool_request_Input): load_balancer_pools_preview_pool_response @httpOperation(path: "/user/load_balancers/pools/{args.identifier}/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Removes association to an organization."
  user_SINGLE_QUOTE__s_organizations_leave_organization(
    "Identifier"
    identifier: common_components_schemas_identifier
  ): user_SINGLE_QUOTE__s_organizations_leave_organization_response @httpOperation(path: "/user/organizations/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Deletes a user's subscription."
  user_subscription_delete_user_subscription(
    "Subscription identifier tag."
    identifier: subscription_v2_components_schemas_identifier
  ): user_subscription_delete_user_subscription_response @httpOperation(path: "/user/subscriptions/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a user's subscriptions."
  user_subscription_update_user_subscription(
    "Subscription identifier tag."
    identifier: subscription_v2_components_schemas_identifier
    input: subscription_v2_Input
  ): user_subscription_update_user_subscription_response @httpOperation(path: "/user/subscriptions/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new access token."
  user_api_tokens_create_token(input: create_payload_Input): user_api_tokens_create_token_response @httpOperation(path: "/user/tokens", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Destroy a token."
  user_api_tokens_delete_token(identifier: JSON!): user_api_tokens_delete_token_response @httpOperation(path: "/user/tokens/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update an existing token."
  user_api_tokens_update_token(identifier: JSON!, input: schemas_token_Input): user_api_tokens_update_token_response @httpOperation(path: "/user/tokens/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Roll the token secret."
  user_api_tokens_roll_token(identifier: JSON!, input: JSON): user_api_tokens_roll_token_response @httpOperation(path: "/user/tokens/{args.identifier}/value", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create Zone"
  zone_create_zone(input: schemas_create_Input): zone_create_zone_response @httpOperation(path: "/zones", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a configured load balancer."
  load_balancers_delete_load_balancer(identifier1: String!, identifier: String!): load_balancers_delete_load_balancer_response @httpOperation(path: "/zones/{args.identifier1}/load_balancers/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Apply changes to an existing load balancer, overwriting the supplied properties."
  load_balancers_patch_load_balancer(identifier1: String!, identifier: String!, input: load_balancers_patch_load_balancer_request_Input): load_balancers_patch_load_balancer_response @httpOperation(path: "/zones/{args.identifier1}/load_balancers/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update a configured load balancer."
  load_balancers_update_load_balancer(identifier1: String!, identifier: String!, input: load_balancers_update_load_balancer_request_Input): load_balancers_update_load_balancer_response @httpOperation(path: "/zones/{args.identifier1}/load_balancers/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes an existing zone."
  zone_delete_zone(identifier: JSON!): zone_delete_zone_response @httpOperation(path: "/zones/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Editz a zone. Only one zone property can be changed at a time."
  zone_edit_zone(identifier: JSON!, input: schemas_patch_Input): zone_edit_zone_response @httpOperation(path: "/zones/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Adds a custom link to the App Launcher. Bookmark applications are not protected by Access."
  zone_level_access_applications_add_a_bookmark_application(identifier: String!, input: zone_level_access_applications_add_a_bookmark_application_request_Input): zone_level_access_applications_add_a_bookmark_application_response @httpOperation(path: "/zones/{args.identifier}/access/apps", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an application from Access."
  zone_level_access_applications_delete_an_access_application(identifier: String!, app_id: String!): zone_level_access_applications_delete_an_access_application_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a Bookmark application."
  zone_level_access_applications_update_a_bookmark_application(identifier: String!, app_id: String!, input: zone_level_access_applications_update_a_bookmark_application_request_Input): zone_level_access_applications_update_a_bookmark_application_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Revokes all service tokens used by an application."
  zone_level_access_applications_revoke_service_tokens(identifier: String!, app_id: String!): zone_level_access_applications_revoke_service_tokens_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.app_id}/revoke_tokens", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an Access policy."
  zone_level_access_policies_delete_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
  ): zone_level_access_policies_delete_an_access_policy_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update a configured Access policy."
  zone_level_access_policies_update_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid1: components_schemas_uuid!
    "The policy ID."
    uuid: components_schemas_uuid!
    input: zone_level_access_policies_update_an_access_policy_request_Input
  ): zone_level_access_policies_update_an_access_policy_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid1}/policies/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes a short-lived certificate CA."
  zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Generates a new short-lived certificate CA and public key."
  zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid}/ca", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a new Access policy for an application."
  zone_level_access_policies_create_an_access_policy(
    identifier: String!
    "The policy ID."
    uuid: components_schemas_uuid!
    input: zone_level_access_policies_create_an_access_policy_request_Input
  ): zone_level_access_policies_create_an_access_policy_response @httpOperation(path: "/zones/{args.identifier}/access/apps/{args.uuid}/policies", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Adds a new mTLS root certificate to Access."
  zone_level_access_m_tls_authentication_add_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: zone_level_access_m_tls_authentication_add_an_m_tls_certificate_request_Input
  ): zone_level_access_m_tls_authentication_add_an_m_tls_certificate_response @httpOperation(path: "/zones/{args.identifier}/access/certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an mTLS certificate."
  zone_level_access_m_tls_authentication_delete_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_m_tls_authentication_delete_an_m_tls_certificate_response @httpOperation(path: "/zones/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured mTLS certificate."
  zone_level_access_m_tls_authentication_update_an_m_tls_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: zone_level_access_m_tls_authentication_update_an_m_tls_certificate_request_Input
  ): zone_level_access_m_tls_authentication_update_an_m_tls_certificate_response @httpOperation(path: "/zones/{args.identifier}/access/certificates/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new Access group."
  zone_level_access_groups_create_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: zone_level_access_groups_create_an_access_group_request_Input
  ): zone_level_access_groups_create_an_access_group_response @httpOperation(path: "/zones/{args.identifier}/access/groups", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an Access group."
  zone_level_access_groups_delete_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
  ): zone_level_access_groups_delete_an_access_group_response @httpOperation(path: "/zones/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured Access group."
  zone_level_access_groups_update_an_access_group(
    "Identifier"
    identifier: common_components_schemas_identifier
    "The unique identifier for the Access group."
    uuid: JSON!
    input: zone_level_access_groups_update_an_access_group_request_Input
  ): zone_level_access_groups_update_an_access_group_response @httpOperation(path: "/zones/{args.identifier}/access/groups/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a new identity provider to Access."
  zone_level_access_identity_providers_add_an_access_identity_provider(identifier: String!, input: zone_level_access_identity_providers_add_an_access_identity_provider_request_Input): zone_level_access_identity_providers_add_an_access_identity_provider_response @httpOperation(path: "/zones/{args.identifier}/access/identity_providers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an identity provider from Access."
  zone_level_access_identity_providers_delete_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
  ): zone_level_access_identity_providers_delete_an_access_identity_provider_response @httpOperation(path: "/zones/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured identity provider."
  zone_level_access_identity_providers_update_an_access_identity_provider(
    identifier: String!
    "UUID"
    uuid: uuid
    input: zone_level_access_identity_providers_update_an_access_identity_provider_request_Input
  ): zone_level_access_identity_providers_update_an_access_identity_provider_response @httpOperation(path: "/zones/{args.identifier}/access/identity_providers/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Sets up a Zero Trust organization for your account."
  zone_level_zero_trust_organization_create_your_zero_trust_organization(identifier: String!, input: zone_level_zero_trust_organization_create_your_zero_trust_organization_request_Input): zone_level_zero_trust_organization_create_your_zero_trust_organization_response @httpOperation(path: "/zones/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates the configuration for your Zero Trust organization."
  zone_level_zero_trust_organization_update_your_zero_trust_organization(identifier: String!, input: zone_level_zero_trust_organization_update_your_zero_trust_organization_request_Input): zone_level_zero_trust_organization_update_your_zero_trust_organization_response @httpOperation(path: "/zones/{args.identifier}/access/organizations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Revokes a user's access across all applications."
  zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user(identifier: String!, input: zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_request_Input): zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_response @httpOperation(path: "/zones/{args.identifier}/access/organizations/revoke_user", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to create a new service token."
  zone_level_access_service_tokens_create_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: zone_level_access_service_tokens_create_a_service_token_request_Input
  ): zone_level_access_service_tokens_create_a_service_token_response @httpOperation(path: "/zones/{args.identifier}/access/service_tokens", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a service token."
  zone_level_access_service_tokens_delete_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
  ): zone_level_access_service_tokens_delete_a_service_token_response @httpOperation(path: "/zones/{args.identifier}/access/service_tokens/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a configured service token."
  zone_level_access_service_tokens_update_a_service_token(
    "Identifier"
    identifier: common_components_schemas_identifier
    "UUID"
    uuid: uuid
    input: zone_level_access_service_tokens_update_a_service_token_request_Input
  ): zone_level_access_service_tokens_update_a_service_token_response @httpOperation(path: "/zones/{args.identifier}/access/service_tokens/{args.uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Initiates another zone activation check."
  zone_zone_activation_check(identifier: JSON!): zone_zone_activation_check_response @httpOperation(path: "/zones/{args.identifier}/activation_check", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new load balancer."
  load_balancers_create_load_balancer(identifier: String!, input: load_balancers_create_load_balancer_request_Input): load_balancers_create_load_balancer_response @httpOperation(path: "/zones/{args.identifier}/load_balancers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix.\\n\\n**NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume."
  zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix(identifier: JSON!, input: purge_by_cache_tags_or_hosts_or_prefixes_Input): zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix_response @httpOperation(path: "/zones/{args.identifier}/purge_cache", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Sends AXFR zone transfer request to primary nameserver(s)."
  secondary_dns__secondary_zone_force_axfr(identifier: String!): secondary_dns__secondary_zone_force_axfr_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/force_axfr", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete secondary zone configuration for incoming zone transfers."
  secondary_dns__secondary_zone_delete_secondary_zone_configuration(identifier: String!): secondary_dns__secondary_zone_delete_secondary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/incoming", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create secondary zone configuration for incoming zone transfers."
  secondary_dns__secondary_zone_create_secondary_zone_configuration(identifier: String!, input: dns_secondary_secondary_zone_Input): secondary_dns__secondary_zone_create_secondary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/incoming", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update secondary zone configuration for incoming zone transfers."
  secondary_dns__secondary_zone_update_secondary_zone_configuration(identifier: String!, input: dns_secondary_secondary_zone_Input): secondary_dns__secondary_zone_update_secondary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/incoming", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete primary zone configuration for outgoing zone transfers."
  secondary_dns__primary_zone_delete_primary_zone_configuration(identifier: String!): secondary_dns__primary_zone_delete_primary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Create primary zone configuration for outgoing zone transfers."
  secondary_dns__primary_zone_create_primary_zone_configuration(identifier: String!, input: single_request_outgoing_Input): secondary_dns__primary_zone_create_primary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Update primary zone configuration for outgoing zone transfers."
  secondary_dns__primary_zone_update_primary_zone_configuration(identifier: String!, input: single_request_outgoing_Input): secondary_dns__primary_zone_update_primary_zone_configuration_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Disable outgoing zone transfers for primary zone and clears IXFR backlog of primary zone."
  secondary_dns__primary_zone_disable_outgoing_zone_transfers(identifier: String!): secondary_dns__primary_zone_disable_outgoing_zone_transfers_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing/disable", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Enable outgoing zone transfers for primary zone."
  secondary_dns__primary_zone_enable_outgoing_zone_transfers(identifier: String!): secondary_dns__primary_zone_enable_outgoing_zone_transfers_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing/enable", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Notifies the secondary nameserver(s) and clears IXFR backlog of primary zone."
  secondary_dns__primary_zone_force_dns_notify(identifier: String!): secondary_dns__primary_zone_force_dns_notify_response @httpOperation(path: "/zones/{args.identifier}/secondary_dns/outgoing/force_notify", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Returns the set of hostnames, the signature algorithm, and the expiration date of the certificate."
  analyze_certificate_analyze_certificate(
    "Identifier"
    identifier: common_components_schemas_identifier
    input: analyze_certificate_analyze_certificate_request_Input
  ): analyze_certificate_analyze_certificate_response @httpOperation(path: "/zones/{args.identifier}/ssl/analyze", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a zone subscription, either plan or add-ons."
  zone_subscription_create_zone_subscription(
    "Subscription identifier tag."
    identifier: subscription_v2_components_schemas_identifier
    input: subscription_v2_Input
  ): zone_subscription_create_zone_subscription_response @httpOperation(path: "/zones/{args.identifier}/subscription", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates zone subscriptions, either plan or add-ons."
  zone_subscription_update_zone_subscription(
    "Subscription identifier tag."
    identifier: subscription_v2_components_schemas_identifier
    input: subscription_v2_Input
  ): zone_subscription_update_zone_subscription_response @httpOperation(path: "/zones/{args.identifier}/subscription", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set Total TLS Settings or disable the feature for a Zone."
  total_tls_enable_or_disable_total_tls(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: total_tls_enable_or_disable_total_tls_request_Input
  ): total_tls_enable_or_disable_total_tls_response @httpOperation(path: "/zones/{args.zone_identifier}/acm/total_tls", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates enablement of Argo Smart Routing."
  argo_smart_routing_patch_argo_smart_routing_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: patch_Input
  ): argo_smart_routing_patch_argo_smart_routing_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/argo/smart_routing", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information."
  zone_cache_settings_change_cache_reserve_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_cache_settings_change_cache_reserve_setting_request_Input
  ): zone_cache_settings_change_cache_reserve_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/cache/cache_reserve", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers."
  zone_cache_settings_delete_variants_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): zone_cache_settings_delete_variants_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/cache/variants", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers."
  zone_cache_settings_change_variants_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_cache_settings_change_variants_setting_request_Input
  ): zone_cache_settings_change_variants_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/cache/variants", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Upload a new SSL certificate for a zone."
  custom_ssl_for_a_zone_create_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: custom_ssl_for_a_zone_create_ssl_configuration_request_Input
  ): custom_ssl_for_a_zone_create_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates."
  custom_ssl_for_a_zone_re_prioritize_ssl_certificates(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: custom_ssl_for_a_zone_re_prioritize_ssl_certificates_request_Input
  ): custom_ssl_for_a_zone_re_prioritize_ssl_certificates_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates/prioritize", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Remove a SSL certificate from a zone."
  custom_ssl_for_a_zone_delete_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom certificate identifier tag."
    identifier: custom_certificate_components_schemas_identifier
  ): custom_ssl_for_a_zone_delete_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted."
  custom_ssl_for_a_zone_edit_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom certificate identifier tag."
    identifier: custom_certificate_components_schemas_identifier
    input: custom_ssl_for_a_zone_edit_ssl_configuration_request_Input
  ): custom_ssl_for_a_zone_edit_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with 'http' recommended if the CNAME is already in place (or will be soon). Specifying 'email' will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation)."
  custom_hostname_for_a_zone_create_custom_hostname(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: custom_hostname_for_a_zone_create_custom_hostname_request_Input
  ): custom_hostname_for_a_zone_create_custom_hostname_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Fallback Origin for Custom Hostnames"
  custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/fallback_origin", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update Fallback Origin for Custom Hostnames"
  custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_request_Input
  ): custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/fallback_origin", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete Custom Hostname (and any issued SSL certificates)"
  custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom hostname identifier tag."
    identifier: custom_hostname_components_schemas_identifier
  ): custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Modify SSL configuration for a custom hostname. When sent with SSL config that matches existing config, used to indicate that hostname should pass domain control validation (DCV). Can also be used to change validation type, e.g., from 'http' to 'email'."
  custom_hostname_for_a_zone_edit_custom_hostname(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Custom hostname identifier tag."
    identifier: custom_hostname_components_schemas_identifier
    input: custom_hostname_for_a_zone_edit_custom_hostname_request_Input
  ): custom_hostname_for_a_zone_edit_custom_hostname_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_hostnames/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Set Account Custom Nameserver Related Zone Metadata"
  account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_metadata_Input
  ): account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_ns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates the configuration of an existing custom page."
  custom_pages_for_a_zone_update_a_custom_page(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: custom_pages_components_schemas_identifier
    input: custom_pages_for_a_zone_update_a_custom_page_request_Input
  ): custom_pages_for_a_zone_update_a_custom_page_response @httpOperation(path: "/zones/{args.zone_identifier}/custom_pages/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create a new DNS record for a zone. See the record object definitions for required attributes for each record type."
  dns_records_for_a_zone_create_dns_record(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: dns_records_for_a_zone_create_dns_record_request_Input
  ): dns_records_for_a_zone_create_dns_record_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file \\"Zone file\\") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present."
  dns_records_for_a_zone_import_dns_records(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: dns_records_for_a_zone_import_dns_records_request_Input
  ): dns_records_for_a_zone_import_dns_records_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/import", operationSpecificHeaders: "{\\"Content-Type\\":\\"multipart/form-data\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet."
  dns_records_for_a_zone_scan_dns_records(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): dns_records_for_a_zone_scan_dns_records_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/scan", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete DNS Record"
  dns_records_for_a_zone_delete_dns_record(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "DNS record identifier tag."
    identifier: dns_record_components_schemas_identifier
  ): dns_records_for_a_zone_delete_dns_record_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Patch DNS Record"
  dns_records_for_a_zone_patch_dns_record(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "DNS record identifier tag."
    identifier: dns_record_components_schemas_identifier
    input: dns_records_for_a_zone_patch_dns_record_request_Input
  ): dns_records_for_a_zone_patch_dns_record_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update DNS Record"
  dns_records_for_a_zone_update_dns_record(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "DNS record identifier tag."
    identifier: dns_record_components_schemas_identifier
    input: dns_records_for_a_zone_update_dns_record_request_Input
  ): dns_records_for_a_zone_update_dns_record_response @httpOperation(path: "/zones/{args.zone_identifier}/dns_records/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete DNSSEC."
  dnssec_delete_dnssec_records(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): dnssec_delete_dnssec_records_response @httpOperation(path: "/zones/{args.zone_identifier}/dnssec", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Enable or disable DNSSEC."
  dnssec_edit_dnssec_status(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: dnssec_edit_dnssec_status_request_Input
  ): dnssec_edit_dnssec_status_response @httpOperation(path: "/zones/{args.zone_identifier}/dnssec", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Disable your Email Routing zone. Also removes additional MX records previously required for Email Routing to work."
  email_routing_settings_disable_email_routing(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_settings_disable_email_routing_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/disable", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Enable you Email Routing zone. Add and lock the necessary MX and SPF records."
  email_routing_settings_enable_email_routing(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): email_routing_settings_enable_email_routing_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/enable", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Rules consist of a set of criteria for matching emails (such as an email being sent to a specific custom email address) plus a set of actions to take on the email (like forwarding it to a specific destination address)."
  email_routing_routing_rules_create_routing_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: create_rule_properties_Input
  ): email_routing_routing_rules_create_routing_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Enable or disable catch-all routing rule, or change action to forward to specific destination address."
  email_routing_routing_rules_update_catch_all_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: update_catch_all_rule_properties_Input
  ): email_routing_routing_rules_update_catch_all_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules/catch_all", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete a specific routing rule."
  email_routing_routing_rules_delete_routing_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Routing rule identifier."
    rule_identifier: rule_identifier
  ): email_routing_routing_rules_delete_routing_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update actions and matches, or enable/disable specific routing rules."
  email_routing_routing_rules_update_routing_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Routing rule identifier."
    rule_identifier: rule_identifier
    input: update_rule_properties_Input
  ): email_routing_routing_rules_update_routing_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/email/routing/rules/{args.rule_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes one or more existing filters."
  filters_delete_filters(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: filters_delete_filters_request_Input
  ): filters_delete_filters_response @httpOperation(path: "/zones/{args.zone_identifier}/filters", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates one or more filters."
  filters_create_filters(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: filters_create_filters_request_Input
  ): filters_create_filters_response @httpOperation(path: "/zones/{args.zone_identifier}/filters", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates one or more existing filters."
  filters_update_filters(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: filters_update_filters_request_Input
  ): filters_update_filters_response @httpOperation(path: "/zones/{args.zone_identifier}/filters", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes an existing filter."
  filters_delete_a_filter(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the filter."
    id: filters_components_schemas_id
  ): filters_delete_a_filter_response @httpOperation(path: "/zones/{args.zone_identifier}/filters/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing filter."
  filters_update_a_filter(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the filter."
    id: filters_components_schemas_id
    input: filters_update_a_filter_request_Input
  ): filters_update_a_filter_response @httpOperation(path: "/zones/{args.zone_identifier}/filters/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new Zone Lockdown rule."
  zone_lockdown_create_a_zone_lockdown_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_lockdown_create_a_zone_lockdown_rule_request_Input
  ): zone_lockdown_create_a_zone_lockdown_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/lockdowns", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing Zone Lockdown rule."
  zone_lockdown_delete_a_zone_lockdown_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the Zone Lockdown rule."
    id: lockdowns_components_schemas_id
  ): zone_lockdown_delete_a_zone_lockdown_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/lockdowns/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing Zone Lockdown rule."
  zone_lockdown_update_a_zone_lockdown_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the Zone Lockdown rule."
    id: lockdowns_components_schemas_id
    input: zone_lockdown_update_a_zone_lockdown_rule_request_Input
  ): zone_lockdown_update_a_zone_lockdown_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/lockdowns/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes existing firewall rules."
  firewall_rules_delete_firewall_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: firewall_rules_delete_firewall_rules_request_Input
  ): firewall_rules_delete_firewall_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the priority of existing firewall rules."
  firewall_rules_update_priority_of_firewall_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: firewall_rules_update_priority_of_firewall_rules_request_Input
  ): firewall_rules_update_priority_of_firewall_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create one or more firewall rules."
  firewall_rules_create_firewall_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: firewall_rules_create_firewall_rules_request_Input
  ): firewall_rules_create_firewall_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates one or more existing firewall rules."
  firewall_rules_update_firewall_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: firewall_rules_update_firewall_rules_request_Input
  ): firewall_rules_update_firewall_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes an existing firewall rule."
  firewall_rules_delete_a_firewall_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the firewall rule."
    id: firewall_rules_components_schemas_id
    input: firewall_rules_delete_a_firewall_rule_request_Input
  ): firewall_rules_delete_a_firewall_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the priority of an existing firewall rule."
  firewall_rules_update_priority_of_a_firewall_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the firewall rule."
    id: firewall_rules_components_schemas_id
    input: firewall_rules_update_priority_of_a_firewall_rule_request_Input
  ): firewall_rules_update_priority_of_a_firewall_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates an existing firewall rule."
  firewall_rules_update_a_firewall_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the firewall rule."
    id: firewall_rules_components_schemas_id
    input: firewall_rules_update_a_firewall_rule_request_Input
  ): firewall_rules_update_a_firewall_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/rules/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new User Agent Blocking rule in a zone."
  user_agent_blocking_rules_create_a_user_agent_blocking_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: user_agent_blocking_rules_create_a_user_agent_blocking_rule_request_Input
  ): user_agent_blocking_rules_create_a_user_agent_blocking_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/ua_rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing User Agent Blocking rule."
  user_agent_blocking_rules_delete_a_user_agent_blocking_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the User Agent Blocking rule."
    id: ua_rules_components_schemas_id
  ): user_agent_blocking_rules_delete_a_user_agent_blocking_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/ua_rules/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing User Agent Blocking rule."
  user_agent_blocking_rules_update_a_user_agent_blocking_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the User Agent Blocking rule."
    id: ua_rules_components_schemas_id
    input: user_agent_blocking_rules_update_a_user_agent_blocking_rule_request_Input
  ): user_agent_blocking_rules_update_a_user_agent_blocking_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/ua_rules/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a URI-based WAF override for a zone."
  waf_overrides_create_a_waf_override(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: waf_overrides_create_a_waf_override_request_Input
  ): waf_overrides_create_a_waf_override_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/overrides", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing URI-based WAF override."
  waf_overrides_delete_a_waf_override(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the WAF override."
    id: overrides_components_schemas_id
  ): waf_overrides_delete_a_waf_override_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/overrides/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing URI-based WAF override."
  waf_overrides_update_waf_override(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the WAF override."
    id: overrides_components_schemas_id
    input: waf_overrides_update_waf_override_request_Input
  ): waf_overrides_update_waf_override_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/overrides/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates a WAF package. You can update the sensitivity and the action of an anomaly detection WAF package."
  waf_packages_update_a_waf_package(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    identifier: package_components_schemas_identifier
    input: waf_packages_update_a_waf_package_request_Input
  ): waf_packages_update_a_waf_package_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates a WAF rule group. You can update the state (\`mode\` parameter) of a rule group."
  waf_rule_groups_update_a_waf_rule_group(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_identifier: package_components_schemas_identifier
    "The unique identifier of the rule group."
    identifier: group_components_schemas_identifier
    input: waf_rule_groups_update_a_waf_rule_group_request_Input
  ): waf_rule_groups_update_a_waf_rule_group_response @httpOperation(path: "/zones/{args.zone_identifier}/firewall/waf/packages/{args.package_identifier}/groups/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create a new health check."
  health_checks_create_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: query_healthcheck_Input
  ): health_checks_create_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Create a new preview health check."
  health_checks_create_preview_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: query_healthcheck_Input
  ): health_checks_create_preview_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete a health check."
  health_checks_delete_preview_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
  ): health_checks_delete_preview_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/preview/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Delete a health check."
  health_checks_delete_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
  ): health_checks_delete_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Patch a configured health check."
  health_checks_patch_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
    input: query_healthcheck_Input
  ): health_checks_patch_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update a configured health check."
  health_checks_update_health_check(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    identifier: String!
    input: query_healthcheck_Input
  ): health_checks_update_health_check_response @httpOperation(path: "/zones/{args.zone_identifier}/healthchecks/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create Keyless SSL Configuration"
  keyless_ssl_for_a_zone_create_keyless_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: keyless_ssl_for_a_zone_create_keyless_ssl_configuration_request_Input
  ): keyless_ssl_for_a_zone_create_keyless_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/keyless_certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Keyless SSL Configuration"
  keyless_ssl_for_a_zone_delete_keyless_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Keyless certificate identifier tag."
    identifier: keyless_certificate_components_schemas_identifier
  ): keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/keyless_certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "This will update attributes of a Keyless SSL. Consists of one or more of the following:  host,name,port,certificate,enabled."
  keyless_ssl_for_a_zone_edit_keyless_ssl_configuration(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Keyless certificate identifier tag."
    identifier: keyless_certificate_components_schemas_identifier
    input: keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_request_Input
  ): keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_response @httpOperation(path: "/zones/{args.zone_identifier}/keyless_certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Creates a new Logpush job for a zone."
  logpush_jobs_create_logpush_job(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logpush_jobs_create_logpush_job_request_Input
  ): logpush_jobs_create_logpush_job_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/jobs", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a Logpush job."
  logpush_jobs_delete_logpush_job(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Unique id of the job."
    job_identifier: PositiveInt!
  ): logpush_jobs_delete_logpush_job_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/jobs/{args.job_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a Logpush job."
  logpush_jobs_update_logpush_job(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Unique id of the job."
    job_identifier: PositiveInt!
    input: logpush_jobs_update_logpush_job_request_Input
  ): logpush_jobs_update_logpush_job_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/jobs/{args.job_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Gets a new ownership challenge sent to your destination."
  logpush_jobs_get_ownership_challenge(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logpush_jobs_get_ownership_challenge_request_Input
  ): logpush_jobs_get_ownership_challenge_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/ownership", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Validates ownership challenge of the destination."
  logpush_jobs_validate_ownership_challenge(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logpush_jobs_validate_ownership_challenge_request_Input
  ): logpush_jobs_validate_ownership_challenge_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/ownership/validate", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Checks if there is an existing job with a destination."
  logpush_jobs_check_destination_exists(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logpush_jobs_check_destination_exists_request_Input
  ): logpush_jobs_check_destination_exists_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/validate/destination/exists", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Validates logpull origin with logpull_options."
  logpush_jobs_validate_origin(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logpush_jobs_validate_origin_request_Input
  ): logpush_jobs_validate_origin_response @httpOperation(path: "/zones/{args.zone_identifier}/logpush/validate/origin", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates log retention flag for Logpull API."
  logs_received_update_log_retention_flag(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: logs_received_update_log_retention_flag_request_Input
  ): logs_received_update_log_retention_flag_response @httpOperation(path: "/zones/{args.zone_identifier}/logs/control/retention/flag", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use."
  zone_level_authenticated_origin_pulls_upload_certificate(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_level_authenticated_origin_pulls_upload_certificate_request_Input
  ): zone_level_authenticated_origin_pulls_upload_certificate_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Associate a hostname to a certificate and enable, disable or invalidate the association. If disabled, client certificate will not be sent to the hostname even if activated at the zone level. 100 maximum associations on a single certificate are allowed. Note: Use a null value for parameter *enabled* to invalidate the association."
  per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_request_Input
  ): per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Upload a certificate to be used for client authentication on a hostname. 10 hostname certificates per zone are allowed."
  per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_request_Input
  ): per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames/certificates", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Hostname Client Certificate"
  per_hostname_authenticated_origin_pull_delete_hostname_client_certificate(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Certificate identifier tag."
    identifier: hostname_authenticated_origin_pull_components_schemas_identifier
  ): per_hostname_authenticated_origin_pull_delete_hostname_client_certificate_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/hostnames/certificates/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use."
  zone_level_authenticated_origin_pulls_set_enablement_for_zone(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_level_authenticated_origin_pulls_set_enablement_for_zone_request_Input
  ): zone_level_authenticated_origin_pulls_set_enablement_for_zone_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/settings", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete Certificate"
  zone_level_authenticated_origin_pulls_delete_certificate(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Certificate identifier tag."
    identifier: zone_authenticated_origin_pull_components_schemas_identifier
  ): zone_level_authenticated_origin_pulls_delete_certificate_response @httpOperation(path: "/zones/{args.zone_identifier}/origin_tls_client_auth/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a new Page Rule."
  page_rules_create_a_page_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: page_rules_create_a_page_rule_request_Input
  ): page_rules_create_a_page_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing Page Rule."
  page_rules_delete_a_page_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): page_rules_delete_a_page_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates one or more fields of an existing Page Rule."
  page_rules_edit_a_page_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: page_rules_edit_a_page_rule_request_Input
  ): page_rules_edit_a_page_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Replaces the configuration of an existing Page Rule. The configuration of the updated Page Rule will exactly match the data passed in the API request."
  page_rules_update_a_page_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: page_rules_update_a_page_rule_request_Input
  ): page_rules_update_a_page_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/pagerules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Connect or disconnect a Railgun."
  railgun_connections_for_a_zone_connect_or_disconnect_a_railgun(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Railgun connection identifier tag."
    identifier: railgun_components_schemas_identifier_2
    input: railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_request_Input
  ): railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_response @httpOperation(path: "/zones/{args.zone_identifier}/railguns/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Creates a new rate limit for a zone. Refer to the object definition for a list of required attributes."
  rate_limits_for_a_zone_create_a_rate_limit(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: rate_limits_for_a_zone_create_a_rate_limit_request_Input
  ): rate_limits_for_a_zone_create_a_rate_limit_response @httpOperation(path: "/zones/{args.zone_identifier}/rate_limits", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing rate limit."
  rate_limits_for_a_zone_delete_a_rate_limit(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the rate limit."
    id: rate_limits_components_schemas_id
  ): rate_limits_for_a_zone_delete_a_rate_limit_response @httpOperation(path: "/zones/{args.zone_identifier}/rate_limits/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing rate limit."
  rate_limits_for_a_zone_update_a_rate_limit(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier of the rate limit."
    id: rate_limits_components_schemas_id
    input: rate_limits_for_a_zone_update_a_rate_limit_request_Input
  ): rate_limits_for_a_zone_update_a_rate_limit_response @httpOperation(path: "/zones/{args.zone_identifier}/rate_limits/{args.id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Edit settings for a zone."
  zone_settings_edit_zone_settings_info(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_edit_zone_settings_info_request_Input
  ): zone_settings_edit_zone_settings_info_response @httpOperation(path: "/zones/{args.zone_identifier}/settings", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes the 0-RTT session resumption setting."
  zone_settings_change_0_rtt_session_resumption_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_0_rtt_session_resumption_setting_request_Input
  ): zone_settings_change_0_rtt_session_resumption_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/0rtt", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
  zone_settings_change_always_online_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_always_online_setting_request_Input
  ): zone_settings_change_always_online_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/always_online", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
  zone_settings_change_always_use_https_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_always_use_https_setting_request_Input
  ): zone_settings_change_always_use_https_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/always_use_https", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enable the Automatic HTTPS Rewrites feature for this zone."
  zone_settings_change_automatic_https_rewrites_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_automatic_https_rewrites_setting_request_Input
  ): zone_settings_change_automatic_https_rewrites_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/automatic_https_rewrites", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts."
  zone_settings_change_automatic_platform_optimization_for_word_press_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_automatic_platform_optimization_for_word_press_settings_request_Input
  ): zone_settings_change_automatic_platform_optimization_for_word_press_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/automatic_platform_optimization", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
  zone_settings_change_brotli_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_brotli_setting_request_Input
  ): zone_settings_change_brotli_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/brotli", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
  zone_settings_change_browser_cache_ttl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_browser_cache_ttl_setting_request_Input
  ): zone_settings_change_browser_cache_ttl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/browser_cache_ttl", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
  zone_settings_change_browser_check_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_browser_check_setting_request_Input
  ): zone_settings_change_browser_check_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/browser_check", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
  zone_settings_change_cache_level_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_cache_level_setting_request_Input
  ): zone_settings_change_cache_level_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/cache_level", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
  zone_settings_change_challenge_ttl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_challenge_ttl_setting_request_Input
  ): zone_settings_change_challenge_ttl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/challenge_ttl", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes ciphers setting."
  zone_settings_change_ciphers_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_ciphers_setting_request_Input
  ): zone_settings_change_ciphers_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ciphers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
  zone_settings_change_development_mode_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_development_mode_setting_request_Input
  ): zone_settings_change_development_mode_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/development_mode", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
  zone_settings_change_early_hints_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_early_hints_setting_request_Input
  ): zone_settings_change_early_hints_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/early_hints", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
  zone_settings_change_email_obfuscation_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_email_obfuscation_setting_request_Input
  ): zone_settings_change_email_obfuscation_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/email_obfuscation", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes HTTP/2 Edge Prioritization setting."
  zone_settings_change_http__2_edge_prioritization_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_http__2_edge_prioritization_setting_request_Input
  ): zone_settings_change_http__2_edge_prioritization_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/h2_prioritization", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
  zone_settings_change_hotlink_protection_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_hotlink_protection_setting_request_Input
  ): zone_settings_change_hotlink_protection_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/hotlink_protection", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Value of the HTTP2 setting."
  zone_settings_change_h_t_t_p_2_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_h_t_t_p_2_setting_request_Input
  ): zone_settings_change_h_t_t_p_2_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/http2", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Value of the HTTP3 setting."
  zone_settings_change_h_t_t_p_3_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_h_t_t_p_3_setting_request_Input
  ): zone_settings_change_h_t_t_p_3_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/http3", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
  zone_settings_change_image_resizing_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_image_resizing_setting_request_Input
  ): zone_settings_change_image_resizing_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/image_resizing", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
  zone_settings_change_ip_geolocation_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_ip_geolocation_setting_request_Input
  ): zone_settings_change_ip_geolocation_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ip_geolocation", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
  zone_settings_change_i_pv6_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_i_pv6_setting_request_Input
  ): zone_settings_change_i_pv6_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ipv6", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes Minimum TLS Version setting."
  zone_settings_change_minimum_tls_version_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_minimum_tls_version_setting_request_Input
  ): zone_settings_change_minimum_tls_version_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/min_tls_version", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
  zone_settings_change_minify_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_minify_setting_request_Input
  ): zone_settings_change_minify_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/minify", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
  zone_settings_change_mirage_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_mirage_setting_request_Input
  ): zone_settings_change_mirage_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/mirage", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
  zone_settings_change_mobile_redirect_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_mobile_redirect_setting_request_Input
  ): zone_settings_change_mobile_redirect_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/mobile_redirect", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enable Network Error Logging reporting on your zone. (Beta) "
  zone_settings_change_network_error_logging_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_network_error_logging_setting_request_Input
  ): zone_settings_change_network_error_logging_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/nel", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes Opportunistic Encryption setting."
  zone_settings_change_opportunistic_encryption_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_opportunistic_encryption_setting_request_Input
  ): zone_settings_change_opportunistic_encryption_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/opportunistic_encryption", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
  zone_settings_change_opportunistic_onion_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_opportunistic_onion_setting_request_Input
  ): zone_settings_change_opportunistic_onion_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/opportunistic_onion", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
  zone_settings_change_orange_to_orange__o_2_o(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_orange_to_orange__o_2_o_request_Input
  ): zone_settings_change_orange_to_orange__o_2_o_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/orange_to_orange", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
  zone_settings_change_enable_error_pages_on_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_enable_error_pages_on_setting_request_Input
  ): zone_settings_change_enable_error_pages_on_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/origin_error_page_pass_thru", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.)."
  zone_settings_change_origin_max_http_version_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_origin_max_http_version_setting_request_Input
  ): zone_settings_change_origin_max_http_version_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/origin_max_http_version", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
  zone_settings_change_polish_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_polish_setting_request_Input
  ): zone_settings_change_polish_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/polish", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
  zone_settings_change_prefetch_preload_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_prefetch_preload_setting_request_Input
  ): zone_settings_change_prefetch_preload_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/prefetch_preload", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
  zone_settings_change_privacy_pass_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_privacy_pass_setting_request_Input
  ): zone_settings_change_privacy_pass_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/privacy_pass", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Maximum time between two read operations from origin."
  zone_settings_change_proxy_read_timeout_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_proxy_read_timeout_setting_request_Input
  ): zone_settings_change_proxy_read_timeout_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/proxy_read_timeout", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Value of the Pseudo IPv4 setting."
  zone_settings_change_pseudo_i_pv4_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_pseudo_i_pv4_setting_request_Input
  ): zone_settings_change_pseudo_i_pv4_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/pseudo_ipv4", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
  zone_settings_change_response_buffering_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_response_buffering_setting_request_Input
  ): zone_settings_change_response_buffering_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/response_buffering", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
  zone_settings_change_rocket_loader_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_rocket_loader_setting_request_Input
  ): zone_settings_change_rocket_loader_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/rocket_loader", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Cloudflare security header for a zone."
  zone_settings_change_security_header__hsts_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_security_header__hsts_setting_request_Input
  ): zone_settings_change_security_header__hsts_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/security_header", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
  zone_settings_change_security_level_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_security_level_setting_request_Input
  ): zone_settings_change_security_level_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/security_level", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
  zone_settings_change_server_side_exclude_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_server_side_exclude_setting_request_Input
  ): zone_settings_change_server_side_exclude_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/server_side_exclude", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
  zone_settings_change_enable_query_string_sort_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_enable_query_string_sort_setting_request_Input
  ): zone_settings_change_enable_query_string_sort_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/sort_query_string_for_cache", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
  zone_settings_change_ssl_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_ssl_setting_request_Input
  ): zone_settings_change_ssl_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ssl", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
  zone_settings_change_ssl__tls_recommender_enrollment(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_ssl__tls_recommender_enrollment_request_Input
  ): zone_settings_change_ssl__tls_recommender_enrollment_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/ssl_recommender", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes TLS 1.3 setting."
  zone_settings_change_tls_1__3_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_tls_1__3_setting_request_Input
  ): zone_settings_change_tls_1__3_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/tls_1_3", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
  zone_settings_change_tls_client_auth_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_tls_client_auth_setting_request_Input
  ): zone_settings_change_tls_client_auth_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/tls_client_auth", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
  zone_settings_change_true_client_ip_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_true_client_ip_setting_request_Input
  ): zone_settings_change_true_client_ip_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/true_client_ip_header", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
  zone_settings_change_web_application_firewall__waf_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_web_application_firewall__waf_setting_request_Input
  ): zone_settings_change_web_application_firewall__waf_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/waf", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
  zone_settings_change_web_p_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_web_p_setting_request_Input
  ): zone_settings_change_web_p_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/webp", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets)."
  zone_settings_change_web_sockets_setting(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: zone_settings_change_web_sockets_setting_request_Input
  ): zone_settings_change_web_sockets_setting_response @httpOperation(path: "/zones/{args.zone_identifier}/settings/websockets", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "For a given zone, order a certificate pack with a list of hostnames."
  certificate_packs_order_certificate_pack(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: certificate_packs_order_certificate_pack_request_Input
  ): certificate_packs_order_certificate_pack_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "For a given zone, order an advanced certificate pack."
  certificate_packs_order_advanced_certificate_manager_certificate_pack(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: certificate_packs_order_advanced_certificate_manager_certificate_pack_request_Input
  ): certificate_packs_order_advanced_certificate_manager_certificate_pack_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs/order", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "For a given zone, delete an advanced certificate pack."
  certificate_packs_delete_advanced_certificate_manager_certificate_pack(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier for a certificate_pack."
    identifier: String
  ): certificate_packs_delete_advanced_certificate_manager_certificate_pack_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "For a given zone, restart validation for an advanced certificate pack.  This is only a validation operation for a Certificate Pack in a validation_timed_out status."
  certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "The unique identifier for a certificate_pack."
    identifier: String
  ): certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/certificate_packs/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Patch Universal SSL Settings for a Zone."
  universal_ssl_settings_for_a_zone_edit_universal_ssl_settings(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: universal_Input
  ): universal_ssl_settings_for_a_zone_edit_universal_ssl_settings_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/universal/settings", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method."
  ssl_verification_edit_ssl_certificate_pack_validation_method(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Certificate Pack UUID."
    cert_pack_uuid: String!
    input: components_schemas_validation_method_Input
  ): ssl_verification_edit_ssl_certificate_pack_validation_method_response @httpOperation(path: "/zones/{args.zone_identifier}/ssl/verification/{args.cert_pack_uuid}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Creates a new waiting room."
  waiting_room_create_waiting_room(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: query_waitingroom_Input
  ): waiting_room_create_waiting_room_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form \`http://waitingrooms.dev/preview/<uuid>\`. You can use the following query parameters to change the state of the preview:\\n1. \`force_queue\`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll).\\n2. \`queue_is_full\`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.\\n3. \`queueing_method\`: The queueing method currently used by the waiting room.\\n\\t- **fifo** indicates a FIFO queue.\\n\\t- **random** indicates a Random queue.\\n\\t- **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if \`force_queue=true\` or \`event=prequeueing\` — for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning \\"Welcome\\". \\n\\t- **reject** indicates a Reject queue.\\n4. \`event\`: Used to preview a waiting room event.\\n\\t- **none** indicates no event is occurring.\\n\\t- **prequeueing** indicates that an event is prequeueing (between \`prequeue_start_time\` and \`event_start_time\`).\\n\\t- **started** indicates that an event has started (between \`event_start_time\` and \`event_end_time\`).\\n5. \`shuffle_at_event_start\`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (\`event\` is not **none**).\\n\\nFor example, you can make a request to \`http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true\`\\n6. \`waitTime\`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.\\n\\nFor example, you can make a request to \`http://waitingrooms.dev/preview/<uuid>?waitTime=50\` to configure the estimated wait time as 50 minutes."
  waiting_room_create_a_custom_waiting_room_page_preview(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: query_preview_Input
  ): waiting_room_create_a_custom_waiting_room_page_preview_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/preview", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a waiting room."
  waiting_room_delete_waiting_room(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
  ): waiting_room_delete_waiting_room_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Patches a configured waiting room."
  waiting_room_patch_waiting_room(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    input: query_waitingroom_Input
  ): waiting_room_patch_waiting_room_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates a configured waiting room."
  waiting_room_update_waiting_room(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    input: query_waitingroom_Input
  ): waiting_room_update_waiting_room_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time."
  waiting_room_create_event(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    input: query_event_Input
  ): waiting_room_create_event_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an event for a waiting room."
  waiting_room_delete_event(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    event_id: String!
  ): waiting_room_delete_event_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events/{args.event_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Patches a configured event for a waiting room."
  waiting_room_patch_event(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    event_id: String!
    input: query_event_Input
  ): waiting_room_patch_event_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events/{args.event_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates a configured event for a waiting room."
  waiting_room_update_event(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    event_id: String!
    input: query_event_Input
  ): waiting_room_update_event_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/events/{args.event_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room."
  waiting_room_create_waiting_room_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    input: create_rule_Input
  ): waiting_room_create_waiting_room_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room."
  waiting_room_replace_waiting_room_rules(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    input: [create_rule_Input]
  ): waiting_room_replace_waiting_room_rules_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes a rule for a waiting room."
  waiting_room_delete_waiting_room_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    "The ID of the rule."
    rule_id: String!
  ): waiting_room_delete_waiting_room_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Patches a rule for a waiting room."
  waiting_room_patch_waiting_room_rule(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    waiting_room_id: String!
    "The ID of the rule."
    rule_id: String!
    input: patch_rule_Input
  ): waiting_room_patch_waiting_room_rule_response @httpOperation(path: "/zones/{args.zone_identifier}/waiting_rooms/{args.waiting_room_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Create Web3 Hostname"
  web3_hostname_create_web3_hostname(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: create_request_Input
  ): web3_hostname_create_web3_hostname_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Web3 Hostname"
  web3_hostname_delete_web3_hostname(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
  ): web3_hostname_delete_web3_hostname_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Edit Web3 Hostname"
  web3_hostname_edit_web3_hostname(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: modify_request_Input
  ): web3_hostname_edit_web3_hostname_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Update IPFS Universal Path Gateway Content List"
  web3_hostname_update_ipfs_universal_path_gateway_content_list(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: content_list_update_request_Input
  ): web3_hostname_update_ipfs_universal_path_gateway_content_list_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create IPFS Universal Path Gateway Content List Entry"
  web3_hostname_create_ipfs_universal_path_gateway_content_list_entry(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    input: content_list_entry_create_request_Input
  ): web3_hostname_create_ipfs_universal_path_gateway_content_list_entry_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list/entries", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete IPFS Universal Path Gateway Content List Entry"
  web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    "Identifier"
    content_list_entry_identifier: common_components_schemas_identifier
  ): web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list/entries/{args.content_list_entry_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Edit IPFS Universal Path Gateway Content List Entry"
  web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    "Identifier"
    identifier: common_components_schemas_identifier
    "Identifier"
    content_list_entry_identifier: common_components_schemas_identifier
    input: content_list_entry_create_request_Input
  ): web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry_response @httpOperation(path: "/zones/{args.zone_identifier}/web3/hostnames/{args.identifier}/ipfs_universal_path/content_list/entries/{args.content_list_entry_identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Delete your worker. This call has no response body on a successful delete."
  worker_script__deprecated_delete_worker(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
  ): JSON @httpOperation(path: "/zones/{args.zone_identifier}/workers/script", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Upload a worker, or a new version of a worker."
  worker_script__deprecated_upload_worker(
    "Identifier"
    zone_identifier: common_components_schemas_identifier
    input: String
  ): worker_script__deprecated_upload_worker_response @httpOperation(path: "/zones/{args.zone_identifier}/workers/script", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/javascript\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Triggeres a new activation check for a PENDING Zone. This can be\\ntriggered every 5 min for paygo/ent customers, every hour for FREE\\nZones."
  put_zones_zone_id_activation_check(
    "Identifier"
    zone_id: identifier
  ): put_zones_zone_id_activation_check_response @httpOperation(path: "/zones/{args.zone_id}/activation_check", operationSpecificHeaders: "{\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Set configuration properties"
  api_shield_settings_set_configuration_properties(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: configuration_Input
  ): api_shield_settings_set_configuration_properties_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/configuration", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Add one or more operations to a zone. Endpoints can contain path variables. Host, method, endpoint will be normalized to a canoncial form when creating an operation and must be unique on the zone. Inserting an operation that matches an existing one will return the record of the already existing operation and update its last_updated date."
  api_shield_endpoint_management_add_operations_to_a_zone(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: [mutationInput_api_shield_endpoint_management_add_operations_to_a_zone_input_items_Input]
  ): api_shield_endpoint_management_add_operations_to_a_zone_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/operations", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete an operation"
  api_shield_endpoint_management_delete_an_operation(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The ID that identifies the API operation."
    operation_id: JSON!
  ): api_shield_endpoint_management_delete_an_operation_response @httpOperation(path: "/zones/{args.zone_id}/api_gateway/operations/{args.operation_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Creates a new IP Access rule for a zone.\\n\\nNote: To create an IP Access rule that applies to multiple zones, refer to [IP Access rules for a user](#ip-access-rules-for-a-user) or [IP Access rules for an account](#ip-access-rules-for-an-account) as appropriate."
  ip_access_rules_for_a_zone_create_an_ip_access_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: ip_access_rules_for_a_zone_create_an_ip_access_rule_request_Input
  ): ip_access_rules_for_a_zone_create_an_ip_access_rule_response @httpOperation(path: "/zones/{args.zone_id}/firewall/access_rules/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an IP Access rule defined at the zone level.\\n\\nOptionally, you can use the \`cascade\` property to specify that you wish to delete similar rules in other zones managed by the same zone owner."
  ip_access_rules_for_a_zone_delete_an_ip_access_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The unique identifier of the IP Access rule."
    identifier: rule_components_schemas_identifier
    input: ip_access_rules_for_a_zone_delete_an_ip_access_rule_request_Input
  ): ip_access_rules_for_a_zone_delete_an_ip_access_rule_response @httpOperation(path: "/zones/{args.zone_id}/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an IP Access rule defined at the zone level. You can only update the rule action (\`mode\` parameter) and notes."
  ip_access_rules_for_a_zone_update_an_ip_access_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The unique identifier of the IP Access rule."
    identifier: rule_components_schemas_identifier
    input: ip_access_rules_for_a_zone_update_an_ip_access_rule_request_Input
  ): ip_access_rules_for_a_zone_update_an_ip_access_rule_response @httpOperation(path: "/zones/{args.zone_id}/firewall/access_rules/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates a WAF rule. You can only update the mode/action of the rule."
  waf_rules_update_a_waf_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "The unique identifier of a WAF package."
    package_id: package_components_schemas_identifier
    "The unique identifier of the WAF rule."
    identifier: rule_components_schemas_identifier_2
    input: waf_rules_update_a_waf_rule_request_Input
  ): waf_rules_update_a_waf_rule_response @httpOperation(path: "/zones/{args.zone_id}/firewall/waf/packages/{args.package_id}/rules/{args.identifier}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates the status of one or more Managed Transforms."
  managed_transforms_update_status_of_managed_transforms(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: managed_transforms_update_status_of_managed_transforms_request_Input
  ): managed_transforms_update_status_of_managed_transforms_response @httpOperation(path: "/zones/{args.zone_id}/managed_headers", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Updates Page Shield settings."
  page_shield_update_page_shield_settings(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: page_shield_update_page_shield_settings_request_Input
  ): page_shield_update_page_shield_settings_response @httpOperation(path: "/zones/{args.zone_id}/page_shield", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a ruleset at the zone level."
  zone_rulesets_create_a_zone_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: create_ruleset_Input
  ): zone_rulesets_create_a_zone_ruleset_response @httpOperation(path: "/zones/{args.zone_id}/rulesets", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Updates the Custom Error Responses of a zone."
  custom_error_responses_update_custom_error_responses(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: update_ruleset_Input
  ): custom_error_responses_update_custom_error_responses_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/http_custom_errors/entrypoint", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates the Transform Rules of a zone."
  transform_rules_update_transform_rules(
    "Identifier"
    zone_id: common_components_schemas_identifier
    phase: schemas_phase!
    input: update_ruleset_Input
  ): transform_rules_update_transform_rules_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.phase}/entrypoint", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Updates a zone entry point ruleset, creating a new version."
  zone_rulesets_update_a_zone_entry_point_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_phase: phase!
    input: update_ruleset_Input
  ): zone_rulesets_update_a_zone_entry_point_ruleset_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/phases/{args.ruleset_phase}/entrypoint", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Deletes all versions of an existing zone ruleset."
  zone_rulesets_delete_a_zone_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
  ): JSON @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a zone ruleset, creating a new version."
  zone_rulesets_update_a_zone_ruleset(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    input: update_ruleset_Input
  ): zone_rulesets_update_a_zone_ruleset_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Adds a new rule to a zone ruleset. The rule will be added to the end of the existing list of rules in the ruleset."
  zone_rulesets_create_a_zone_ruleset_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    input: create_update_rule_Input
  ): zone_rulesets_create_a_zone_ruleset_rule_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/rules", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes an existing rule from a zone ruleset."
  zone_rulesets_delete_a_zone_ruleset_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    "The unique ID of the rule."
    rule_id: String!
  ): zone_rulesets_delete_a_zone_ruleset_rule_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates an existing rule in a zone ruleset."
  zone_rulesets_update_a_zone_ruleset_rule(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    "The unique ID of the rule."
    rule_id: String!
    input: create_update_rule_Input
  ): zone_rulesets_update_a_zone_ruleset_rule_response @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/rules/{args.rule_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PATCH)
  "Deletes an existing version of a zone ruleset."
  zone_rulesets_delete_a_zone_ruleset_version(
    "Identifier"
    zone_id: common_components_schemas_identifier
    ruleset_id: rulesets_components_schemas_id!
    ruleset_version: version!
  ): JSON @httpOperation(path: "/zones/{args.zone_id}/rulesets/{args.ruleset_id}/versions/{args.ruleset_version}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates the URL normalization settings."
  url_normalization_update_url_normalization_settings(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: schemas_request_model_Input
  ): url_normalization_update_url_normalization_settings_response @httpOperation(path: "/zones/{args.zone_id}/url_normalization", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create Filter"
  worker_filters__deprecated_create_filter(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: filter_no_id_Input
  ): worker_filters__deprecated_create_filter_response @httpOperation(path: "/zones/{args.zone_id}/workers/filters", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Filter"
  worker_filters__deprecated_delete_filter(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "Identifier"
    filter_id: common_components_schemas_identifier
  ): worker_filters__deprecated_delete_filter_response @httpOperation(path: "/zones/{args.zone_id}/workers/filters/{args.filter_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update Filter"
  worker_filters__deprecated_update_filter(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "Identifier"
    filter_id: common_components_schemas_identifier
    input: filter_no_id_Input
  ): worker_filters__deprecated_update_filter_response @httpOperation(path: "/zones/{args.zone_id}/workers/filters/{args.filter_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Create Route"
  worker_routes_create_route(
    "Identifier"
    zone_id: common_components_schemas_identifier
    input: route_no_id_Input
  ): worker_routes_create_route_response @httpOperation(path: "/zones/{args.zone_id}/workers/routes", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Delete Route"
  worker_routes_delete_route(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "Identifier"
    route_id: common_components_schemas_identifier
  ): worker_routes_delete_route_response @httpOperation(path: "/zones/{args.zone_id}/workers/routes/{args.route_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Update Route"
  worker_routes_update_route(
    "Identifier"
    zone_id: common_components_schemas_identifier
    "Identifier"
    route_id: common_components_schemas_identifier
    input: route_no_id_Input
  ): worker_routes_update_route_response @httpOperation(path: "/zones/{args.zone_id}/workers/routes/{args.route_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
  "Creates a new Spectrum application from a configuration using a name for the origin."
  spectrum_applications_create_spectrum_application_using_a_name_for_the_origin(
    "Identifier"
    zone: common_components_schemas_identifier
    input: spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_request_Input
  ): spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_response @httpOperation(path: "/zones/{args.zone}/spectrum/apps", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: POST)
  "Deletes a previously existing application."
  spectrum_applications_delete_spectrum_application(
    "Identifier"
    zone: common_components_schemas_identifier
    "Application identifier."
    app_id: app_id
  ): spectrum_applications_delete_spectrum_application_response @httpOperation(path: "/zones/{args.zone}/spectrum/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: DELETE)
  "Updates a previously existing application's configuration that uses a name for the origin."
  spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin(
    "Identifier"
    zone: common_components_schemas_identifier
    "Application identifier."
    app_id: app_id
    input: spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_request_Input
  ): spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_response @httpOperation(path: "/zones/{args.zone}/spectrum/apps/{args.app_id}", operationSpecificHeaders: "{\\"Content-Type\\":\\"application/json\\",\\"accept\\":\\"application/json\\"}", httpMethod: PUT)
}

union ip_address_management_address_maps_remove_an_account_membership_from_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_remove_an_account_membership_from_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_remove_an_account_membership_from_an_address_map_4xx_response

type ip_address_management_address_maps_remove_an_account_membership_from_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_add_an_account_membership_to_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_add_an_account_membership_to_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_add_an_account_membership_to_an_address_map_4xx_response

type ip_address_management_address_maps_add_an_account_membership_to_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_create_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "full_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_create_address_map_4xx_response") = full_response | ip_address_management_address_maps_create_address_map_4xx_response

type ip_address_management_address_maps_create_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_address_maps_create_address_map_request_Input {
  "An optional description field which may be used to describe the types of IPs or zones on the map."
  description: String
}

union ip_address_management_address_maps_delete_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_delete_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_delete_address_map_4xx_response

type ip_address_management_address_maps_delete_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_update_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "address_maps_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_update_address_map_4xx_response") = address_maps_components_schemas_single_response | ip_address_management_address_maps_update_address_map_4xx_response

type address_maps_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: address_maps
  "Whether the API call was successful"
  success: Boolean!
}

type ip_address_management_address_maps_update_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_address_maps_update_address_map_request_Input {
  "If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account."
  default_sni: String
  "An optional description field which may be used to describe the types of IPs or zones on the map."
  description: String
}

union ip_address_management_address_maps_remove_an_ip_from_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_remove_an_ip_from_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_remove_an_ip_from_an_address_map_4xx_response

type ip_address_management_address_maps_remove_an_ip_from_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_add_an_ip_to_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_add_an_ip_to_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_add_an_ip_to_an_address_map_4xx_response

type ip_address_management_address_maps_add_an_ip_to_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map_4xx_response

type ip_address_management_address_maps_remove_a_zone_membership_from_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_address_maps_add_a_zone_membership_to_an_address_map_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_address_maps_add_a_zone_membership_to_an_address_map_4xx_response") = api_response_collection | ip_address_management_address_maps_add_a_zone_membership_to_an_address_map_4xx_response

type ip_address_management_address_maps_add_a_zone_membership_to_an_address_map_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_prefixes_upload_loa_document_response @statusCodeTypeName(statusCode: 200, typeName: "loa_upload_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_upload_loa_document_4xx_response") = loa_upload_response | ip_address_management_prefixes_upload_loa_document_4xx_response

type loa_upload_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_ip_address_management_prefixes_upload_loa_document_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_ip_address_management_prefixes_upload_loa_document_oneOf_0_allOf_1_result {
  "Name of LOA document."
  filename: String
}

type ip_address_management_prefixes_upload_loa_document_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_prefixes_upload_loa_document_request_Input {
  "LOA document to upload."
  loa_document: String!
}

union ip_address_management_prefixes_add_prefix_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_prefixes_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_add_prefix_4xx_response") = ipam_prefixes_components_schemas_single_response | ip_address_management_prefixes_add_prefix_4xx_response

type ip_address_management_prefixes_add_prefix_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_prefixes_add_prefix_request_Input {
  "Autonomous System Number (ASN) the prefix will be advertised under."
  asn: Int
  "IP Prefix in Classless Inter-Domain Routing format."
  cidr: String!
  "Identifier for the uploaded LOA document."
  loa_document_id: loa_document_identifier
}

union ip_address_management_prefixes_delete_prefix_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_delete_prefix_4xx_response") = api_response_collection | ip_address_management_prefixes_delete_prefix_4xx_response

type ip_address_management_prefixes_delete_prefix_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union ip_address_management_prefixes_update_prefix_description_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_prefixes_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefixes_update_prefix_description_4xx_response") = ipam_prefixes_components_schemas_single_response | ip_address_management_prefixes_update_prefix_description_4xx_response

type ip_address_management_prefixes_update_prefix_description_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_prefixes_update_prefix_description_request_Input {
  "Description of the prefix."
  description: ipam_prefixes_components_schemas_description!
}

union ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_response @statusCodeTypeName(statusCode: 200, typeName: "advertised_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_4xx_response") = advertised_response | ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_4xx_response

type ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_dynamic_advertisement_update_prefix_dynamic_advertisement_status_request_Input {
  "Enablement of prefix advertisement to the Internet."
  advertised: Boolean!
}

union ip_address_management_prefix_delegation_create_prefix_delegation_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_delegations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefix_delegation_create_prefix_delegation_4xx_response") = ipam_delegations_components_schemas_single_response | ip_address_management_prefix_delegation_create_prefix_delegation_4xx_response

type ipam_delegations_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: ipam_delegations
  "Whether the API call was successful"
  success: Boolean!
}

type ip_address_management_prefix_delegation_create_prefix_delegation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_address_management_prefix_delegation_create_prefix_delegation_request_Input {
  "IP Prefix in Classless Inter-Domain Routing format."
  cidr: String!
  "Account identifier for the account to which prefix is being delegated."
  delegated_account_id: delegated_account_identifier
}

union ip_address_management_prefix_delegation_delete_prefix_delegation_response @statusCodeTypeName(statusCode: 200, typeName: "ipam_delegations_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_address_management_prefix_delegation_delete_prefix_delegation_4xx_response") = ipam_delegations_components_schemas_id_response | ip_address_management_prefix_delegation_delete_prefix_delegation_4xx_response

type ipam_delegations_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_ip_address_management_prefix_delegation_delete_prefix_delegation_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_ip_address_management_prefix_delegation_delete_prefix_delegation_oneOf_0_allOf_1_result {
  "Delegation identifier tag."
  id: delegation_identifier!
}

type ip_address_management_prefix_delegation_delete_prefix_delegation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_tunnel_create_cloudflare_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_create_cloudflare_tunnel_4xx_response") = schemas_tunnel_response_single | cloudflare_tunnel_create_cloudflare_tunnel_4xx_response

type cloudflare_tunnel_create_cloudflare_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input cloudflare_tunnel_create_cloudflare_tunnel_request_Input {
  "A user-friendly name chosen when the tunnel is created. Cannot be empty."
  name: String!
  "A secret encoded as a base64 string. The Create Cloudflare Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password."
  tunnel_secret: String!
}

union cloudflare_tunnel_delete_cloudflare_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_delete_cloudflare_tunnel_4xx_response") = schemas_tunnel_response_single | cloudflare_tunnel_delete_cloudflare_tunnel_4xx_response

type cloudflare_tunnel_delete_cloudflare_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_tunnel_update_cloudflare_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_update_cloudflare_tunnel_4xx_response") = schemas_tunnel_response_single | cloudflare_tunnel_update_cloudflare_tunnel_4xx_response

type cloudflare_tunnel_update_cloudflare_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input cloudflare_tunnel_update_cloudflare_tunnel_request_Input {
  "A user-friendly name chosen when the tunnel is created. Cannot be empty."
  name: String
  "A secret encoded as a base64 string. The endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password."
  tunnel_secret: String
}

union cloudflare_tunnel_configuration_put_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "config_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_configuration_put_configuration_4xx_response") = config_response_single | cloudflare_tunnel_configuration_put_configuration_4xx_response

type cloudflare_tunnel_configuration_put_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input cloudflare_tunnel_configuration_put_configuration_request_Input {
  "This is a json that conforms to the same syntax rules as the config.yaml."
  config: JSON
}

union cloudflare_tunnel_clean_up_cloudflare_tunnel_connections_response @statusCodeTypeName(statusCode: 200, typeName: "cloudflare_tunnel_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_tunnel_clean_up_cloudflare_tunnel_connections_4xx_response") = cloudflare_tunnel_components_schemas_empty_response | cloudflare_tunnel_clean_up_cloudflare_tunnel_connections_4xx_response

type cloudflare_tunnel_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_tunnel_clean_up_cloudflare_tunnel_connections_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_pages_for_an_account_update_a_custom_page_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_an_account_update_a_custom_page_4xx_response") = custom_pages_response_single | custom_pages_for_an_account_update_a_custom_page_4xx_response

type custom_pages_for_an_account_update_a_custom_page_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_pages_for_an_account_update_a_custom_page_request_Input {
  state: components_schemas_state!
  "The URL associated with the custom page."
  url: URL!
}

"The custom page state."
enum components_schemas_state {
  default
  customized
}

union diagnostics_traceroute_response @statusCodeTypeName(statusCode: 200, typeName: "traceroute_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "diagnostics_traceroute_4xx_response") = traceroute_response_collection | diagnostics_traceroute_4xx_response

type traceroute_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [target_result]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type target_result {
  colos: [colo_result]
  "The target hostname, IPv6, or IPv6 address."
  target: String
}

type colo_result {
  colo: colo
  error: error
  hops: [hop_result]
  target_summary: target_summary
  "Total time of traceroute in ms."
  traceroute_time_ms: Int
}

type colo {
  "Source colo city."
  city: String
  "Source colo name."
  name: String
}

"Errors resulting from collecting traceroute from colo to target."
enum error {
  _ @enum(value: "\\"\\"")
  Could_not_gather_traceroute_data__Code_1 @enum(value: "\\"Could not gather traceroute data: Code 1\\"")
  Could_not_gather_traceroute_data__Code_2 @enum(value: "\\"Could not gather traceroute data: Code 2\\"")
  Could_not_gather_traceroute_data__Code_3 @enum(value: "\\"Could not gather traceroute data: Code 3\\"")
  Could_not_gather_traceroute_data__Code_4 @enum(value: "\\"Could not gather traceroute data: Code 4\\"")
}

type hop_result {
  "An array of node objects."
  nodes: [node_result]
  "Number of packets where no response was received."
  packets_lost: Int
  "Number of packets sent with specified TTL."
  packets_sent: Int
  "The time to live (TTL)."
  packets_ttl: Int
}

type node_result {
  "AS number associated with the node object."
  asn: String
  "IP address of the node."
  ip: String
  "Field appears if there is an additional annotation printed when the probe returns. Field also appears when running a GRE+ICMP traceroute to denote which traceroute a node comes from."
  labels: [String]
  "Maximum RTT in ms."
  max_rtt_ms: Float
  "Mean RTT in ms."
  mean_rtt_ms: Float
  "Minimum RTT in ms."
  min_rtt_ms: Float
  "Host name of the address, this may be the same as the IP address."
  name: String
  "Number of packets with a response from this node."
  packet_count: Int
  "Standard deviation of the RTTs in ms."
  std_dev_rtt_ms: Float
}

"Aggregated statistics from all hops about the target."
type target_summary {
  asn: String
  ip: String
  max_latency_ms: Float
  mean_latency_ms: Float
  min_latency_ms: Float
  name: String
  packet_count: Int
  std_dev_latency_ms: Float
}

type diagnostics_traceroute_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input diagnostics_traceroute_request_Input {
  "If no source colo names specified, all colos will be used. China colos are unavailable for traceroutes."
  colos: [String]
  options: schemas_options_Input
  targets: [String]!
}

input schemas_options_Input {
  "Max TTL."
  max_ttl: NonNegativeInt = 15
  packet_type: packet_type = icmp
  "Number of packets sent at each TTL."
  packets_per_ttl: NonNegativeInt = 3
  "For UDP and TCP, specifies the destination port. For ICMP, specifies the initial ICMP sequence value. Default value 0 will choose the best value to use for each protocol."
  port: NonNegativeInt
  "Set the time (in seconds) to wait for a response to a probe."
  wait_time: PositiveInt = 1
}

"Integers that will have a value of 0 or more."
scalar NonNegativeInt

"Type of packet sent."
enum packet_type {
  icmp
  tcp
  udp
  gre
  gre_PLUS_icmp @enum(value: "\\"gre+icmp\\"")
}

union dlp_pattern_validation_validate_pattern_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_validate_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_pattern_validation_validate_pattern_4xx_response") = schemas_validate_response | dlp_pattern_validation_validate_pattern_4xx_response

type schemas_validate_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_dlp_pattern_validation_validate_pattern_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_dlp_pattern_validation_validate_pattern_oneOf_0_allOf_1_result {
  valid: Boolean
}

type dlp_pattern_validation_validate_pattern_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A request to validate a pattern"
input validate_pattern_Input {
  "The regex pattern."
  regex: String!
}

union dlp_profiles_create_custom_profiles_response @statusCodeTypeName(statusCode: 200, typeName: "create_custom_profile_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_create_custom_profiles_4xx_response") = create_custom_profile_response | dlp_profiles_create_custom_profiles_4xx_response

type create_custom_profile_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [Custom_profile]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type dlp_profiles_create_custom_profiles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input create_custom_profiles_Input {
  profiles: [new_custom_profile_Input]!
}

input new_custom_profile_Input {
  "The description of the profile."
  description: String
  "The entries for this profile."
  entries: [new_custom_entry_Input]
  "The name of the profile."
  name: String
}

"A custom entry create payload"
input new_custom_entry_Input {
  "Whether the entry is enabled or not."
  enabled: Boolean!
  "The name of the entry."
  name: String!
  pattern: components_schemas_pattern_Input!
}

"A pattern that matches an entry"
input components_schemas_pattern_Input {
  "The regex pattern."
  regex: String!
  validation: luhn_const
}

union dlp_profiles_delete_custom_profile_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_delete_custom_profile_4xx_response") = api_response_single | dlp_profiles_delete_custom_profile_4xx_response

type dlp_profiles_delete_custom_profile_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dlp_profiles_update_custom_profile_response @statusCodeTypeName(statusCode: 200, typeName: "Custom_profile") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_update_custom_profile_4xx_response") = Custom_profile | dlp_profiles_update_custom_profile_4xx_response

type dlp_profiles_update_custom_profile_4xx_response {
  created_at: DateTime
  "The description of the profile."
  description: String
  "The entries for this profile."
  entries: [custom_entry]
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: custom_const
  updated_at: DateTime
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input Update_custom_profile_Input {
  "The description of the profile."
  description: String
  "The entries for this profile. Array elements with IDs are modifying the existing entry with that ID. Elements without ID will create new entries. Any entry not in the list will be deleted."
  entries: [custom_entry_Input]
  "The name of the profile."
  name: String
}

"A custom entry that matches a profile"
input custom_entry_Input {
  created_at: DateTime
  "Whether the entry is enabled or not."
  enabled: Boolean
  "The ID for this entry"
  id: String
  "The name of the entry."
  name: String
  pattern: components_schemas_pattern_Input
  "ID of the parent profile"
  profile_id: JSON
  updated_at: DateTime
}

union dlp_profiles_update_predefined_profile_response @statusCodeTypeName(statusCode: 200, typeName: "Predefined_profile") @statusCodeTypeName(statusCode: "4xx", typeName: "dlp_profiles_update_predefined_profile_4xx_response") = Predefined_profile | dlp_profiles_update_predefined_profile_4xx_response

type dlp_profiles_update_predefined_profile_4xx_response {
  "The entries for this profile."
  entries: [Predefined_entry]
  "The ID for this profile"
  id: String!
  "The name of the profile."
  name: String
  type: predefined_const
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input Update_predefined_profile_Input {
  "The entries for this profile."
  entries: [mutationInput_dlp_profiles_update_predefined_profile_input_entries_items_Input]
}

input mutationInput_dlp_profiles_update_predefined_profile_input_entries_items_Input {
  "Wheter the entry is enabled or not."
  enabled: Boolean
  "The ID for this entry"
  id: String
}

union dns_firewall_create_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_create_dns_firewall_cluster_4xx_response") = dns_firewall_single_response | dns_firewall_create_dns_firewall_cluster_4xx_response

type dns_firewall_create_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_firewall_create_dns_firewall_cluster_request_Input {
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat = 900
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat = 60
  "DNS Firewall Cluster Name."
  name: dns_firewall_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat
  origin_ips: [JSON]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster)."
  ratelimit: PositiveFloat
}

union dns_firewall_delete_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_delete_dns_firewall_cluster_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_delete_dns_firewall_cluster_4xx_response") = dns_firewall_delete_dns_firewall_cluster_200_response | dns_firewall_delete_dns_firewall_cluster_4xx_response

type dns_firewall_delete_dns_firewall_cluster_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_dns_firewall_delete_dns_firewall_cluster_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_dns_firewall_delete_dns_firewall_cluster_oneOf_0_allOf_1_result {
  "Identifier"
  id: common_components_schemas_identifier!
}

type dns_firewall_delete_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall_update_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall_update_dns_firewall_cluster_4xx_response") = dns_firewall_single_response | dns_firewall_update_dns_firewall_cluster_4xx_response

type dns_firewall_update_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_dns_firewall_Input {
  attack_mitigation: attack_mitigation_Input
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean!
  dns_firewall_ips: [JSON]!
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean!
  "Identifier"
  id: common_components_schemas_identifier
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat! = 900
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat! = 60
  "Last modification of DNS Firewall cluster."
  modified_on: DateTime
  "DNS Firewall Cluster Name."
  name: dns_firewall_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat
  origin_ips: [JSON]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster)."
  ratelimit: PositiveFloat
}

"Attack mitigation settings."
input attack_mitigation_Input {
  "When enabled, random-prefix attacks are automatically mitigated and the origin DNS servers protected."
  enabled: Boolean
  "Only mitigate attacks when origin servers seem unhealthy."
  only_when_origin_unhealthy: Boolean = true
}

union email_routing_destination_addresses_create_a_destination_address_response @statusCodeTypeName(statusCode: 200, typeName: "destination_address_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_destination_addresses_create_a_destination_address_4xx_response") = destination_address_response_single | email_routing_destination_addresses_create_a_destination_address_4xx_response

type email_routing_destination_addresses_create_a_destination_address_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_destination_address_properties_Input {
  "The contact email address of the user."
  email: EmailAddress!
}

union email_routing_destination_addresses_delete_destination_address_response @statusCodeTypeName(statusCode: 200, typeName: "destination_address_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_destination_addresses_delete_destination_address_4xx_response") = destination_address_response_single | email_routing_destination_addresses_delete_destination_address_4xx_response

type email_routing_destination_addresses_delete_destination_address_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_an_account_create_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_an_account_create_an_ip_access_rule_4xx_response") = response_single | ip_access_rules_for_an_account_create_an_ip_access_rule_4xx_response

type ip_access_rules_for_an_account_create_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_an_account_create_an_ip_access_rule_request_Input {
  configuration: schemas_configuration_Input!
  mode: schemas_mode!
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
}

input schemas_configuration_Input @oneOf {
  ip_configuration_Input: ip_configuration_Input
  An_IPv6_address_configuration__Input: An_IPv6_address_configuration__Input
  cidr_configuration_Input: cidr_configuration_Input
  An_ASN_configuration__Input: An_ASN_configuration__Input
  A_country_configuration__Input: A_country_configuration__Input
}

input ip_configuration_Input {
  target: ip_const
  "The IP address to match. This address will be compared to the IP address of incoming requests."
  value: String
}

input An_IPv6_address_configuration__Input {
  target: ip6_const
  "The IPv6 address to match."
  value: IPv6
}

input cidr_configuration_Input {
  target: ip_range_const
  "The IP address range to match. You can only use prefix lengths \`/16\` and \`/24\` for IPv4 ranges, and prefix lengths \`/32\`, \`/48\`, and \`/64\` for IPv6 ranges."
  value: String
}

input An_ASN_configuration__Input {
  target: asn_const
  "The AS number to match."
  value: String
}

input A_country_configuration__Input {
  target: country_const
  "The two-letter ISO-3166-1 alpha-2 code to match. For more information, refer to [IP Access rules: Parameters](https://developers.cloudflare.com/waf/tools/ip-access-rules/parameters/#country)."
  value: String
}

union ip_access_rules_for_an_account_delete_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_an_account_delete_an_ip_access_rule_4xx_response") = api_response_single_id | ip_access_rules_for_an_account_delete_an_ip_access_rule_4xx_response

type api_response_single_id {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_ip_access_rules_for_an_account_delete_an_ip_access_rule_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_ip_access_rules_for_an_account_delete_an_ip_access_rule_oneOf_0_allOf_1_result {
  "Identifier"
  id: common_components_schemas_identifier!
}

type ip_access_rules_for_an_account_delete_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_an_account_update_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_an_account_update_an_ip_access_rule_4xx_response") = response_single | ip_access_rules_for_an_account_update_an_ip_access_rule_4xx_response

type ip_access_rules_for_an_account_update_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_rule_Input {
  "The available actions that a rule can apply to a matched request."
  allowed_modes: [schemas_mode]
  configuration: schemas_configuration_Input!
  "The timestamp of when the rule was created."
  created_on: DateTime
  "The unique identifier of the IP Access rule."
  id: rule_components_schemas_identifier
  mode: schemas_mode!
  "The timestamp of when the rule was last modified."
  modified_on: DateTime
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
  scope: mutationInput_ip_access_rules_for_an_account_update_an_ip_access_rule_input_allOf_1_scope_Input
}

"All zones owned by the user will have the rule applied."
input mutationInput_ip_access_rules_for_an_account_update_an_ip_access_rule_input_allOf_1_scope_Input {
  "The contact email address of the user."
  email: EmailAddress
  "Identifier"
  id: common_components_schemas_identifier
  type: mutationInput_ip_access_rules_for_an_account_update_an_ip_access_rule_input_allOf_1_scope_type
}

"The scope of the rule."
enum mutationInput_ip_access_rules_for_an_account_update_an_ip_access_rule_input_allOf_1_scope_type {
  user
  organization
}

union cloudflare_images_upload_an_image_via_url_response @statusCodeTypeName(statusCode: 200, typeName: "image_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_upload_an_image_via_url_4xx_response") = image_response_single | cloudflare_images_upload_an_image_via_url_4xx_response

type cloudflare_images_upload_an_image_via_url_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input image_basic_upload_via_url_Input {
  metadata: JSON
  "Indicates whether the image requires a signature token for the access."
  requireSignedURLs: Boolean
  "A URL to fetch an image from origin."
  url: URL!
}

union cloudflare_images_create_authenticated_direct_upload_url_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_direct_upload_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_create_authenticated_direct_upload_url_4xx_response") = schemas_direct_upload_response | cloudflare_images_create_authenticated_direct_upload_url_4xx_response

type schemas_direct_upload_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_cloudflare_images_create_authenticated_direct_upload_url_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_cloudflare_images_create_authenticated_direct_upload_url_oneOf_0_allOf_1_result {
  "Image unique identifier."
  id: images_components_schemas_identifier!
  "The URL the unauthenticated upload can be performed to using a single HTTP POST (multipart/form-data) request."
  uploadURL: URL
}

type cloudflare_images_create_authenticated_direct_upload_url_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_direct_upload_request_Input {
  "The date after which the upload will not be accepted. Minimum: Now + 2 minutes. Maximum: Now + 6 hours."
  expiry: DateTime
}

union cloudflare_images_variants_create_a_variant_response @statusCodeTypeName(statusCode: 200, typeName: "variant_simple_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_variants_create_a_variant_4xx_response") = variant_simple_response | cloudflare_images_variants_create_a_variant_4xx_response

type cloudflare_images_variants_create_a_variant_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input variant_generation_request_Input {
  id: variants_components_schemas_identifier!
  "Indicates whether the variant can access an image without a signature, regardless of image access control."
  neverRequireSignedURLs: Boolean
  options: options_Input!
}

"Allows you to define image resizing sizes for different use cases."
input options_Input {
  fit: fit!
  "Maximum height in image pixels."
  height: PositiveFloat!
  metadata: schemas_metadata!
  "Maximum width in image pixels."
  width: PositiveFloat!
}

"The fit property describes how the width and height dimensions should be interpreted."
enum fit {
  scale_down @enum(value: "\\"scale-down\\"")
  contain
  cover
  crop
  pad
}

"What EXIF data should be preserved in the output image."
enum schemas_metadata {
  keep
  copyright
  none
}

union cloudflare_images_variants_delete_a_variant_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_variants_delete_a_variant_4xx_response") = schemas_deleted_response | cloudflare_images_variants_delete_a_variant_4xx_response

type schemas_deleted_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type cloudflare_images_variants_delete_a_variant_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_images_variants_update_a_variant_response @statusCodeTypeName(statusCode: 200, typeName: "variant_simple_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_variants_update_a_variant_4xx_response") = variant_simple_response | cloudflare_images_variants_update_a_variant_4xx_response

type cloudflare_images_variants_update_a_variant_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input variant_patch_request_Input {
  "Indicates whether the variant can access an image without a signature, regardless of image access control."
  neverRequireSignedURLs: Boolean
  options: options_Input!
}

union cloudflare_images_delete_image_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_delete_image_4xx_response") = schemas_deleted_response | cloudflare_images_delete_image_4xx_response

type cloudflare_images_delete_image_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union cloudflare_images_update_image_response @statusCodeTypeName(statusCode: 200, typeName: "image_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_update_image_4xx_response") = image_response_single | cloudflare_images_update_image_4xx_response

type cloudflare_images_update_image_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input image_patch_request_Input {
  metadata: JSON
  "Indicates whether the image can be accessed using only its UID. If set to \`true\`, a signed token needs to be generated with a signing key to view the image. Returns a new UID on a change. No change if not specified."
  requireSignedURLs: Boolean
}

union cloudflare_images_create_authenticated_direct_upload_url_v_2_response @statusCodeTypeName(statusCode: 200, typeName: "direct_upload_response_v2") @statusCodeTypeName(statusCode: "4xx", typeName: "cloudflare_images_create_authenticated_direct_upload_url_v_2_4xx_response") = direct_upload_response_v2 | cloudflare_images_create_authenticated_direct_upload_url_v_2_4xx_response

type direct_upload_response_v2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_cloudflare_images_create_authenticated_direct_upload_url_v_2_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_cloudflare_images_create_authenticated_direct_upload_url_v_2_oneOf_0_allOf_1_result {
  "Image unique identifier."
  id: mutation_cloudflare_images_create_authenticated_direct_upload_url_v_2_oneOf_0_allOf_1_result_id
  "The URL the unauthenticated upload can be performed to using a single HTTP POST (multipart/form-data) request."
  uploadURL: URL
}

"Image unique identifier."
scalar mutation_cloudflare_images_create_authenticated_direct_upload_url_v_2_oneOf_0_allOf_1_result_id @length(min: null, max: 32)

type cloudflare_images_create_authenticated_direct_upload_url_v_2_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input direct_upload_request_v2_Input {
  "The date after which the upload will not be accepted. Minimum: Now + 2 minutes. Maximum: Now + 6 hours."
  expiry: DateTime
  metadata: JSON
  "Indicates whether the image requires a signature token to be accessed."
  requireSignedURLs: Boolean
}

union miscategorization_create_miscategorization_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "miscategorization_create_miscategorization_4xx_response") = api_response_single | miscategorization_create_miscategorization_4xx_response

type miscategorization_create_miscategorization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input miscategorization_Input {
  "Content category IDs to add."
  content_adds: [Int]
  "Content category IDs to remove."
  content_removes: [Int]
  indicator_type: mutationInput_miscategorization_create_miscategorization_input_indicator_type
  "Provide only if indicator_type is \`ipv4\` or \`ipv6\`."
  ip: JSON
  "Security category IDs to add."
  security_adds: [Int]
  "Security category IDs to remove."
  security_removes: [Int]
  "Provide only if indicator_type is \`domain\` or \`url\`. Example if indicator_type is \`domain\`: \`example.com\`. Example if indicator_type is \`url\`: \`https://example.com/news/\`."
  url: String
}

enum mutationInput_miscategorization_create_miscategorization_input_indicator_type {
  domain
  ipv4
  ipv6
  url
}

union account_load_balancer_monitors_create_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_create_monitor_4xx_response") = monitor_components_schemas_single_response_2 | account_load_balancer_monitors_create_monitor_4xx_response

type account_load_balancer_monitors_create_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_monitors_create_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times."
  consecutive_down: Int
  "To be marked healthy the monitored origin must pass this healthcheck N consecutive times."
  consecutive_up: Int
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

"The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors."
input header_Input {
  Host: [String]
  X_App_ID: [String] @resolveRootField(field: "X-App-ID")
}

union account_load_balancer_monitors_delete_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_delete_monitor_4xx_response") = monitor_components_schemas_id_response | account_load_balancer_monitors_delete_monitor_4xx_response

type monitor_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_account_load_balancer_monitors_delete_monitor_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_account_load_balancer_monitors_delete_monitor_oneOf_0_allOf_1_result {
  id: String!
}

type account_load_balancer_monitors_delete_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_monitors_patch_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_patch_monitor_4xx_response") = monitor_components_schemas_single_response_2 | account_load_balancer_monitors_patch_monitor_4xx_response

type account_load_balancer_monitors_patch_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_monitors_patch_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times."
  consecutive_down: Int
  "To be marked healthy the monitored origin must pass this healthcheck N consecutive times."
  consecutive_up: Int
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union account_load_balancer_monitors_update_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_update_monitor_4xx_response") = monitor_components_schemas_single_response_2 | account_load_balancer_monitors_update_monitor_4xx_response

type account_load_balancer_monitors_update_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_monitors_update_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times."
  consecutive_down: Int
  "To be marked healthy the monitored origin must pass this healthcheck N consecutive times."
  consecutive_up: Int
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union account_load_balancer_monitors_preview_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "preview_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_monitors_preview_monitor_4xx_response") = preview_response | account_load_balancer_monitors_preview_monitor_4xx_response

type preview_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_account_load_balancer_monitors_preview_monitor_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_account_load_balancer_monitors_preview_monitor_oneOf_0_allOf_1_result {
  pools: mutation_account_load_balancer_monitors_preview_monitor_oneOf_0_allOf_1_result_pools
  preview_id: String!
}

type mutation_account_load_balancer_monitors_preview_monitor_oneOf_0_allOf_1_result_pools {
  abwlnp5jbqn45ecgxd03erbgtxtqai0d: String
  ve8h9lrcip5n5bbga9yqmdws28ay5d0l: String
  additionalProperties: JSON @resolveRoot
}

type account_load_balancer_monitors_preview_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_monitors_preview_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union account_load_balancer_pools_patch_pools_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_patch_pools_4xx_response") = pool_components_schemas_response_collection | account_load_balancer_pools_patch_pools_4xx_response

type account_load_balancer_pools_patch_pools_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input account_load_balancer_pools_patch_pools_request_Input {
  notification_email: patch_pools_notification_email
}

enum patch_pools_notification_email @typescript(type: "\\"\\\\\\"\\\\\\"\\"") @example(value: "\\"\\\\\\"\\\\\\"\\"") {
  _QUOTATION_MARK__QUOTATION_MARK_ @enum(value: "\\"\\\\\\"\\\\\\"\\"")
}

union account_load_balancer_pools_create_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_create_pool_4xx_response") = pool_components_schemas_single_response | account_load_balancer_pools_create_pool_4xx_response

type account_load_balancer_pools_create_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_pools_create_pool_request_Input {
  "A human-readable description of the pool."
  description: String
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String!
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]!
}

"Configures load shedding policies and percentages for the pool."
input load_shedding_Input {
  "The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity."
  default_percent: NonNegativeFloat
  default_policy: query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_load_shedding_default_policy = random
  "The percent of existing sessions to shed from the pool, according to the session policy."
  session_percent: NonNegativeFloat
  session_policy: hash_const
}

"Filter pool and origin health notifications by resource type or health status. Use null to reset."
input notification_filter_Input {
  origin: filter_options_Input
  pool: filter_options_Input
}

"Filter options for a particular resource type (pool or origin). Use null to reset."
input filter_options_Input {
  "If set true, disable notifications for this type of resource (pool or origin)."
  disable: Boolean
  "If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events)."
  healthy: Boolean
}

"Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity."
input origin_steering_Input {
  policy: query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_origin_steering_policy = random
}

input schemas_origin_Input {
  "The IP address (IPv4 or IPv6) of the origin, or the publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare."
  address: String
  "This field shows up only if the origin is disabled. This field is set with the time the origin was disabled."
  disabled_at: DateTime
  "Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool."
  enabled: Boolean = true
  header: schemas_header_Input
  "A human-identifiable name for the origin."
  name: String
  "The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool."
  weight: NonNegativeFloat = 1
}

"The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'."
input schemas_header_Input {
  "The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin."
  Host: [String]
}

union account_load_balancer_pools_delete_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_delete_pool_4xx_response") = pool_components_schemas_id_response | account_load_balancer_pools_delete_pool_4xx_response

type pool_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_account_load_balancer_pools_delete_pool_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_account_load_balancer_pools_delete_pool_oneOf_0_allOf_1_result {
  id: String!
}

type account_load_balancer_pools_delete_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_load_balancer_pools_patch_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_patch_pool_4xx_response") = pool_components_schemas_single_response | account_load_balancer_pools_patch_pool_4xx_response

type account_load_balancer_pools_patch_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_pools_patch_pool_request_Input {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  "A human-readable description of the pool."
  description: String
  "This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at."
  disabled_at: DateTime
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]
}

union account_load_balancer_pools_update_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_update_pool_4xx_response") = pool_components_schemas_single_response | account_load_balancer_pools_update_pool_4xx_response

type account_load_balancer_pools_update_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_pools_update_pool_request_Input {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  "A human-readable description of the pool."
  description: String
  "This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at."
  disabled_at: DateTime
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String!
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]!
}

union account_load_balancer_pools_preview_pool_response @statusCodeTypeName(statusCode: 200, typeName: "preview_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_load_balancer_pools_preview_pool_4xx_response") = preview_response | account_load_balancer_pools_preview_pool_4xx_response

type account_load_balancer_pools_preview_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_load_balancer_pools_preview_pool_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response codes or code ranges of the health check, comma-separated. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union magic_interconnects_update_multiple_interconnects_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_modified_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_interconnects_update_multiple_interconnects_4xx_response") = components_schemas_modified_tunnels_collection_response | magic_interconnects_update_multiple_interconnects_4xx_response

type components_schemas_modified_tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_interconnects_update_multiple_interconnects_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_interconnects_update_multiple_interconnects_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_interconnects: [interconnect]
}

type magic_interconnects_update_multiple_interconnects_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_interconnects_update_multiple_interconnects_request_Input {
  id: JSON!
}

union magic_interconnects_update_interconnect_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_tunnel_modified_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_interconnects_update_interconnect_4xx_response") = components_schemas_tunnel_modified_response | magic_interconnects_update_interconnect_4xx_response

type components_schemas_tunnel_modified_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_interconnects_update_interconnect_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_interconnects_update_interconnect_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_interconnect: JSON
}

type magic_interconnects_update_interconnect_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input components_schemas_tunnel_update_request_Input {
  "An optional description of the interconnect."
  description: String
  gre: gre_Input
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String
  "The Maximum Transmission Unit (MTU) in bytes for the interconnect. The minimum value is 576."
  mtu: Int = 1476
}

"The configuration specific to GRE interconnects."
input gre_Input {
  "The IP address assigned to the Cloudflare side of the GRE tunnel created as part of the Interconnect."
  cloudflare_endpoint: String
  "The IP address assigned to the customer side of the GRE tunnel created as part of the Interconnect."
  customer_endpoint: String
}

union magic_gre_tunnels_create_gre_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_create_gre_tunnels_4xx_response") = tunnels_collection_response | magic_gre_tunnels_create_gre_tunnels_4xx_response

type magic_gre_tunnels_create_gre_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_gre_tunnels_create_gre_tunnels_request_Input {
  name: JSON!
  customer_gre_endpoint: JSON!
  cloudflare_gre_endpoint: JSON!
  interface_address: JSON!
}

union magic_gre_tunnels_update_multiple_gre_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "modified_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_update_multiple_gre_tunnels_4xx_response") = modified_tunnels_collection_response | magic_gre_tunnels_update_multiple_gre_tunnels_4xx_response

type modified_tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_gre_tunnels_update_multiple_gre_tunnels_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_gre_tunnels_update_multiple_gre_tunnels_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_gre_tunnels: [gre_tunnel]
}

type magic_gre_tunnels_update_multiple_gre_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_gre_tunnels_update_multiple_gre_tunnels_request_Input {
  id: JSON!
}

union magic_gre_tunnels_delete_gre_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_delete_gre_tunnel_4xx_response") = tunnel_deleted_response | magic_gre_tunnels_delete_gre_tunnel_4xx_response

type tunnel_deleted_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_gre_tunnels_delete_gre_tunnel_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_gre_tunnels_delete_gre_tunnel_oneOf_0_allOf_1_result {
  deleted: Boolean
  deleted_gre_tunnel: JSON
}

type magic_gre_tunnels_delete_gre_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_gre_tunnels_update_gre_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_modified_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_gre_tunnels_update_gre_tunnel_4xx_response") = tunnel_modified_response | magic_gre_tunnels_update_gre_tunnel_4xx_response

type tunnel_modified_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_gre_tunnels_update_gre_tunnel_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_gre_tunnels_update_gre_tunnel_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_gre_tunnel: JSON
}

type magic_gre_tunnels_update_gre_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_update_request_Input {
  "The IP address assigned to the Cloudflare side of the GRE tunnel."
  cloudflare_gre_endpoint: String!
  "The IP address assigned to the customer side of the GRE tunnel."
  customer_gre_endpoint: String!
  "An optional description of the GRE tunnel."
  description: String
  health_check: health_check_Input
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String!
  "Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576."
  mtu: Int = 1476
  "The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel."
  name: String!
  "Time To Live (TTL) in number of hops of the GRE tunnel."
  ttl: Int = 64
}

input health_check_Input {
  "Determines whether to run healthchecks for a tunnel."
  enabled: Boolean = true
  "The address used to run healthchecks for a tunnel. This field defaults to \`customer_gre_endpoint address\`."
  target: String
  type: query_magic_gre_tunnels_list_gre_tunnels_oneOf_0_allOf_1_result_gre_tunnels_items_health_check_type = reply
}

union magic_i_psec_tunnels_create_i_psec_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_create_i_psec_tunnels_4xx_response") = schemas_tunnels_collection_response | magic_i_psec_tunnels_create_i_psec_tunnels_4xx_response

type magic_i_psec_tunnels_create_i_psec_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_i_psec_tunnels_create_i_psec_tunnels_request_Input {
  name: JSON!
  customer_ipsec_endpoint: JSON!
  cloudflare_ipsec_endpoint: JSON!
  interface_address: JSON!
}

union magic_i_psec_tunnels_update_multiple_i_psec_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_modified_tunnels_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_update_multiple_i_psec_tunnels_4xx_response") = schemas_modified_tunnels_collection_response | magic_i_psec_tunnels_update_multiple_i_psec_tunnels_4xx_response

type schemas_modified_tunnels_collection_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_i_psec_tunnels_update_multiple_i_psec_tunnels_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_i_psec_tunnels_update_multiple_i_psec_tunnels_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_ipsec_tunnels: [ipsec_tunnel]
}

type magic_i_psec_tunnels_update_multiple_i_psec_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_i_psec_tunnels_update_multiple_i_psec_tunnels_request_Input {
  id: JSON!
}

union magic_i_psec_tunnels_delete_i_psec_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_delete_i_psec_tunnel_4xx_response") = schemas_tunnel_deleted_response | magic_i_psec_tunnels_delete_i_psec_tunnel_4xx_response

type schemas_tunnel_deleted_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_i_psec_tunnels_delete_i_psec_tunnel_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_i_psec_tunnels_delete_i_psec_tunnel_oneOf_0_allOf_1_result {
  deleted: Boolean
  deleted_ipsec_tunnel: JSON
}

type magic_i_psec_tunnels_delete_i_psec_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_i_psec_tunnels_update_i_psec_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_tunnel_modified_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_update_i_psec_tunnel_4xx_response") = schemas_tunnel_modified_response | magic_i_psec_tunnels_update_i_psec_tunnel_4xx_response

type schemas_tunnel_modified_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_i_psec_tunnels_update_i_psec_tunnel_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_i_psec_tunnels_update_i_psec_tunnel_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_ipsec_tunnel: JSON
}

type magic_i_psec_tunnels_update_i_psec_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_tunnel_update_request_Input {
  "The IP address assigned to the Cloudflare side of the IPsec tunnel."
  cloudflare_endpoint: String!
  "The IP address assigned to the customer side of the IPsec tunnel."
  customer_endpoint: String
  "An optional description forthe IPsec tunnel."
  description: String
  "A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255."
  interface_address: String!
  "The name of the IPsec tunnel. The name cannot share a name with other tunnels."
  name: String!
  "A randomly generated or provided string for use in the IPsec tunnel."
  psk: String
}

union magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_response @statusCodeTypeName(statusCode: 200, typeName: "psk_generation_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_4xx_response") = psk_generation_response | magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_4xx_response

type psk_generation_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_oneOf_0_allOf_1_result {
  "Identifier"
  ipsec_tunnel_id: common_components_schemas_identifier!
  "A randomly generated or provided string for use in the IPsec tunnel."
  psk: String
  psk_metadata: psk_metadata
}

type magic_i_psec_tunnels_generate_pre_shared_key__psk_for_i_psec_tunnels_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_static_routes_create_routes_response @statusCodeTypeName(statusCode: 200, typeName: "routes_collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_create_routes_4xx_response") = routes_collection_response | magic_static_routes_create_routes_4xx_response

type magic_static_routes_create_routes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input magic_static_routes_create_routes_request_Input {
  prefix: JSON!
  nexthop: JSON!
  priority: JSON!
}

union magic_static_routes_update_many_routes_response @statusCodeTypeName(statusCode: 200, typeName: "multiple_route_modified_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_update_many_routes_4xx_response") = multiple_route_modified_response | magic_static_routes_update_many_routes_4xx_response

type multiple_route_modified_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_static_routes_update_many_routes_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_static_routes_update_many_routes_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_routes: [schemas_route]
}

type magic_static_routes_update_many_routes_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input route_update_many_request_Input {
  routes: [route_update_single_request_Input]!
}

input route_update_single_request_Input {
  "Identifier"
  id: common_components_schemas_identifier
  "An optional human provided description of the static route."
  description: String
  "The next-hop IP Address for the static route."
  nexthop: String!
  "IP Prefix in Classless Inter-Domain Routing format."
  prefix: String!
  "Priority of the static route."
  priority: Int!
  scope: schemas_scope_Input
  "Optional weight of the ECMP scope - if provided."
  weight: Int
}

"Used only for ECMP routes."
input schemas_scope_Input {
  "List of colo names for the ECMP scope."
  colo_names: [String]
  "List of colo regions for the ECMP scope."
  colo_regions: [String]
}

union magic_static_routes_delete_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_delete_route_4xx_response") = route_deleted_response | magic_static_routes_delete_route_4xx_response

type route_deleted_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_static_routes_delete_route_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_static_routes_delete_route_oneOf_0_allOf_1_result {
  deleted: Boolean
  deleted_route: JSON
}

type magic_static_routes_delete_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_static_routes_update_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_modified_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_static_routes_update_route_4xx_response") = route_modified_response | magic_static_routes_update_route_4xx_response

type route_modified_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_magic_static_routes_update_route_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_magic_static_routes_update_route_oneOf_0_allOf_1_result {
  modified: Boolean
  modified_route: JSON
}

type magic_static_routes_update_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input route_update_request_Input {
  "An optional human provided description of the static route."
  description: String
  "The next-hop IP Address for the static route."
  nexthop: String!
  "IP Prefix in Classless Inter-Domain Routing format."
  prefix: String!
  "Priority of the static route."
  priority: Int!
  scope: schemas_scope_Input
  "Optional weight of the ECMP scope - if provided."
  weight: Int
}

union account_members_add_member_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_members_add_member_4xx_response") = response_single | account_members_add_member_4xx_response

type account_members_add_member_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_Input {
  "The contact email address of the user."
  email: EmailAddress!
  "Array of roles associated with this member."
  roles: [role_components_schemas_identifier]!
  status: mutationInput_account_members_add_member_input_status = pending
}

enum mutationInput_account_members_add_member_input_status {
  accepted
  pending
}

union account_members_remove_member_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "account_members_remove_member_4xx_response") = api_response_single_id | account_members_remove_member_4xx_response

type account_members_remove_member_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_members_update_member_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_members_update_member_4xx_response") = response_single | account_members_update_member_4xx_response

type account_members_update_member_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_member_Input {
  "The unique activation code for the account membership."
  code: code
  "Membership identifier tag."
  id: membership_components_schemas_identifier
  "Roles assigned to this member."
  roles: [role_Input]!
  status: JSON
  user: mutationInput_account_members_update_member_input_allOf_0_user_Input
}

input role_Input {
  "Description of role's permissions."
  description: String
  "Role identifier tag."
  id: role_components_schemas_identifier
  "Role name."
  name: mutationInput_account_members_update_member_input_allOf_0_roles_items_name
  permissions: permissions_Input!
}

"Role name."
scalar mutationInput_account_members_update_member_input_allOf_0_roles_items_name @length(min: null, max: 120)

input permissions_Input {
  analytics: grants_Input
  billing: grants_Input
  cache_purge: grants_Input
  dns: grants_Input
  dns_records: grants_Input
  lb: grants_Input
  logs: grants_Input
  organization: grants_Input
  ssl: grants_Input
  waf: grants_Input
  zone_settings: grants_Input
  zones: grants_Input
}

input grants_Input {
  read: Boolean
  write: Boolean
}

input mutationInput_account_members_update_member_input_allOf_0_user_Input {
  "The contact email address of the user."
  email: EmailAddress!
  "User's first name"
  first_name: first_name
  "Identifier"
  id: common_components_schemas_identifier
  "User's last name"
  last_name: last_name
  "Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication."
  two_factor_authentication_enabled: Boolean
}

"User's first name"
scalar first_name @length(min: null, max: 60)

"User's last name"
scalar last_name @length(min: null, max: 60)

union magic_network_monitoring_configuration_delete_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_delete_account_configuration_4xx_response") = mnm_config | magic_network_monitoring_configuration_delete_account_configuration_4xx_response

type magic_network_monitoring_configuration_delete_account_configuration_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_configuration_update_account_configuration_fields_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_update_account_configuration_fields_4xx_response") = mnm_config | magic_network_monitoring_configuration_update_account_configuration_fields_4xx_response

type magic_network_monitoring_configuration_update_account_configuration_fields_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_configuration_create_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_create_account_configuration_4xx_response") = mnm_config | magic_network_monitoring_configuration_create_account_configuration_4xx_response

type magic_network_monitoring_configuration_create_account_configuration_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_configuration_update_an_entire_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_config") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_configuration_update_an_entire_account_configuration_4xx_response") = mnm_config | magic_network_monitoring_configuration_update_an_entire_account_configuration_4xx_response

type magic_network_monitoring_configuration_update_an_entire_account_configuration_4xx_response {
  "Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router."
  default_sampling: PositiveFloat!
  "The account name."
  name: String!
  router_ips: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_create_rules_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_create_rules_4xx_response") = mnm_rule | magic_network_monitoring_rules_create_rules_4xx_response

type magic_network_monitoring_rules_create_rules_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_update_rules_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_update_rules_4xx_response") = mnm_rule | magic_network_monitoring_rules_update_rules_4xx_response

type magic_network_monitoring_rules_update_rules_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_delete_rule_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_delete_rule_4xx_response") = mnm_rule | magic_network_monitoring_rules_delete_rule_4xx_response

type magic_network_monitoring_rules_delete_rule_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_update_rule_response @statusCodeTypeName(statusCode: 200, typeName: "mnm_rule") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_update_rule_4xx_response") = mnm_rule | magic_network_monitoring_rules_update_rule_4xx_response

type magic_network_monitoring_rules_update_rule_4xx_response {
  "Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit."
  automatic_advertisement: Boolean!
  "The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  bandwidth_threshold: PositiveFloat
  "The amount of time that the rule threshold must be exceeded to send an alert notification. The minimum is 60 seconds and maximum is 21600 seconds. The format is XhYmZs where X, Y, and Z durations are optional; however at least one unit must be provided."
  duration: String!
  id: String!
  "The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters."
  name: String!
  "The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum."
  packet_threshold: PositiveFloat
  prefixes: [String]!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_network_monitoring_rules_update_advertisement_for_rule_response @statusCodeTypeName(statusCode: 200, typeName: "Boolean_container") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_network_monitoring_rules_update_advertisement_for_rule_4xx_response") = Boolean_container | magic_network_monitoring_rules_update_advertisement_for_rule_4xx_response

type Boolean_container {
  Boolean: Boolean
}

type magic_network_monitoring_rules_update_advertisement_for_rule_4xx_response {
  Boolean: Boolean @resolveRoot
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_project_create_project_response @statusCodeTypeName(statusCode: 200, typeName: "new_project_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_project_create_project_4xx_response") = new_project_response | pages_project_create_project_4xx_response

type new_project_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type pages_project_create_project_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input projects_Input {
  build_config: build_config_Input
  canonical_deployment: mutationInput_pages_project_create_project_input_canonical_deployment_Input
  "When the project was created."
  created_on: DateTime
  deployment_configs: deployment_configs_Input
  "A list of associated custom domains for the project."
  domains: [JSON]
  "Id of the project."
  id: String
  latest_deployment: mutationInput_pages_project_create_project_input_latest_deployment_Input
  "Name of the project."
  name: String
  "Production branch of the project. Used to identify production deployments."
  production_branch: String
  source: JSON
  "The Cloudflare subdomain associated with the project."
  subdomain: String
}

"Configs for the project build process."
input build_config_Input {
  "Command used to build project."
  build_command: String
  "Output directory of the build."
  destination_dir: String
  "Directory to run the command."
  root_dir: String
  "The classifying tag for analytics."
  web_analytics_tag: String
  "The auth token for analytics."
  web_analytics_token: String
}

input mutationInput_pages_project_create_project_input_canonical_deployment_Input @oneOf {
  JSON: JSON
  deployments_Input: deployments_Input
}

input deployments_Input {
  "A list of alias URLs pointing to this deployment."
  aliases: [JSON]
  build_config: JSON
  "When the deployment was created."
  created_on: DateTime
  deployment_trigger: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_Input
  env_vars: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_Input
  environment: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_environment
  "Id of the deployment."
  id: String
  "If the deployment has been skipped."
  is_skipped: Boolean
  latest_stage: JSON
  "When the deployment was last modified."
  modified_on: DateTime
  "Id of the project."
  project_id: String
  "Name of the project."
  project_name: String
  "Short Id (8 character) of the deployment."
  short_id: String
  source: JSON
  "List of past stages."
  stages: [stage_Input]
  "The live URL to view this deployment."
  url: URL
}

"Info about what caused the deployment."
input query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_Input {
  metadata: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_metadata_Input
  type: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_type
}

"Additional info about the trigger."
input query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_deployment_trigger_metadata_Input {
  "Where the trigger happened."
  branch: String
  "Hash of the deployment trigger commit."
  commit_hash: String
  "Message of the deployment trigger commit."
  commit_message: String
}

"A dict of env variables to build this deploy."
input query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_Input {
  BUILD_VERSION: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_BUILD_VERSION_Input
  ENV: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_ENV_Input
}

input query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_BUILD_VERSION_Input {
  value: String
}

input query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_env_vars_ENV_Input {
  value: String
}

"The status of the deployment."
input stage_Input {
  "When the stage ended."
  ended_on: DateTime
  name: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_name
  "When the stage started."
  started_on: DateTime
  status: query_pages_deployment_get_deployment_info_oneOf_0_allOf_1_result_stages_items_status
}

"Configs for deployments in a project."
input deployment_configs_Input {
  preview: mutationInput_pages_project_create_project_input_deployment_configs_preview_Input
  production: mutationInput_pages_project_create_project_input_deployment_configs_production_Input
}

"Configs for preview deploys."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_Input {
  "Compatibility date used for Pages Functions."
  compatibility_date: Date
  "Compatibility flags used for Pages Functions."
  compatibility_flags: [JSON]
  d1_databases: mutationInput_pages_project_create_project_input_deployment_configs_preview_d1_databases_Input
  durable_object_namespaces: mutationInput_pages_project_create_project_input_deployment_configs_preview_durable_object_namespaces_Input
  env_vars: mutationInput_pages_project_create_project_input_deployment_configs_preview_env_vars_Input
  kv_namespaces: mutationInput_pages_project_create_project_input_deployment_configs_preview_kv_namespaces_Input
  r2_buckets: mutationInput_pages_project_create_project_input_deployment_configs_preview_r2_buckets_Input
}

"D1 databases used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_d1_databases_Input {
  D1_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_preview_d1_databases_D1_BINDING_Input
}

"D1 binding."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_d1_databases_D1_BINDING_Input {
  "UUID of the D1 database."
  id: String
}

"Durabble Object namespaces used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_durable_object_namespaces_Input {
  DO_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_preview_durable_object_namespaces_DO_BINDING_Input
}

"Durabble Object binding."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_durable_object_namespaces_DO_BINDING_Input {
  "ID of the Durabble Object namespace."
  namespace_id: String
}

"Environment variables for build configs."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_env_vars_Input {
  BUILD_VERSION: mutationInput_pages_project_create_project_input_deployment_configs_preview_env_vars_BUILD_VERSION_Input
}

"Environment variable."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_env_vars_BUILD_VERSION_Input {
  "Environment variable value."
  value: String
}

"KV namespaces used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_kv_namespaces_Input {
  KV_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_preview_kv_namespaces_KV_BINDING_Input
}

"KV binding."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_kv_namespaces_KV_BINDING_Input {
  "ID of the KV namespace."
  namespace_id: String
}

"R2 buckets used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_r2_buckets_Input {
  R2_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_preview_r2_buckets_R2_BINDING_Input
}

"R2 binding."
input mutationInput_pages_project_create_project_input_deployment_configs_preview_r2_buckets_R2_BINDING_Input {
  "Name of the R2 bucket."
  name: String
}

"Configs for production deploys."
input mutationInput_pages_project_create_project_input_deployment_configs_production_Input {
  "Compatibility date used for Pages Functions."
  compatibility_date: Date
  "Compatibility flags used for Pages Functions."
  compatibility_flags: [JSON]
  d1_databases: mutationInput_pages_project_create_project_input_deployment_configs_production_d1_databases_Input
  durable_object_namespaces: mutationInput_pages_project_create_project_input_deployment_configs_production_durable_object_namespaces_Input
  env_vars: mutationInput_pages_project_create_project_input_deployment_configs_production_env_vars_Input
  kv_namespaces: mutationInput_pages_project_create_project_input_deployment_configs_production_kv_namespaces_Input
  r2_buckets: mutationInput_pages_project_create_project_input_deployment_configs_production_r2_buckets_Input
}

"D1 databases used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_production_d1_databases_Input {
  D1_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_production_d1_databases_D1_BINDING_Input
}

"D1 binding."
input mutationInput_pages_project_create_project_input_deployment_configs_production_d1_databases_D1_BINDING_Input {
  "UUID of the D1 database."
  id: String
}

"Durabble Object namespaces used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_production_durable_object_namespaces_Input {
  DO_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_production_durable_object_namespaces_DO_BINDING_Input
}

"Durabble Object binding."
input mutationInput_pages_project_create_project_input_deployment_configs_production_durable_object_namespaces_DO_BINDING_Input {
  "ID of the Durabble Object namespace."
  namespace_id: String
}

"Environment variables for build configs."
input mutationInput_pages_project_create_project_input_deployment_configs_production_env_vars_Input {
  BUILD_VERSION: mutationInput_pages_project_create_project_input_deployment_configs_production_env_vars_BUILD_VERSION_Input
}

"Environment variable."
input mutationInput_pages_project_create_project_input_deployment_configs_production_env_vars_BUILD_VERSION_Input {
  "Environment variable value."
  value: String
}

"KV namespaces used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_production_kv_namespaces_Input {
  KV_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_production_kv_namespaces_KV_BINDING_Input
}

"KV binding."
input mutationInput_pages_project_create_project_input_deployment_configs_production_kv_namespaces_KV_BINDING_Input {
  "ID of the KV namespace."
  namespace_id: String
}

"R2 buckets used for Pages Functions."
input mutationInput_pages_project_create_project_input_deployment_configs_production_r2_buckets_Input {
  R2_BINDING: mutationInput_pages_project_create_project_input_deployment_configs_production_r2_buckets_R2_BINDING_Input
}

"R2 binding."
input mutationInput_pages_project_create_project_input_deployment_configs_production_r2_buckets_R2_BINDING_Input {
  "Name of the R2 bucket."
  name: String
}

input mutationInput_pages_project_create_project_input_latest_deployment_Input @oneOf {
  JSON: JSON
  deployments_Input: deployments_Input
}

union pages_project_delete_project_response @statusCodeTypeName(statusCode: 200, typeName: "pages_project_delete_project_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_project_delete_project_4xx_response") = pages_project_delete_project_200_response | pages_project_delete_project_4xx_response

type pages_project_delete_project_200_response {
  errors: [JSON]
  messages: [JSON]
  result: Void
  success: Boolean
}

type pages_project_delete_project_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_project_update_project_response @statusCodeTypeName(statusCode: 200, typeName: "new_project_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_project_update_project_4xx_response") = new_project_response | pages_project_update_project_4xx_response

type pages_project_update_project_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input project_patch_Input {
  deployment_configs: mutationInput_pages_project_update_project_input_deployment_configs_Input
}

input mutationInput_pages_project_update_project_input_deployment_configs_Input {
  production: mutationInput_pages_project_update_project_input_deployment_configs_production_Input
}

input mutationInput_pages_project_update_project_input_deployment_configs_production_Input {
  compatibility_date: Date
  compatibility_flags: [String]
  env_vars: mutationInput_pages_project_update_project_input_deployment_configs_production_env_vars_Input
}

input mutationInput_pages_project_update_project_input_deployment_configs_production_env_vars_Input {
  BUILD_VERSION: mutationInput_pages_project_update_project_input_deployment_configs_production_env_vars_BUILD_VERSION_Input
  delete_this_env_var: Void
}

input mutationInput_pages_project_update_project_input_deployment_configs_production_env_vars_BUILD_VERSION_Input {
  value: String
}

union pages_deployment_create_deployment_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_new_deployment") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_create_deployment_4xx_response") = deployment_new_deployment | pages_deployment_create_deployment_4xx_response

type deployment_new_deployment {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: deployments
  "Whether the API call was successful"
  success: Boolean!
}

type pages_deployment_create_deployment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_deployment_delete_deployment_response @statusCodeTypeName(statusCode: 200, typeName: "pages_deployment_delete_deployment_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_delete_deployment_4xx_response") = pages_deployment_delete_deployment_200_response | pages_deployment_delete_deployment_4xx_response

type pages_deployment_delete_deployment_200_response {
  errors: [JSON]
  messages: [JSON]
  result: Void
  success: Boolean
}

type pages_deployment_delete_deployment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_deployment_retry_deployment_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_new_deployment") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_retry_deployment_4xx_response") = deployment_new_deployment | pages_deployment_retry_deployment_4xx_response

type pages_deployment_retry_deployment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_deployment_rollback_deployment_response @statusCodeTypeName(statusCode: 200, typeName: "deployment_response_details") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_deployment_rollback_deployment_4xx_response") = deployment_response_details | pages_deployment_rollback_deployment_4xx_response

type pages_deployment_rollback_deployment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_domains_add_domain_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_domains_add_domain_4xx_response") = domain_response_single | pages_domains_add_domain_4xx_response

type pages_domains_add_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input domains_post_Input {
  name: String
}

union pages_domains_delete_domain_response @statusCodeTypeName(statusCode: 200, typeName: "pages_domains_delete_domain_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_domains_delete_domain_4xx_response") = pages_domains_delete_domain_200_response | pages_domains_delete_domain_4xx_response

type pages_domains_delete_domain_200_response {
  errors: [JSON]
  messages: [JSON]
  result: Void
  success: Boolean
}

type pages_domains_delete_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union pages_domains_patch_domain_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "pages_domains_patch_domain_4xx_response") = domain_response_single | pages_domains_patch_domain_4xx_response

type pages_domains_patch_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union magic_pcap_collection_create_pcap_request_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_create_pcap_request_4xx_response") = pcaps_single_response | magic_pcap_collection_create_pcap_request_4xx_response

type magic_pcap_collection_create_pcap_request_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input pcaps_request_pcap_Input {
  filter_v1: pcaps_filter_v1_Input
  "The limit of packets contained in a packet capture."
  packet_limit: PositiveFloat!
  system: pcaps_system!
  "The packet capture duration in seconds."
  time_limit: PositiveFloat!
  type: pcaps_type!
  "The maximum number of bytes to capture. This field only applies to \`full\` packet captures."
  byte_limit: PositiveFloat
  "The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to \`full\` packet captures."
  colo_name: String!
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL!
}

"The packet capture filter. When this field is empty, all packets are captured."
input pcaps_filter_v1_Input {
  "The destination IP address of the packet."
  destination_address: String
  "The destination port of the packet."
  destination_port: Float
  "The protocol number of the packet."
  protocol: Float
  "The source IP address of the packet."
  source_address: String
  "The source port of the packet."
  source_port: Float
}

union magic_pcap_collection_add_buckets_for_full_packet_captures_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_ownership_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_add_buckets_for_full_packet_captures_4xx_response") = pcaps_ownership_single_response | magic_pcap_collection_add_buckets_for_full_packet_captures_4xx_response

type pcaps_ownership_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: pcaps_ownership_response
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type magic_pcap_collection_add_buckets_for_full_packet_captures_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input pcaps_ownership_request_Input {
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL!
}

union magic_pcap_collection_validate_buckets_for_full_packet_captures_response @statusCodeTypeName(statusCode: 200, typeName: "pcaps_ownership_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "magic_pcap_collection_validate_buckets_for_full_packet_captures_4xx_response") = pcaps_ownership_single_response | magic_pcap_collection_validate_buckets_for_full_packet_captures_4xx_response

type magic_pcap_collection_validate_buckets_for_full_packet_captures_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input pcaps_ownership_validate_request_Input {
  "The full URI for the bucket. This field only applies to \`full\` packet captures."
  destination_conf: URL!
  "The ownership challenge filename stored in the bucket."
  ownership_challenge: String!
}

union r_2_bucket_create_bucket_response @statusCodeTypeName(statusCode: 200, typeName: "r2_single_bucket_operation_response") @statusCodeTypeName(statusCode: "4xx", typeName: "r_2_bucket_create_bucket_4xx_response") = r2_single_bucket_operation_response | r_2_bucket_create_bucket_4xx_response

type r2_single_bucket_operation_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type r_2_bucket_create_bucket_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union r_2_bucket_delete_bucket_response @statusCodeTypeName(statusCode: 200, typeName: "r2_single_bucket_operation_response") @statusCodeTypeName(statusCode: "4xx", typeName: "r_2_bucket_delete_bucket_4xx_response") = r2_single_bucket_operation_response | r_2_bucket_delete_bucket_4xx_response

type r_2_bucket_delete_bucket_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

scalar bucket_name @regexp(pattern: "^[a-z0-9][a-z0-9-]*[a-z0-9]") @typescript(type: "string")

union account_railguns_create_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_railguns_create_railgun_4xx_response") = railgun_response_single | account_railguns_create_railgun_4xx_response

type account_railguns_create_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input account_railguns_create_railgun_request_Input {
  "Readable identifier of the Railgun."
  name: railgun_components_schemas_name!
}

union account_railguns_delete_a_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "account_railguns_delete_a_railgun_4xx_response") = railgun_response_single_id | account_railguns_delete_a_railgun_4xx_response

type railgun_response_single_id {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_account_railguns_delete_a_railgun_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_account_railguns_delete_a_railgun_oneOf_0_allOf_1_result {
  "Railgun identifier tag."
  id: railgun_components_schemas_identifier!
}

type account_railguns_delete_a_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_railguns_update_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_railguns_update_railgun_4xx_response") = railgun_response_single | account_railguns_update_railgun_4xx_response

type account_railguns_update_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_railgun_Input {
  activation: activation_Input
  "When the Railgun was created."
  created_on: DateTime
  "Flag to determine if the Railgun is accepting connections."
  enabled: Boolean!
  "Railgun identifier tag."
  id: railgun_components_schemas_identifier
  "When the Railgun was last modified."
  modified_on: DateTime
  "Readable identifier of the Railgun."
  name: railgun_components_schemas_name!
  status: railgun_components_schemas_status
  upgrade_info: upgrade_info_Input
  "The number of zones using this Railgun."
  zones_connected: Float
}

input activation_Input {
  "When the Railgun was activated."
  activated_on: DateTime
  key: activation_key
  version: mutationInput_account_railguns_update_railgun_input_activation_version_Input
}

input mutationInput_account_railguns_update_railgun_input_activation_version_Input {
  "The build identifier for the Railgun receiver."
  build: String
  "The version of the Railgun receiver."
  number: String
  "The revision of the Railgun receiver."
  revision: String
}

"Defined when the Railgun version is out of date from the latest release from Cloudflare."
input upgrade_info_Input {
  "An HTTP link to download the latest Railgun binary."
  download_link: URL
  "Latest version of the Railgun receiver available to install."
  latest_version: String
}

union railgun_connections_create_connection_response @statusCodeTypeName(statusCode: 200, typeName: "connection_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_create_connection_4xx_response") = connection_single_response | railgun_connections_create_connection_4xx_response

type railgun_connections_create_connection_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input connection_single_request_Input {
  "A value indicating whether the connection is enabled or not."
  enabled: Boolean
  zone: mutationInput_railgun_connections_create_connection_input_zone_Input
}

input mutationInput_railgun_connections_create_connection_input_zone_Input {
  "Identifier"
  id: common_components_schemas_identifier
}

union railgun_connections_delete_connection_response @statusCodeTypeName(statusCode: 200, typeName: "connection_single_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_delete_connection_4xx_response") = connection_single_id_response | railgun_connections_delete_connection_4xx_response

type connection_single_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_railgun_connections_delete_connection_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_railgun_connections_delete_connection_oneOf_0_allOf_1_result {
  "Connection identifier tag."
  id: connection_components_schemas_identifier!
}

type railgun_connections_delete_connection_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union railgun_connections_update_connection_response @statusCodeTypeName(statusCode: 200, typeName: "connection_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_update_connection_4xx_response") = connection_single_response | railgun_connections_update_connection_4xx_response

type railgun_connections_update_connection_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_connection_Input {
  "When the connection was created."
  created_on: DateTime
  "A value indicating whether the connection is enabled or not."
  enabled: Boolean!
  "Connection identifier tag."
  id: connection_components_schemas_identifier
  "When the connection was last modified."
  modified_on: DateTime
  zone: connection_components_schemas_zone_Input
}

input connection_components_schemas_zone_Input {
  "Identifier"
  id: common_components_schemas_identifier
  name: properties_name
}

union registrar_domains_list_domains_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_collection2") @statusCodeTypeName(statusCode: "4xx", typeName: "registrar_domains_list_domains_4xx_response") = domain_response_collection2 | registrar_domains_list_domains_4xx_response

type domain_response_collection2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [domains]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type domains {
  "Shows if a domain is available for transferring into Cloudflare Registrar."
  available: Boolean
  "Indicates if the domain can be registered as a new domain."
  can_register: Boolean
  "Shows time of creation."
  created_at: DateTime
  "Shows name of current registrar."
  current_registrar: String
  "Shows when domain name registration expires."
  expires_at: DateTime
  "Domain identifier."
  id: schemas_domain_identifier
  "Shows whether a registrar lock is in place for a domain."
  locked: Boolean
  "Shows contact information for domain registrant."
  registrant_contact: registrant_contact
  "A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en)."
  registry_statuses: String
  "Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs."
  supported_tld: Boolean
  transfer_in: transfer_in
  "Last updated."
  updated_at: DateTime
}

"Domain identifier."
scalar schemas_domain_identifier @length(min: null, max: 32)

"Shows contact information for domain registrant."
type registrant_contact {
  "Address."
  address: String!
  "Optional address line for unit, floor, suite, etc."
  address2: String
  "City."
  city: String!
  "The country in which the user lives."
  country: country
  "The contact email address of the user."
  email: EmailAddress
  "Contact fax number."
  fax: String
  "User's first name"
  first_name: first_name
  "Contact Identifier."
  id: contact_identifier
  "User's last name"
  last_name: last_name
  "Name of organization."
  organization: String!
  "User's telephone number"
  phone: telephone
  "State."
  state: String!
  "The zipcode or postal code where the user lives."
  zip: zipcode
}

"The country in which the user lives."
scalar country @length(min: null, max: 30)

"Contact Identifier."
scalar contact_identifier @length(min: null, max: 32)

"User's telephone number"
scalar telephone @length(min: null, max: 20)

"The zipcode or postal code where the user lives."
scalar zipcode @length(min: null, max: 20)

"Statuses for domain transfers into Cloudflare Registrar."
type transfer_in {
  "Form of authorization has been accepted by the registrant."
  accept_foa: String
  "Shows transfer status with the registry."
  approve_transfer: String
  "Indicates if cancellation is still possible."
  can_cancel_transfer: Boolean
  "Privacy guards are disabled at the foreign registrar."
  disable_privacy: JSON
  "Auth code has been entered and verified."
  enter_auth_code: String
  "Domain is unlocked at the foreign registrar."
  unlock_domain: JSON
}

type registrar_domains_list_domains_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input registrar_domains_list_domains_request_Input {
  "List of domain names."
  id: [String]!
}

union registrar_domains_update_domain_response @statusCodeTypeName(statusCode: 200, typeName: "domain_response_single2") @statusCodeTypeName(statusCode: "4xx", typeName: "registrar_domains_update_domain_4xx_response") = domain_response_single2 | registrar_domains_update_domain_4xx_response

type registrar_domains_update_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input registrar_domains_update_domain_request_Input {
  "Auto-renew controls whether subscription is automatically renewed upon domain expiration."
  auto_renew: Boolean
  "Shows whether a registrar lock is in place for a domain."
  locked: Boolean
  "List of name servers."
  name_servers: [String]
  "Privacy option controls redacting WHOIS information."
  privacy: Boolean
}

union lists_create_a_list_response @statusCodeTypeName(statusCode: 200, typeName: "list_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_create_a_list_4xx_response") = list_response_collection | lists_create_a_list_4xx_response

type lists_create_a_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input lists_create_a_list_request_Input {
  "An informative summary of the list."
  description: lists_components_schemas_description
  kind: kind!
  name: lists_components_schemas_name!
}

union lists_delete_a_list_response @statusCodeTypeName(statusCode: 200, typeName: "list_delete_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_delete_a_list_4xx_response") = list_delete_response_collection | lists_delete_a_list_4xx_response

type list_delete_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_lists_delete_a_list_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type mutation_lists_delete_a_list_oneOf_0_allOf_1_result {
  "The unique ID of the item in the List."
  id: String!
}

type lists_delete_a_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union lists_update_a_list_response @statusCodeTypeName(statusCode: 200, typeName: "list_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_update_a_list_4xx_response") = list_response_collection | lists_update_a_list_4xx_response

type lists_update_a_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input lists_update_a_list_request_Input {
  "An informative summary of the list."
  description: lists_components_schemas_description
}

union lists_delete_list_items_response @statusCodeTypeName(statusCode: 200, typeName: "lists_async_response") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_delete_list_items_4xx_response") = lists_async_response | lists_delete_list_items_4xx_response

type lists_async_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_lists_delete_list_items_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type mutation_lists_delete_list_items_oneOf_0_allOf_1_result {
  "The unique operation ID of the asynchronous action."
  operation_id: String!
}

type lists_delete_list_items_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input lists_delete_list_items_request_Input {
  items: [mutationInput_lists_delete_list_items_input_items_items_Input]
}

input mutationInput_lists_delete_list_items_input_items_items_Input {
  "The unique ID of the item in the List."
  id: String!
}

union lists_create_list_items_response @statusCodeTypeName(statusCode: 200, typeName: "lists_async_response") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_create_list_items_4xx_response") = lists_async_response | lists_create_list_items_4xx_response

type lists_create_list_items_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input mutationInput_lists_create_list_items_input_items_Input {
  "An informative summary of the list item."
  comment: String
  "An IPv4 address, an IPv4 CIDR, or an IPv6 CIDR. IPv6 CIDRs are limited to a maximum of /64."
  ip: String
  redirect: item_redirect_Input
}

"The definition of the redirect."
input item_redirect_Input {
  include_subdomains: Boolean
  preserve_path_suffix: Boolean = true
  preserve_query_string: Boolean
  source_url: String!
  status_code: query_lists_get_list_items_oneOf_0_allOf_1_result_items_redirect_status_code = _301
  subpath_matching: Boolean
  target_url: URL!
}

union lists_update_all_list_items_response @statusCodeTypeName(statusCode: 200, typeName: "lists_async_response") @statusCodeTypeName(statusCode: "4xx", typeName: "lists_update_all_list_items_4xx_response") = lists_async_response | lists_update_all_list_items_4xx_response

type lists_update_all_list_items_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union secondary_dns__acl_create_acl_response @statusCodeTypeName(statusCode: 200, typeName: "acl_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__acl_create_acl_4xx_response") = acl_components_schemas_single_response | secondary_dns__acl_create_acl_4xx_response

type secondary_dns__acl_create_acl_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input secondary_dns__acl_create_acl_request_Input {
  name: JSON!
  ip_range: JSON!
}

union secondary_dns__acl_delete_acl_response @statusCodeTypeName(statusCode: 200, typeName: "acl_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__acl_delete_acl_4xx_response") = acl_components_schemas_id_response | secondary_dns__acl_delete_acl_4xx_response

type acl_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_secondary_dns__acl_delete_acl_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_secondary_dns__acl_delete_acl_oneOf_0_allOf_1_result {
  id: String!
}

type secondary_dns__acl_delete_acl_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__acl_update_acl_response @statusCodeTypeName(statusCode: 200, typeName: "acl_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__acl_update_acl_4xx_response") = acl_components_schemas_single_response | secondary_dns__acl_update_acl_4xx_response

type secondary_dns__acl_update_acl_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input acl_Input {
  id: String!
  "Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively."
  ip_range: String!
  "The name of the acl."
  name: String!
}

union secondary_dns__peer_create_peer_response @statusCodeTypeName(statusCode: 200, typeName: "peer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__peer_create_peer_4xx_response") = peer_components_schemas_single_response | secondary_dns__peer_create_peer_4xx_response

type secondary_dns__peer_create_peer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input secondary_dns__peer_create_peer_request_Input {
  name: JSON!
}

union secondary_dns__peer_delete_peer_response @statusCodeTypeName(statusCode: 200, typeName: "peer_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__peer_delete_peer_4xx_response") = peer_components_schemas_id_response | secondary_dns__peer_delete_peer_4xx_response

type peer_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_secondary_dns__peer_delete_peer_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_secondary_dns__peer_delete_peer_oneOf_0_allOf_1_result {
  id: String!
}

type secondary_dns__peer_delete_peer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__peer_update_peer_response @statusCodeTypeName(statusCode: 200, typeName: "peer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__peer_update_peer_4xx_response") = peer_components_schemas_single_response | secondary_dns__peer_update_peer_4xx_response

type secondary_dns__peer_update_peer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input peer_Input {
  id: String!
  "IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to."
  ip: String
  "Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones."
  ixfr_enable: Boolean
  "The name of the peer."
  name: String!
  "DNS port of primary or secondary nameserver, depending on what zone this peer is linked to."
  port: Float
  "TSIG authentication will be used for zone transfer if configured."
  tsig_id: String
}

union secondary_dns__tsig_create_tsig_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__tsig_create_tsig_4xx_response") = components_schemas_single_response | secondary_dns__tsig_create_tsig_4xx_response

type secondary_dns__tsig_create_tsig_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input secondary_dns__tsig_create_tsig_request_Input {
  name: JSON!
  algo: JSON!
}

union secondary_dns__tsig_delete_tsig_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__tsig_delete_tsig_4xx_response") = components_schemas_id_response | secondary_dns__tsig_delete_tsig_4xx_response

type components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_secondary_dns__tsig_delete_tsig_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_secondary_dns__tsig_delete_tsig_oneOf_0_allOf_1_result {
  id: String!
}

type secondary_dns__tsig_delete_tsig_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__tsig_update_tsig_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__tsig_update_tsig_4xx_response") = components_schemas_single_response | secondary_dns__tsig_update_tsig_4xx_response

type secondary_dns__tsig_update_tsig_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tsig_Input {
  "TSIG algorithm."
  algo: String!
  id: String!
  "TSIG key name."
  name: String!
  "TSIG secret."
  secret: String!
}

union workers_kv_namespace_create_a_namespace_response @statusCodeTypeName(statusCode: 200, typeName: "workers_kv_namespace_create_a_namespace_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_create_a_namespace_4xx_response") = workers_kv_namespace_create_a_namespace_200_response | workers_kv_namespace_create_a_namespace_4xx_response

type workers_kv_namespace_create_a_namespace_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: namespace
  "Whether the API call was successful"
  success: Boolean!
}

type workers_kv_namespace_create_a_namespace_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_rename_namespace_body_Input {
  "A human-readable string name for a Namespace."
  title: String!
}

union workers_kv_namespace_remove_a_namespace_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_remove_a_namespace_4xx_response") = api_response_single | workers_kv_namespace_remove_a_namespace_4xx_response

type workers_kv_namespace_remove_a_namespace_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_namespace_rename_a_namespace_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_rename_a_namespace_4xx_response") = api_response_single | workers_kv_namespace_rename_a_namespace_4xx_response

type workers_kv_namespace_rename_a_namespace_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_namespace_delete_multiple_key_value_pairs_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_delete_multiple_key_value_pairs_4xx_response") = api_response_single | workers_kv_namespace_delete_multiple_key_value_pairs_4xx_response

type workers_kv_namespace_delete_multiple_key_value_pairs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid."
scalar key_name_bulk @length(min: null, max: 512)

union workers_kv_namespace_write_multiple_key_value_pairs_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_write_multiple_key_value_pairs_4xx_response") = api_response_single | workers_kv_namespace_write_multiple_key_value_pairs_4xx_response

type workers_kv_namespace_write_multiple_key_value_pairs_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input mutationInput_workers_kv_namespace_write_multiple_key_value_pairs_input_items_Input {
  "Whether or not the server should base64 decode the value before storing it. Useful for writing values that wouldn't otherwise be valid JSON strings, such as images."
  base64: Boolean
  "The time, measured in number of seconds since the UNIX epoch, at which the key should expire."
  expiration: Float
  "The number of seconds for which the key should be visible before it expires. At least 60."
  expiration_ttl: Float
  "A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid."
  key: key_name_bulk
  metadata: list_metadata_Input
  "A UTF-8 encoded string to be stored, up to 10 MB in length."
  value: mutationInput_workers_kv_namespace_write_multiple_key_value_pairs_input_items_value
}

"Arbitrary JSON that is associated with a key."
input list_metadata_Input {
  someMetadataKey: String
}

"A UTF-8 encoded string to be stored, up to 10 MB in length."
scalar mutationInput_workers_kv_namespace_write_multiple_key_value_pairs_input_items_value @length(min: null, max: 10485760)

union workers_kv_namespace_delete_key_value_pair_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_delete_key_value_pair_4xx_response") = api_response_single | workers_kv_namespace_delete_key_value_pair_4xx_response

type workers_kv_namespace_delete_key_value_pair_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union workers_kv_namespace_write_key_value_pair_with_metadata_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "workers_kv_namespace_write_key_value_pair_with_metadata_4xx_response") = api_response_single | workers_kv_namespace_write_key_value_pair_with_metadata_4xx_response

type workers_kv_namespace_write_key_value_pair_with_metadata_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input workers_kv_namespace_write_key_value_pair_with_metadata_request_Input {
  "Arbitrary JSON to be associated with a key/value pair."
  metadata: String!
  "A byte sequence to be stored, up to 10 MB in length."
  value: String!
}

enum tus_resumable @typescript(type: "\\"1.0.0\\"") @example(value: "\\"1.0.0\\"") {
  _1_0_0 @enum(value: "\\"1.0.0\\"")
}

union stream_video_clipping_clip_videos_given_a_start_and_end_time_response @statusCodeTypeName(statusCode: 200, typeName: "clipResponseSingle") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_video_clipping_clip_videos_given_a_start_and_end_time_4xx_response") = clipResponseSingle | stream_video_clipping_clip_videos_given_a_start_and_end_time_4xx_response

type clipResponseSingle {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: schemas_output
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type schemas_output {
  "Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin."
  allowedOrigins: [String]
  "The unique video identifier (UID)."
  clippedFromVideoUID: clipped_from_video_uid
  "The date and time the live input was created."
  created: DateTime
  "A user-defined identifier for the media creator."
  creator: creator!
  "Specifies the end time for the video clip in seconds."
  endTimeSeconds: Int
  "Calculates the amount of time a video occupies before the video is uploaded. Direct uploads occupy minutes of videos on your Stream account until they are expired. After upload, the upload duration is used instead. If a video longer than the value is uploaded, the video results in an error."
  maxDurationSeconds: PositiveInt
  meta: schemas_media_metadata
  "The date and time the live input was last modified."
  modified: DateTime
  playback: playback
  "The video's preview page URI. This field is omitted until encoding is complete."
  preview: URL
  "Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video."
  requireSignedURLs: Boolean
  "Specifies the start time for the video clip in seconds."
  startTimeSeconds: Int
  status: media_state
  "The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video."
  thumbnailTimestampPct: NonNegativeFloat
  watermark: watermarkAtUpload
}

"The unique video identifier (UID)."
scalar clipped_from_video_uid @length(min: null, max: 32)

"A user modifiable key-value store used to reference other systems of record for managing videos."
type schemas_media_metadata {
  name: String
}

type watermarkAtUpload {
  "The unique identifier for the watermark profile."
  uid: mutation_stream_video_clipping_clip_videos_given_a_start_and_end_time_oneOf_0_allOf_1_result_watermark_uid
}

"The unique identifier for the watermark profile."
scalar mutation_stream_video_clipping_clip_videos_given_a_start_and_end_time_oneOf_0_allOf_1_result_watermark_uid @length(min: null, max: 32)

type stream_video_clipping_clip_videos_given_a_start_and_end_time_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input videoClipStandard_Input {
  "Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin."
  allowedOrigins: [String]
  "The unique video identifier (UID)."
  clippedFromVideoUID: clipped_from_video_uid
  "A user-defined identifier for the media creator."
  creator: creator!
  "Specifies the end time for the video clip in seconds."
  endTimeSeconds: Int
  "Calculates the amount of time a video occupies before the video is uploaded. Direct uploads occupy minutes of videos on your Stream account until they are expired. After upload, the upload duration is used instead. If a video longer than the value is uploaded, the video results in an error."
  maxDurationSeconds: PositiveInt
  "Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video."
  requireSignedURLs: Boolean
  "Specifies the start time for the video clip in seconds."
  startTimeSeconds: Int
  "The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video."
  thumbnailTimestampPct: NonNegativeFloat
  watermark: watermarkAtUpload_Input
}

input watermarkAtUpload_Input {
  "The unique identifier for the watermark profile."
  uid: mutation_stream_video_clipping_clip_videos_given_a_start_and_end_time_oneOf_0_allOf_1_result_watermark_uid
}

union stream_videos_upload_videos_from_a_url_response @statusCodeTypeName(statusCode: 200, typeName: "video_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_upload_videos_from_a_url_4xx_response") = video_response_single | stream_videos_upload_videos_from_a_url_4xx_response

type stream_videos_upload_videos_from_a_url_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input video_copy_request_Input {
  "Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin."
  allowedOrigins: [String]
  "A user-defined identifier for the media creator."
  creator: creator!
  "Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video."
  requireSignedURLs: Boolean
  "The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video."
  thumbnailTimestampPct: NonNegativeFloat
  "A video's URL. The server must be publicly routable and support \`HTTP HEAD\` requests and \`HTTP GET\` range requests. The server should respond to \`HTTP HEAD\` requests with a \`content-range\` header that includes the size of the file."
  url: URL!
  watermark: watermark_at_upload_Input
}

input watermark_at_upload_Input {
  "The unique identifier for the watermark profile."
  uid: mutationInput_stream_videos_upload_videos_from_a_url_input_watermark_uid
}

"The unique identifier for the watermark profile."
scalar mutationInput_stream_videos_upload_videos_from_a_url_input_watermark_uid @length(min: null, max: 32)

union stream_videos_upload_videos_via_direct_upload_ur_ls_response @statusCodeTypeName(statusCode: 200, typeName: "direct_upload_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_upload_videos_via_direct_upload_ur_ls_4xx_response") = direct_upload_response | stream_videos_upload_videos_via_direct_upload_ur_ls_4xx_response

type direct_upload_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_stream_videos_upload_videos_via_direct_upload_ur_ls_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_stream_videos_upload_videos_via_direct_upload_ur_ls_oneOf_0_allOf_1_result {
  "A Cloudflare-generated unique identifier for a media item."
  uid: videos_components_schemas_identifier!
  "The URL an unauthenticated upload can use for a single \`HTTP POST multipart/form-data\` request."
  uploadURL: String
  watermark: watermarks
}

type stream_videos_upload_videos_via_direct_upload_ur_ls_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input direct_upload_request_Input {
  "Lists the origins allowed to display the video. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin."
  allowedOrigins: [String]
  "A user-defined identifier for the media creator."
  creator: creator!
  "The date and time after upload when videos will not be accepted."
  expiry: DateTime
  "Calculates the amount of time a video occupies before the video is uploaded. Direct uploads occupy minutes of videos on your Stream account until they are expired. After upload, the upload duration is used instead. If a video longer than the value is uploaded, the video results in an error."
  maxDurationSeconds: PositiveInt!
  "Indicates whether the video can be a accessed using the UID. When set to \`true\`, a signed token must be generated with a signing key to view the video."
  requireSignedURLs: Boolean
  "The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video."
  thumbnailTimestampPct: NonNegativeFloat
  watermark: watermark_at_upload_Input
}

union stream_signing_keys_create_signing_keys_response @statusCodeTypeName(statusCode: 200, typeName: "key_generation_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_signing_keys_create_signing_keys_4xx_response") = key_generation_response | stream_signing_keys_create_signing_keys_4xx_response

type key_generation_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: keys
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type keys {
  "The date and time a signing key was created."
  created: DateTime
  id: String!
  "The signing key in JWK format."
  jwk: String
  "The signing key in PEM format."
  pem: String
}

type stream_signing_keys_create_signing_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_signing_keys_delete_signing_keys_response @statusCodeTypeName(statusCode: 200, typeName: "deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_signing_keys_delete_signing_keys_4xx_response") = deleted_response | stream_signing_keys_delete_signing_keys_4xx_response

type deleted_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type stream_signing_keys_delete_signing_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_live_inputs_create_a_live_input_response @statusCodeTypeName(statusCode: 200, typeName: "live_input_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_create_a_live_input_4xx_response") = live_input_response_single | stream_live_inputs_create_a_live_input_4xx_response

type stream_live_inputs_create_a_live_input_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_input_request_Input {
  "Sets the creator ID asssociated with this live input."
  defaultCreator: String
  meta: live_input_metadata_Input
  recording: live_input_recording_settings_Input
}

"A user modifiable key-value store used to reference other systems of record for managing live inputs."
input live_input_metadata_Input {
  name: String
}

"Records the input to a Cloudflare Stream video. Behavior depends on the mode. In most cases, the video will initially be viewable as a live video and transition to on-demand after a condition is satisfied."
input live_input_recording_settings_Input {
  "Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use \`*\` for wildcard subdomains. An empty array allows videos to be viewed on any origin."
  allowedOrigins: [String]
  mode: live_input_recording_mode = off
  "Indicates if a video using the live input has the \`requireSignedURLs\` property set. Also enforces access controls on any video recording of the livestream with the live input."
  requireSignedURLs: Boolean
  "Determines the amount of time a live input configured in \`automatic\` mode should wait before a recording transitions from live to on-demand. \`0\` is recommended for most use cases and indicates the platform default should be used."
  timeoutSeconds: Int
}

"Specifies the recording behavior for the live input. Set this value to \`off\` to prevent a recording. Set the value to \`automatic\` to begin a recording and transition to on-demand after Stream Live stops receiving input."
enum live_input_recording_mode {
  off
  automatic
}

union stream_live_inputs_update_a_live_input_response @statusCodeTypeName(statusCode: 200, typeName: "live_input_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_update_a_live_input_4xx_response") = live_input_response_single | stream_live_inputs_update_a_live_input_4xx_response

type stream_live_inputs_update_a_live_input_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input update_input_request_Input {
  "Sets the creator ID asssociated with this live input."
  defaultCreator: String
  meta: live_input_metadata_Input
  recording: live_input_recording_settings_Input
}

union stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input_response @statusCodeTypeName(statusCode: 200, typeName: "output_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input_4xx_response") = output_response_single | stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input_4xx_response

type output_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: output
  "Whether the API call was successful"
  success: Boolean!
}

type stream_live_inputs_create_a_new_output_COMMA__connected_to_a_live_input_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_output_request_Input {
  "When enabled, live video streamed to the associated live input will be sent to the output URL. When disabled, live video will not be sent to the output URL, even when streaming to the associated live input. Use this to control precisely when you start and stop simulcasting to specific destinations like YouTube and Twitch."
  enabled: Boolean = true
  "The streamKey used to authenticate against an output's target."
  streamKey: String
  "The URL an output uses to restream."
  url: URL
}

union stream_live_inputs_update_an_output_response @statusCodeTypeName(statusCode: 200, typeName: "output_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_live_inputs_update_an_output_4xx_response") = output_response_single | stream_live_inputs_update_an_output_4xx_response

type stream_live_inputs_update_an_output_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input update_output_request_Input {
  "When enabled, live video streamed to the associated live input will be sent to the output URL. When disabled, live video will not be sent to the output URL, even when streaming to the associated live input. Use this to control precisely when you start and stop simulcasting to specific destinations like YouTube and Twitch."
  enabled: Boolean! = true
}

union stream_watermark_profile_create_watermark_profiles_via_basic_upload_response @statusCodeTypeName(statusCode: 200, typeName: "watermark_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_watermark_profile_create_watermark_profiles_via_basic_upload_4xx_response") = watermark_response_single | stream_watermark_profile_create_watermark_profiles_via_basic_upload_4xx_response

type stream_watermark_profile_create_watermark_profiles_via_basic_upload_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input watermark_basic_upload_Input {
  "The image file to upload."
  file: String!
  "A short description of the watermark profile."
  name: String
  "The translucency of the image. A value of \`0.0\` makes the image completely transparent, and \`1.0\` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to \`1.0\` will not make the image completely opaque."
  opacity: NonNegativeFloat = 1
  "The whitespace between the adjacent edges (determined by position) of the video and the image. \`0.0\` indicates no padding, and \`1.0\` indicates a fully padded video width or length, as determined by the algorithm."
  padding: NonNegativeFloat = 0.05
  "The location of the image. Valid positions are: \`upperRight\`, \`upperLeft\`, \`lowerLeft\`, \`lowerRight\`, and \`center\`. Note that \`center\` ignores the \`padding\` parameter."
  position: String = "upperRight"
  "The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. \`0.0\` indicates no scaling (use the size of the image as-is), and \`1.0 \`fills the entire video."
  scale: NonNegativeFloat = 0.15
}

union stream_watermark_profile_delete_watermark_profiles_response @statusCodeTypeName(statusCode: 200, typeName: "stream_watermark_profile_delete_watermark_profiles_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_watermark_profile_delete_watermark_profiles_4xx_response") = stream_watermark_profile_delete_watermark_profiles_200_response | stream_watermark_profile_delete_watermark_profiles_4xx_response

type stream_watermark_profile_delete_watermark_profiles_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type stream_watermark_profile_delete_watermark_profiles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_webhook_delete_webhooks_response @statusCodeTypeName(statusCode: 200, typeName: "deleted_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_webhook_delete_webhooks_4xx_response") = deleted_response | stream_webhook_delete_webhooks_4xx_response

type stream_webhook_delete_webhooks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union stream_webhook_create_webhooks_response @statusCodeTypeName(statusCode: 200, typeName: "webhook_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_webhook_create_webhooks_4xx_response") = webhook_response_single | stream_webhook_create_webhooks_4xx_response

type stream_webhook_create_webhooks_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input webhook_request_Input {
  "The URL where webhooks will be sent."
  notificationUrl: URL!
}

union stream_videos_associate_videos_to_nf_ts_response @statusCodeTypeName(statusCode: 200, typeName: "video_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_associate_videos_to_nf_ts_4xx_response") = video_response_collection | stream_videos_associate_videos_to_nf_ts_4xx_response

type stream_videos_associate_videos_to_nf_ts_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
  "The total number of remaining videos based on cursor position."
  range: Int
  "The total number of videos that match the provided filters."
  total: Int
}

input nft_Input {
  "The ERC-721 compatible contract address."
  contract: query_stream_videos_list_videos_oneOf_0_allOf_1_result_items_nft_contract
  "The token ID for the NFT."
  token: Int
}

union stream_videos_create_signed_url_tokens_for_videso_response @statusCodeTypeName(statusCode: 200, typeName: "signed_token_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_videos_create_signed_url_tokens_for_videso_4xx_response") = signed_token_response | stream_videos_create_signed_url_tokens_for_videso_4xx_response

type signed_token_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_stream_videos_create_signed_url_tokens_for_videso_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_stream_videos_create_signed_url_tokens_for_videso_oneOf_0_allOf_1_result {
  "The signed token used with the signed URLs feature."
  token: String
}

type stream_videos_create_signed_url_tokens_for_videso_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input signed_token_request_Input {
  "The optional list of access rule constraints on the token. Access can be blocked or allowed based on an IP, IP range, or by country. Access rules are evaluated from first to last. If a rule matches, the associated action is applied and no further rules are evaluated."
  accessRules: [accessRules_Input]
  "The optional boolean value that enables using signed tokens to access MP4 download links for a video."
  downloadable: Boolean
  "The optional unix epoch timestamp that specficies the time after a token is not accepted. The maximum time specification is 24 hours from issuing time. If this field is not set, the default is one hour after issuing."
  exp: Int
  "The optional ID of a Stream signing key. If present, the \`pem\` field is also required."
  id: String
  "The optional unix epoch timestamp that specifies the time before a the token is not accepted. If this field is not set, the default is one hour before issuing."
  nbf: Int
  "The optional base64 encoded private key in PEM format associated with a Stream signing key. If present, the \`id\` field is also required."
  pem: String
}

"Defines rules for fine-grained control over content than signed URL tokens alone. Access rules primarily make tokens conditionally valid based on user information. Access Rules are specified on token payloads as the \`accessRules\` property containing an array of Rule objects."
input accessRules_Input {
  action: mutationInput_stream_videos_create_signed_url_tokens_for_videso_input_accessRules_items_action
  "An array of 2-letter country codes in ISO 3166-1 Alpha-2 format used to match requests."
  country: [String]
  "An array of IPv4 or IPV6 addresses or CIDRs used to match requests."
  ip: [String]
  type: mutationInput_stream_videos_create_signed_url_tokens_for_videso_input_accessRules_items_type
}

"The action to take when a request matches a rule. If the action is \`block\`, the signed token blocks views for viewers matching the rule."
enum mutationInput_stream_videos_create_signed_url_tokens_for_videso_input_accessRules_items_action {
  allow
  block
}

"Lists available rule types to match for requests. An \`any\` type matches all requests and can be used as a wildcard to apply default actions after other rules."
enum mutationInput_stream_videos_create_signed_url_tokens_for_videso_input_accessRules_items_type {
  any
  ip_src @enum(value: "\\"ip.src\\"")
  ip_geoip_country @enum(value: "\\"ip.geoip.country\\"")
}

union stream_subtitles__captions_delete_captions_or_subtitles_response @statusCodeTypeName(statusCode: 200, typeName: "stream_subtitles__captions_delete_captions_or_subtitles_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_subtitles__captions_delete_captions_or_subtitles_4xx_response") = stream_subtitles__captions_delete_captions_or_subtitles_200_response | stream_subtitles__captions_delete_captions_or_subtitles_4xx_response

type stream_subtitles__captions_delete_captions_or_subtitles_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: String
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type stream_subtitles__captions_delete_captions_or_subtitles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union stream_subtitles__captions_upload_captions_or_subtitles_response @statusCodeTypeName(statusCode: 200, typeName: "language_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_subtitles__captions_upload_captions_or_subtitles_4xx_response") = language_response_single | stream_subtitles__captions_upload_captions_or_subtitles_4xx_response

type language_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type stream_subtitles__captions_upload_captions_or_subtitles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input caption_basic_upload_Input {
  "The WebVTT file containing the caption or subtitle content."
  file: String!
}

union stream_m_p_4_downloads_create_downloads_response @statusCodeTypeName(statusCode: 200, typeName: "downloads_response") @statusCodeTypeName(statusCode: "4xx", typeName: "stream_m_p_4_downloads_create_downloads_4xx_response") = downloads_response | stream_m_p_4_downloads_create_downloads_4xx_response

type stream_m_p_4_downloads_create_downloads_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_subscriptions_create_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "account_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_subscriptions_create_subscription_4xx_response") = account_subscription_response_single | account_subscriptions_create_subscription_4xx_response

type account_subscription_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type account_subscriptions_create_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input subscription_v2_Input {
  app: query_account_subscriptions_list_subscriptions_oneOf_0_allOf_1_result_items_allOf_0_app_Input
  "The list of add-ons subscribed to."
  component_values: [component_value_Input]
  "The monetary unit in which pricing information is displayed."
  currency: String
  "The end of the current period and also when the next billing is due."
  current_period_end: DateTime
  "When the current billing period started. May match initial_period_start if this is the first period."
  current_period_start: DateTime
  frequency: frequency
  "Subscription identifier tag."
  id: subscription_v2_components_schemas_identifier
  "The price of the subscription that will be billed, in US dollars."
  price: Float
  rate_plan: rate_plan_Input
  state: state
  zone: zone_Input
}

input query_account_subscriptions_list_subscriptions_oneOf_0_allOf_1_result_items_allOf_0_app_Input {
  "app install id."
  install_id: String
}

"A component value for a subscription."
input component_value_Input {
  "The default amount assigned."
  default: Float
  "The name of the component value."
  name: String
  "The unit price for the component value."
  price: Float
  "The amount of the component value assigned."
  value: Float
}

"The rate plan applied to the subscription."
input rate_plan_Input {
  "The currency applied to the rate plan subscription."
  currency: String
  "Whether this rate plan is managed externally from Cloudflare."
  externally_managed: Boolean
  "The ID of the rate plan."
  id: String
  "Whether a rate plan is enterprise-based (or newly adopted term contract)."
  is_contract: Boolean
  "The full name of the rate plan."
  public_name: String
  "The scope that this rate plan applies to."
  scope: String
  "The list of sets this rate plan applies to."
  sets: [String]
}

"A simple zone object. May have null properties if not a zone subscription."
input zone_Input {
  "Identifier"
  id: common_components_schemas_identifier
  name: properties_name
}

union account_subscriptions_delete_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "account_subscriptions_delete_subscription_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_subscriptions_delete_subscription_4xx_response") = account_subscriptions_delete_subscription_200_response | account_subscriptions_delete_subscription_4xx_response

type account_subscriptions_delete_subscription_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_account_subscriptions_delete_subscription_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_account_subscriptions_delete_subscription_oneOf_0_allOf_1_result {
  "Subscription identifier tag."
  subscription_id: subscription_v2_components_schemas_identifier!
}

type account_subscriptions_delete_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_subscriptions_update_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "account_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_subscriptions_update_subscription_4xx_response") = account_subscription_response_single | account_subscriptions_update_subscription_4xx_response

type account_subscriptions_update_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union tunnel_route_delete_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_route_delete_route_4xx_response") = route_response_single | tunnel_route_delete_route_4xx_response

type tunnel_route_delete_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_route_delete_route_request_Input {
  "UUID of the virtual network."
  virtual_network_id: vnet_id
}

union tunnel_route_update_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_route_update_route_4xx_response") = route_response_single | tunnel_route_update_route_4xx_response

type tunnel_route_update_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_route_update_route_request_Input {
  "Optional remark describing the route. Empty if none."
  comment: String
  "New CIDR of this route."
  network: JSON
  "UUID of the tunnel this route should belong to."
  tunnel_id: JSON
  "UUID of the virtual network to which this route belongs to."
  virtual_network_id: JSON
}

union tunnel_route_create_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_route_create_route_4xx_response") = route_response_single | tunnel_route_create_route_4xx_response

type tunnel_route_create_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_route_create_route_request_Input {
  "Optional remark describing the route. Empty if none."
  comment: String
  "UUID of the tunnel for which this route is being added."
  tunnel_id: JSON!
  "optional UUID of the virtual network for which this route is being added; uses the default virtual network of the account if none is provided."
  virtual_network_id: JSON
}

union tunnel_virtual_network_create_virtual_network_response @statusCodeTypeName(statusCode: 200, typeName: "vnet_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_virtual_network_create_virtual_network_4xx_response") = vnet_response_single | tunnel_virtual_network_create_virtual_network_4xx_response

type vnet_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type tunnel_virtual_network_create_virtual_network_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_virtual_network_create_virtual_network_request_Input {
  "Optional remark describing the virtual network. Empty if none."
  comment: String
  "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case."
  is_default: Boolean
  "A user-friendly name chosen when the virtual network is created. Cannot be empty."
  name: String!
}

union tunnel_virtual_network_delete_virtual_network_response @statusCodeTypeName(statusCode: 200, typeName: "vnet_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_virtual_network_delete_virtual_network_4xx_response") = vnet_response_single | tunnel_virtual_network_delete_virtual_network_4xx_response

type tunnel_virtual_network_delete_virtual_network_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union tunnel_virtual_network_update_virtual_network_response @statusCodeTypeName(statusCode: 200, typeName: "vnet_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "tunnel_virtual_network_update_virtual_network_4xx_response") = vnet_response_single | tunnel_virtual_network_update_virtual_network_4xx_response

type tunnel_virtual_network_update_virtual_network_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input tunnel_virtual_network_update_virtual_network_request_Input {
  "Optional remark describing the virtual network. Empty if none."
  comment: String
  "Whether this virtual network is the default one for the account. This means IP Routes belong to this virtual network and Teams Clients in the account route through this virtual network, unless specified otherwise for each case."
  is_default_network: Boolean
  "A user-friendly name chosen when the virtual network is created. Cannot be empty."
  name: String
}

union argo_tunnel_create_argo_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_tunnel_create_argo_tunnel_4xx_response") = tunnel_response_single | argo_tunnel_create_argo_tunnel_4xx_response

type argo_tunnel_create_argo_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input argo_tunnel_create_argo_tunnel_request_Input {
  "A user-friendly name chosen when the tunnel is created. Cannot be empty."
  name: String!
  "32 or more bytes, encoded as a base64 string. The Create Argo Tunnel endpoint sets this as the tunnel's password. Anyone wishing to run the tunnel needs this password."
  tunnel_secret: String!
}

union argo_tunnel_delete_argo_tunnel_response @statusCodeTypeName(statusCode: 200, typeName: "tunnel_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_tunnel_delete_argo_tunnel_4xx_response") = tunnel_response_single | argo_tunnel_delete_argo_tunnel_4xx_response

type argo_tunnel_delete_argo_tunnel_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union argo_tunnel_clean_up_argo_tunnel_connections_response @statusCodeTypeName(statusCode: 200, typeName: "argo_tunnel_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_tunnel_clean_up_argo_tunnel_connections_4xx_response") = argo_tunnel_components_schemas_empty_response | argo_tunnel_clean_up_argo_tunnel_connections_4xx_response

type argo_tunnel_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type argo_tunnel_clean_up_argo_tunnel_connections_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall__legacy_create_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "virtual_dns_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall__legacy_create_dns_firewall_cluster_4xx_response") = virtual_dns_single_response | dns_firewall__legacy_create_dns_firewall_cluster_4xx_response

type dns_firewall__legacy_create_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_firewall__legacy_create_dns_firewall_cluster_request_Input {
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat = 900
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat = 60
  "DNS Firewall Cluster Name."
  name: virtual_dns_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat = 900
  origin_ips: [JSON]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster).\\nNotes: A ratelimit of 0 turns off the ratelimit. Otherwise the minimum is 100."
  ratelimit: Float
}

union dns_firewall__legacy_delete_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "dns_firewall__legacy_delete_dns_firewall_cluster_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall__legacy_delete_dns_firewall_cluster_4xx_response") = dns_firewall__legacy_delete_dns_firewall_cluster_200_response | dns_firewall__legacy_delete_dns_firewall_cluster_4xx_response

type dns_firewall__legacy_delete_dns_firewall_cluster_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_dns_firewall__legacy_delete_dns_firewall_cluster_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_dns_firewall__legacy_delete_dns_firewall_cluster_oneOf_0_allOf_1_result {
  "Identifier"
  id: common_components_schemas_identifier!
}

type dns_firewall__legacy_delete_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dns_firewall__legacy_update_dns_firewall_cluster_response @statusCodeTypeName(statusCode: 200, typeName: "virtual_dns_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_firewall__legacy_update_dns_firewall_cluster_4xx_response") = virtual_dns_single_response | dns_firewall__legacy_update_dns_firewall_cluster_4xx_response

type dns_firewall__legacy_update_dns_firewall_cluster_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_virtual_dns_Input {
  "Deprecate the response to ANY requests."
  deprecate_any_requests: Boolean!
  "Forward client IP (resolver) subnet if no EDNS Client Subnet is sent."
  ecs_fallback: Boolean!
  "Identifier"
  id: common_components_schemas_identifier
  "Maximum DNS Cache TTL."
  maximum_cache_ttl: PositiveFloat! = 900
  "Minimum DNS Cache TTL."
  minimum_cache_ttl: PositiveFloat! = 60
  "Last modification of DNS Firewall cluster."
  modified_on: DateTime
  "DNS Firewall Cluster Name."
  name: virtual_dns_components_schemas_name!
  "Negative DNS Cache TTL."
  negative_cache_ttl: PositiveFloat = 900
  origin_ips: [JSON]!
  "Ratelimit in queries per second per datacenter (applies to DNS queries sent to the origin nameservers configured on the cluster).\\nNotes: A ratelimit of 0 turns off the ratelimit. Otherwise the minimum is 100."
  ratelimit: Float
  virtual_dns_ips: [JSON]!
}

union worker_account_settings_create_worker_account_settings_response @statusCodeTypeName(statusCode: 200, typeName: "account_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_account_settings_create_worker_account_settings_4xx_response") = account_settings_response | worker_account_settings_create_worker_account_settings_4xx_response

type worker_account_settings_create_worker_account_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_domain_attach_to_domain_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_domain_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_domain_attach_to_domain_4xx_response") = schemas_domain_response_single | worker_domain_attach_to_domain_4xx_response

type worker_domain_attach_to_domain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input worker_domain_attach_to_domain_request_Input {
  "Worker environment associated with the zone and hostname."
  environment: String!
  "Hostname of the Worker Domain."
  hostname: String!
  "Worker service associated with the zone and hostname."
  service: String!
  "Identifier of the zone."
  zone_id: String!
}

union queue_create_queue_response @statusCodeTypeName(statusCode: 200, typeName: "queue_create_queue_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_create_queue_4xx_response") = queue_create_queue_200_response | queue_create_queue_4xx_response

type queue_create_queue_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: queue_created
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type queue_created {
  created_on: JSON
  modified_on: JSON
  queue_id: JSON
  queue_name: String!
}

type queue_create_queue_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input queue_create_queue_request_Input {
  queue_name: String
}

union queue_delete_queue_response @statusCodeTypeName(statusCode: 200, typeName: "queue_delete_queue_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_delete_queue_4xx_response") = queue_delete_queue_200_response | queue_delete_queue_4xx_response

type queue_delete_queue_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type queue_delete_queue_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union queue_update_queue_response @statusCodeTypeName(statusCode: 200, typeName: "queue_update_queue_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_update_queue_4xx_response") = queue_update_queue_200_response | queue_update_queue_4xx_response

type queue_update_queue_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: queue_updated
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type queue_updated {
  created_on: JSON
  modified_on: JSON
  queue_id: JSON
  queue_name: String
}

type queue_update_queue_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input queue_update_queue_request_Input {
  queue_name: String
}

union queue_create_queue_consumer_response @statusCodeTypeName(statusCode: 200, typeName: "queue_create_queue_consumer_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_create_queue_consumer_4xx_response") = queue_create_queue_consumer_200_response | queue_create_queue_consumer_4xx_response

type queue_create_queue_consumer_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: consumer_created
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type consumer_created {
  created_on: JSON
  dead_letter_queue: String
  environment: JSON
  queue_name: JSON
  script_name: JSON
  settings: mutation_queue_create_queue_consumer_oneOf_0_allOf_1_result_settings
}

type mutation_queue_create_queue_consumer_oneOf_0_allOf_1_result_settings {
  batch_size: Float
  max_retries: Float
  max_wait_time_ms: Float
}

type queue_create_queue_consumer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input queue_create_queue_consumer_request_Input {
  dead_letter_queue: String
  environment: String
  script_name: String
  settings: mutationInput_queue_create_queue_consumer_input_settings_Input
}

input mutationInput_queue_create_queue_consumer_input_settings_Input {
  batch_size: Int
  max_retries: Int
  max_wait_time_ms: Int
}

union queue_delete_queue_consumer_response @statusCodeTypeName(statusCode: 200, typeName: "queue_delete_queue_consumer_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_delete_queue_consumer_4xx_response") = queue_delete_queue_consumer_200_response | queue_delete_queue_consumer_4xx_response

type queue_delete_queue_consumer_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type queue_delete_queue_consumer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union queue_update_queue_consumer_response @statusCodeTypeName(statusCode: 200, typeName: "queue_update_queue_consumer_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "queue_update_queue_consumer_4xx_response") = queue_update_queue_consumer_200_response | queue_update_queue_consumer_4xx_response

type queue_update_queue_consumer_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: consumer_updated
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type consumer_updated {
  created_on: JSON
  dead_letter_queue: String
  environment: JSON
  queue_name: JSON
  script_name: JSON
  settings: mutation_queue_update_queue_consumer_oneOf_0_allOf_1_result_settings
}

type mutation_queue_update_queue_consumer_oneOf_0_allOf_1_result_settings {
  batch_size: Float
  max_retries: Float
  max_wait_time_ms: Float
}

type queue_update_queue_consumer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input queue_update_queue_consumer_request_Input {
  dead_letter_queue: String
  environment: String
  script_name: String
  settings: mutationInput_queue_update_queue_consumer_input_settings_Input
}

input mutationInput_queue_update_queue_consumer_input_settings_Input {
  batch_size: Int
}

union worker_script_upload_worker_module_response @statusCodeTypeName(statusCode: 200, typeName: "worker_script_upload_worker_module_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_script_upload_worker_module_4xx_response") = worker_script_upload_worker_module_200_response | worker_script_upload_worker_module_4xx_response

type worker_script_upload_worker_module_200_response {
  errors: [JSON]
  messages: [JSON]
  result: mutation_worker_script_upload_worker_module_oneOf_0_result
  success: Boolean
}

type mutation_worker_script_upload_worker_module_oneOf_0_result {
  created_on: DateTime
  etag: String
  handlers: [String]
  id: String
  modified_on: DateTime
  usage_model: String
}

type worker_script_upload_worker_module_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input worker_script_upload_worker_module_request_Input {
  "Worker script."
  _QUOTATION_MARK_second_file_js_QUOTATION_MARK_: String @resolveRootField(field: "\\"second-file.js\\"")
  "Worker script."
  _QUOTATION_MARK_worker_js_QUOTATION_MARK_: String @resolveRootField(field: "\\"worker.js\\"")
  "Metadata for script such as bindings. Main module needs to be specified with \`main_module\`."
  metadata: String
}

union worker_cron_trigger_update_cron_triggers_response @statusCodeTypeName(statusCode: 200, typeName: "cron_trigger_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_cron_trigger_update_cron_triggers_4xx_response") = cron_trigger_response_collection | worker_cron_trigger_update_cron_triggers_4xx_response

type worker_cron_trigger_update_cron_triggers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_tail_logs_start_tail_response @statusCodeTypeName(statusCode: 200, typeName: "tail_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_tail_logs_start_tail_4xx_response") = tail_response | worker_tail_logs_start_tail_4xx_response

type worker_tail_logs_start_tail_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_tail_logs_delete_tail_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_common") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_tail_logs_delete_tail_4xx_response") = api_response_common | worker_tail_logs_delete_tail_4xx_response

type worker_tail_logs_delete_tail_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_script_update_usage_model_response @statusCodeTypeName(statusCode: 200, typeName: "usage_model_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_script_update_usage_model_4xx_response") = usage_model_response | worker_script_update_usage_model_4xx_response

type worker_script_update_usage_model_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_subdomain_create_subdomain_response @statusCodeTypeName(statusCode: 200, typeName: "subdomain_response") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_subdomain_create_subdomain_4xx_response") = subdomain_response | worker_subdomain_create_subdomain_4xx_response

type worker_subdomain_create_subdomain_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_create_an_account_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_create_an_account_ruleset_4xx_response") = ruleset_response | account_rulesets_create_an_account_ruleset_4xx_response

type account_rulesets_create_an_account_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A ruleset object."
input create_ruleset_Input {
  "An informative description of the ruleset."
  description: String
  kind: schemas_kind!
  "The human-readable name of the ruleset."
  name: String!
  phase: phase!
  "The list of rules in the ruleset."
  rules: [JSON]!
}

union account_rulesets_update_an_account_entry_point_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_update_an_account_entry_point_ruleset_4xx_response") = ruleset_response | account_rulesets_update_an_account_entry_point_ruleset_4xx_response

type account_rulesets_update_an_account_entry_point_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A ruleset object."
input update_ruleset_Input {
  "An informative description of the ruleset."
  description: String
  "The list of rules in the ruleset."
  rules: [JSON]!
}

union account_rulesets_update_an_account_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_update_an_account_ruleset_4xx_response") = ruleset_response | account_rulesets_update_an_account_ruleset_4xx_response

type account_rulesets_update_an_account_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_create_an_account_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_create_an_account_ruleset_rule_4xx_response") = ruleset_response | account_rulesets_create_an_account_ruleset_rule_4xx_response

type account_rulesets_create_an_account_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"A rule object."
input create_update_rule_Input {
  action: rules_components_schemas_action!
  action_parameters: action_parameters_Input
  "An informative description of the rule."
  description: String
  "Whether the rule should be executed."
  enabled: Boolean = true
  "The expression defining which traffic will match the rule."
  expression: String!
  logging: logging_Input
  "The reference of the rule (the rule ID by default)."
  ref: String
}

"The parameters configuring the rule action."
input action_parameters_Input {
  id: String
}

"An object configuring the rule's logging behavior."
input logging_Input {
  "Whether to generate a log when the rule matches."
  enabled: Boolean
}

union account_rulesets_delete_an_account_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_delete_an_account_ruleset_rule_4xx_response") = ruleset_response | account_rulesets_delete_an_account_ruleset_rule_4xx_response

type account_rulesets_delete_an_account_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union account_rulesets_update_an_account_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_rulesets_update_an_account_ruleset_rule_4xx_response") = ruleset_response | account_rulesets_update_an_account_ruleset_rule_4xx_response

type account_rulesets_update_an_account_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union accounts_update_account_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "accounts_update_account_4xx_response") = response_single | accounts_update_account_4xx_response

type accounts_update_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input components_schemas_account_Input {
  "Timestamp for the creation of the account"
  created_on: DateTime
  "Identifier"
  id: common_components_schemas_identifier
  "Account name"
  name: query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_name!
  settings: query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_settings_Input
}

"Account settings"
input query_user_SINGLE_QUOTE__s_account_memberships_list_memberships_oneOf_0_allOf_1_result_items_account_allOf_0_settings_Input {
  "Indicates whether membership in this account requires that\\nTwo-Factor Authentication is enabled"
  enforce_twofactor: Boolean
  "Indicates whether new zones should use the account-level custom\\nnameservers by default"
  use_account_custom_ns_by_default: Boolean
}

union access_applications_add_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "access_applications_add_a_bookmark_application_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_add_a_bookmark_application_4xx_response") = access_applications_add_a_bookmark_application_200_response | access_applications_add_a_bookmark_application_4xx_response

type access_applications_add_a_bookmark_application_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_applications_add_a_bookmark_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_applications_add_a_bookmark_application_oneOf_0_allOf_1_result {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  app_launcher_visible: JSON
  "The URL or domain of the bookmark."
  domain: String
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "The application type."
  type: String
}

type access_applications_add_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_applications_add_a_bookmark_application_request_Input {
  name: JSON!
  type: JSON!
  domain: JSON!
}

union access_applications_delete_an_access_application_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_delete_an_access_application_4xx_response") = apps_components_schemas_id_response | access_applications_delete_an_access_application_4xx_response

type apps_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_applications_delete_an_access_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_applications_delete_an_access_application_oneOf_0_allOf_1_result {
  "UUID"
  id: uuid!
}

type access_applications_delete_an_access_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_applications_update_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "access_applications_update_a_bookmark_application_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_update_a_bookmark_application_4xx_response") = access_applications_update_a_bookmark_application_200_response | access_applications_update_a_bookmark_application_4xx_response

type access_applications_update_a_bookmark_application_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_applications_update_a_bookmark_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_applications_update_a_bookmark_application_oneOf_0_allOf_1_result {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  app_launcher_visible: JSON
  "The URL or domain of the bookmark."
  domain: String
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "The application type."
  type: String
}

type access_applications_update_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_applications_update_a_bookmark_application_request_Input {
  name: JSON!
  type: JSON!
  domain: JSON!
}

union access_applications_revoke_service_tokens_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_applications_revoke_service_tokens_4xx_response") = components_schemas_empty_response | access_applications_revoke_service_tokens_4xx_response

type components_schemas_empty_response {
  result: JSON
  success: Boolean
}

type access_applications_revoke_service_tokens_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union access_policies_delete_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_policies_delete_an_access_policy_4xx_response") = policies_components_schemas_id_response | access_policies_delete_an_access_policy_4xx_response

type policies_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_policies_delete_an_access_policy_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_policies_delete_an_access_policy_oneOf_0_allOf_1_result {
  "The policy ID."
  id: components_schemas_uuid!
}

type access_policies_delete_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_policies_update_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_policies_update_an_access_policy_4xx_response") = policies_components_schemas_single_response | access_policies_update_an_access_policy_4xx_response

type access_policies_update_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_policies_update_an_access_policy_request_Input {
  "Administrators who can approve a temporary authentication request."
  approval_groups: [approval_group_Input]
  "Requires the user to request access from an administrator at the start of each session."
  approval_required: Boolean
  decision: decision!
  "Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access policy."
  name: String!
  "The order of execution for this policy. Must be unique for each policy."
  precedence: Int
  "A custom message that will appear on the purpose justification screen."
  purpose_justification_prompt: String
  "Require users to enter a justification when they log in to the application."
  purpose_justification_required: Boolean
  "Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

"A group of email addresses that can approve a temporary authentication request."
input approval_group_Input {
  "The number of approvals needed to obtain access."
  approvals_needed: NonNegativeFloat!
  "A list of emails that can approve the access request."
  email_addresses: [JSON]
  "The UUID of an re-usable email list."
  email_list_uuid: String
}

input rule_components_schemas_rule_Input @oneOf {
  Email_Input: Email_Input
  Email_domain_Input: Email_domain_Input
  Everyone_Input: Everyone_Input
  IP_ranges_Input: IP_ranges_Input
  IP_list_Input: IP_list_Input
  Valid_certificate_Input: Valid_certificate_Input
  Access_groups_Input: Access_groups_Input
  Azure_group_Input: Azure_group_Input
  Github_organization_Input: Github_organization_Input
  Google_Workspace_group_Input: Google_Workspace_group_Input
  Okta_group_Input: Okta_group_Input
  SAML_group_Input: SAML_group_Input
}

"Matches a specific email."
input Email_Input {
  email: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_0_email_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_0_email_Input {
  "The email of the user."
  email: EmailAddress!
}

"Match an entire email domain."
input Email_domain_Input {
  email_domain: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_1_email_domain_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_1_email_domain_Input {
  "The email domain to match."
  domain: String!
}

"Matches everyone."
input Everyone_Input {
  "An empty object which matches on all users."
  everyone: JSON!
}

"Matches an IP address block."
input IP_ranges_Input {
  ip: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_3_ip_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_3_ip_Input {
  "An IPv4 or IPv6 CIDR block."
  ip: String!
}

"Matches an IP address from a list."
input IP_list_Input {
  ip_list: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_4_ip_list_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_4_ip_list_Input {
  "The ID of a previously created IP list."
  id: String!
}

"Matches any valid client certificate."
input Valid_certificate_Input {
  certificate: JSON!
}

"Matches an Access group."
input Access_groups_Input {
  group: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_6_group_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_6_group_Input {
  "The ID of a previously created Access group."
  id: String!
}

"Matches an Azure group.\\nRequires an Azure identity provider."
input Azure_group_Input {
  azureAD: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_7_azureAD_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_7_azureAD_Input {
  "The ID of your Azure identity provider."
  connection_id: String!
  "The ID of an Azure group."
  id: String!
}

"Matches a Github organization.\\nRequires a Github identity provider."
input Github_organization_Input {
  github_organization: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_8_github_organization_Input! @resolveRootField(field: "github-organization")
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_8_github_organization_Input {
  "The ID of your Github identity provider."
  connection_id: String!
  "The name of the organization."
  name: String!
}

"Matches a group in Google Workspace.\\nRequires a Google Workspace identity provider."
input Google_Workspace_group_Input {
  gsuite: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_9_gsuite_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_9_gsuite_Input {
  "The ID of your Google Workspace identity provider."
  connection_id: String!
  "The email of the Google Workspace group."
  email: EmailAddress!
}

"Matches an Okta group.\\nRequires an Okta identity provider."
input Okta_group_Input {
  okta: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_10_okta_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_10_okta_Input {
  "The ID of your Okta identity provider."
  connection_id: String!
  "The email of the Okta group."
  email: EmailAddress!
}

"Matches a SAML group.\\nRequires a SAML identity provider."
input SAML_group_Input {
  saml: query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_11_saml_Input!
}

input query_access_policies_get_an_access_policy_oneOf_0_allOf_1_result_exclude_items_oneOf_11_saml_Input {
  "The name of the SAML attribute."
  attribute_name: String!
  "The SAML attribute value to look for."
  attribute_value: EmailAddress!
}

union access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_id_response | access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response

type ca_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_oneOf_0_allOf_1_result {
  "The ID of the CA."
  id: ca_components_schemas_id
}

type access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_single_response | access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response

type access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_policies_create_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_policies_create_an_access_policy_4xx_response") = policies_components_schemas_single_response | access_policies_create_an_access_policy_4xx_response

type access_policies_create_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_policies_create_an_access_policy_request_Input {
  "Administrators who can approve a temporary authentication request."
  approval_groups: [approval_group_Input]
  "Requires the user to request access from an administrator at the start of each session."
  approval_required: Boolean
  decision: decision!
  "Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access policy."
  name: String!
  "The order of execution for this policy. Must be unique for each policy."
  precedence: Int
  "A custom message that will appear on the purpose justification screen."
  purpose_justification_prompt: String
  "Require users to enter a justification when they log in to the application."
  purpose_justification_required: Boolean
  "Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union access_bookmark_applications__deprecated_delete_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "bookmarks_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_bookmark_applications__deprecated_delete_a_bookmark_application_4xx_response") = bookmarks_components_schemas_id_response | access_bookmark_applications__deprecated_delete_a_bookmark_application_4xx_response

type bookmarks_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_bookmark_applications__deprecated_delete_a_bookmark_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_bookmark_applications__deprecated_delete_a_bookmark_application_oneOf_0_allOf_1_result {
  "UUID"
  id: uuid!
}

type access_bookmark_applications__deprecated_delete_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_bookmark_applications__deprecated_create_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "bookmarks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_bookmark_applications__deprecated_create_a_bookmark_application_4xx_response") = bookmarks_components_schemas_single_response | access_bookmark_applications__deprecated_create_a_bookmark_application_4xx_response

type access_bookmark_applications__deprecated_create_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_bookmark_applications__deprecated_update_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "bookmarks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_bookmark_applications__deprecated_update_a_bookmark_application_4xx_response") = bookmarks_components_schemas_single_response | access_bookmark_applications__deprecated_update_a_bookmark_application_4xx_response

type access_bookmark_applications__deprecated_update_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_m_tls_authentication_add_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_m_tls_authentication_add_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | access_m_tls_authentication_add_an_m_tls_certificate_4xx_response

type access_m_tls_authentication_add_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_m_tls_authentication_add_an_m_tls_certificate_request_Input {
  "The hostnames of the applications that will use this certificate."
  associated_hostnames: [String]
  "The certificate content."
  certificate: String!
  "The name of the certificate."
  name: String!
}

union access_m_tls_authentication_delete_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response") = certificates_components_schemas_id_response | access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response

type certificates_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_m_tls_authentication_delete_an_m_tls_certificate_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_m_tls_authentication_delete_an_m_tls_certificate_oneOf_0_allOf_1_result {
  "UUID"
  id: uuid!
}

type access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_m_tls_authentication_update_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_m_tls_authentication_update_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | access_m_tls_authentication_update_an_m_tls_certificate_4xx_response

type access_m_tls_authentication_update_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_m_tls_authentication_update_an_m_tls_certificate_request_Input {
  "The hostnames of the applications that will use this certificate."
  associated_hostnames: [String]!
  "The name of the certificate."
  name: String!
}

union access_groups_create_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_groups_create_an_access_group_4xx_response") = groups_components_schemas_single_response | access_groups_create_an_access_group_4xx_response

type access_groups_create_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_groups_create_an_access_group_request_Input {
  "Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access group."
  name: String!
  "Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union access_groups_delete_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_groups_delete_an_access_group_4xx_response") = groups_components_schemas_id_response | access_groups_delete_an_access_group_4xx_response

type groups_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_groups_delete_an_access_group_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_groups_delete_an_access_group_oneOf_0_allOf_1_result {
  "The unique identifier for the Access group."
  id: JSON!
}

type access_groups_delete_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_groups_update_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_groups_update_an_access_group_4xx_response") = groups_components_schemas_single_response | access_groups_update_an_access_group_4xx_response

type access_groups_update_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_groups_update_an_access_group_request_Input {
  "Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access group."
  name: String!
  "Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union access_identity_providers_add_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_identity_providers_add_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | access_identity_providers_add_an_access_identity_provider_4xx_response

type access_identity_providers_add_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_identity_providers_add_an_access_identity_provider_request_Input {
  config: JSON!
  "The name of the identity provider, shown to users on the login page."
  name: String!
  "The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/)."
  type: String!
}

union access_identity_providers_delete_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_identity_providers_delete_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | access_identity_providers_delete_an_access_identity_provider_4xx_response

type access_identity_providers_delete_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_identity_providers_update_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_identity_providers_update_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | access_identity_providers_update_an_access_identity_provider_4xx_response

type access_identity_providers_update_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_identity_providers_update_an_access_identity_provider_request_Input {
  config: JSON!
  "The name of the identity provider, shown to users on the login page."
  name: String!
  "The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/)."
  type: String!
}

union access_key_configuration_update_the_access_key_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keys_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_key_configuration_update_the_access_key_configuration_4xx_response") = keys_components_schemas_single_response | access_key_configuration_update_the_access_key_configuration_4xx_response

type access_key_configuration_update_the_access_key_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  "The number of days until the next key rotation."
  days_until_next_rotation: Float
  "The number of days between key rotations."
  key_rotation_interval_days: PositiveFloat
  "The timestamp of the previous key rotation."
  last_key_rotation_at: DateTime
}

input access_key_configuration_update_the_access_key_configuration_request_Input {
  "The number of days between key rotations."
  key_rotation_interval_days: PositiveFloat!
}

union access_key_configuration_rotate_access_keys_response @statusCodeTypeName(statusCode: 200, typeName: "keys_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_key_configuration_rotate_access_keys_4xx_response") = keys_components_schemas_single_response | access_key_configuration_rotate_access_keys_4xx_response

type access_key_configuration_rotate_access_keys_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  "The number of days until the next key rotation."
  days_until_next_rotation: Float
  "The number of days between key rotations."
  key_rotation_interval_days: PositiveFloat
  "The timestamp of the previous key rotation."
  last_key_rotation_at: DateTime
}

union zero_trust_organization_create_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_organization_create_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zero_trust_organization_create_your_zero_trust_organization_4xx_response

type zero_trust_organization_create_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_organization_create_your_zero_trust_organization_request_Input {
  "The unique subdomain assigned to your Zero Trust organization."
  auth_domain: String!
  "Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled."
  is_ui_read_only: Boolean
  login_design: login_design_Input
  "The name of your Zero Trust organization."
  name: String!
}

input login_design_Input {
  "The background color on your login page."
  background_color: String
  "The text at the bottom of your login page."
  footer_text: String
  "The text at the top of your login page."
  header_text: String
  "The URL of the logo on your login page."
  logo_path: URL
  "The text color on your login page."
  text_color: String
}

union zero_trust_organization_update_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_organization_update_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zero_trust_organization_update_your_zero_trust_organization_4xx_response

type zero_trust_organization_update_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_organization_update_your_zero_trust_organization_request_Input {
  "The unique subdomain assigned to your Zero Trust organization."
  auth_domain: String
  "Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled."
  is_ui_read_only: Boolean
  login_design: login_design_Input
  "The name of your Zero Trust organization."
  name: String
}

union zero_trust_organization_revoke_all_access_tokens_for_a_user_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response") = schemas_empty_response | zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response

type schemas_empty_response {
  result: Boolean
  success: Boolean
}

type zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

input zero_trust_organization_revoke_all_access_tokens_for_a_user_request_Input {
  "The email of the user to revoke."
  email: EmailAddress!
}

union zero_trust_seats_update_a_user_seat_response @statusCodeTypeName(statusCode: 200, typeName: "seats_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_seats_update_a_user_seat_4xx_response") = seats_components_schemas_response_collection | zero_trust_seats_update_a_user_seat_4xx_response

type seats_components_schemas_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [seats]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type seats {
  "True if the seat is part of Access."
  access_seat: Boolean
  created_at: DateTime
  "True if the seat is part of Gateway."
  gateway_seat: Boolean
  "The unique API identifier for the Zero Trust seat."
  seat_uid: JSON
  updated_at: DateTime
}

type zero_trust_seats_update_a_user_seat_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input seat_Input {
  "True if the seat is part of Access."
  access_seat: Boolean!
  "True if the seat is part of Gateway."
  gateway_seat: Boolean!
  "The unique API identifier for the Zero Trust seat."
  seat_uid: JSON!
}

union access_service_tokens_create_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "create_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_create_a_service_token_4xx_response") = create_response | access_service_tokens_create_a_service_token_4xx_response

type create_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_access_service_tokens_create_a_service_token_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_access_service_tokens_create_a_service_token_oneOf_0_allOf_1_result {
  "The Client ID for the service token. Access will check for this value in the \`CF-Access-Client-ID\` request header."
  client_id: String
  "The Client Secret for the service token. Access will check for this value in the \`CF-Access-Client-Secret\` request header."
  client_secret: String
  created_at: DateTime
  "The ID of the service token."
  id: JSON
  "The name of the service token."
  name: String
  updated_at: DateTime
}

type access_service_tokens_create_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_service_tokens_create_a_service_token_request_Input {
  "The name of the service token."
  name: String!
}

union access_service_tokens_delete_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_delete_a_service_token_4xx_response") = service_tokens_components_schemas_single_response | access_service_tokens_delete_a_service_token_4xx_response

type service_tokens_components_schemas_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: service_tokens
  "Whether the API call was successful"
  success: Boolean!
}

type access_service_tokens_delete_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_service_tokens_update_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_update_a_service_token_4xx_response") = service_tokens_components_schemas_single_response | access_service_tokens_update_a_service_token_4xx_response

type access_service_tokens_update_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input access_service_tokens_update_a_service_token_request_Input {
  "The name of the service token."
  name: String
}

union access_service_tokens_refresh_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_refresh_a_service_token_4xx_response") = service_tokens_components_schemas_single_response | access_service_tokens_refresh_a_service_token_4xx_response

type access_service_tokens_refresh_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union access_service_tokens_rotate_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "create_response") @statusCodeTypeName(statusCode: "4xx", typeName: "access_service_tokens_rotate_a_service_token_4xx_response") = create_response | access_service_tokens_rotate_a_service_token_4xx_response

type access_service_tokens_rotate_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union notification_webhooks_create_a_webhook_response @statusCodeTypeName(statusCode: 200, typeName: "webhooks_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_webhooks_create_a_webhook_4xx_response") = webhooks_components_schemas_id_response | notification_webhooks_create_a_webhook_4xx_response

type webhooks_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_notification_webhooks_create_a_webhook_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_notification_webhooks_create_a_webhook_oneOf_0_allOf_1_result {
  "UUID"
  id: uuid!
}

type notification_webhooks_create_a_webhook_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input notification_webhooks_create_a_webhook_request_Input {
  "The name of the webhook destination. This will be included in the request body when you receive a webhook notification."
  name: String!
  "Optional secret that will be passed in the \`cf-webhook-auth\` header when dispatching a webhook notification. Secrets are not returned in any API response body."
  secret: String
  "The POST endpoint to call when dispatching a notification."
  url: URL!
}

union notification_webhooks_delete_a_webhook_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_webhooks_delete_a_webhook_4xx_response") = api_response_collection | notification_webhooks_delete_a_webhook_4xx_response

type notification_webhooks_delete_a_webhook_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_webhooks_update_a_webhook_response @statusCodeTypeName(statusCode: 200, typeName: "webhooks_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_webhooks_update_a_webhook_4xx_response") = webhooks_components_schemas_id_response | notification_webhooks_update_a_webhook_4xx_response

type notification_webhooks_update_a_webhook_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input notification_webhooks_update_a_webhook_request_Input {
  "The name of the webhook destination. This will be included in the request body when you receive a webhook notification."
  name: String!
  "Optional secret that will be passed in the \`cf-webhook-auth\` header when dispatching a webhook notification. Secrets are not returned in any API response body."
  secret: String
  "The POST endpoint to call when dispatching a notification."
  url: URL!
}

union notification_policies_create_a_notification_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_id_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_policies_create_a_notification_policy_4xx_response") = policies_components_schemas_id_response_2 | notification_policies_create_a_notification_policy_4xx_response

type policies_components_schemas_id_response_2 {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_notification_policies_create_a_notification_policy_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_notification_policies_create_a_notification_policy_oneOf_0_allOf_1_result {
  "UUID"
  id: uuid!
}

type notification_policies_create_a_notification_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input notification_policies_create_a_notification_policy_request_Input {
  "Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values."
  alert_type: String!
  "Optional description for the Notification policy."
  description: String
  "Whether or not the Notification policy is enabled."
  enabled: Boolean! = true
  filters: components_schemas_filters_Input
  mechanisms: mechanisms_Input!
  "Name of the policy."
  name: String!
}

input components_schemas_filters_Input {
  slo: [String]
}

"List of IDs that will be used when dispatching a notification. IDs for email type will be the email address."
input mechanisms_Input {
  email: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_email_items_Input]
  pagerduty: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_pagerduty_items_Input]
  webhooks: [query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_webhooks_items_Input]
}

input query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_email_items_Input {
  id: EmailAddress
}

input query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_pagerduty_items_Input {
  id: String
}

input query_notification_policies_list_notification_policies_oneOf_0_allOf_1_result_items_mechanisms_webhooks_items_Input {
  id: String
}

union notification_policies_delete_a_notification_policy_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_policies_delete_a_notification_policy_4xx_response") = api_response_collection | notification_policies_delete_a_notification_policy_4xx_response

type notification_policies_delete_a_notification_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union notification_policies_update_a_notification_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_id_response_2") @statusCodeTypeName(statusCode: "4xx", typeName: "notification_policies_update_a_notification_policy_4xx_response") = policies_components_schemas_id_response_2 | notification_policies_update_a_notification_policy_4xx_response

type notification_policies_update_a_notification_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input notification_policies_update_a_notification_policy_request_Input {
  "Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values."
  alert_type: String
  "Optional description for the Notification policy."
  description: String
  "Whether or not the Notification policy is enabled."
  enabled: Boolean = true
  filters: components_schemas_filters_Input
  mechanisms: mechanisms_Input
  "Name of the policy."
  name: String
}

union account_level_custom_nameservers_add_account_custom_nameserver_response @statusCodeTypeName(statusCode: 200, typeName: "acns_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_add_account_custom_nameserver_4xx_response") = acns_response_single | account_level_custom_nameservers_add_account_custom_nameserver_4xx_response

type acns_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Custom_NS
  "Whether the API call was successful"
  success: Boolean!
}

type account_level_custom_nameservers_add_account_custom_nameserver_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input Custom_NS_Input_Input {
  "The FQDN of the name server."
  ns_name: Hostname!
}

union account_level_custom_nameservers_verify_account_custom_nameserver_glue_records_response @statusCodeTypeName(statusCode: 200, typeName: "acns_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_verify_account_custom_nameserver_glue_records_4xx_response") = acns_response_collection | account_level_custom_nameservers_verify_account_custom_nameserver_glue_records_4xx_response

type account_level_custom_nameservers_verify_account_custom_nameserver_glue_records_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union account_level_custom_nameservers_delete_account_custom_nameserver_response @statusCodeTypeName(statusCode: 200, typeName: "empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_delete_account_custom_nameserver_4xx_response") = empty_response | account_level_custom_nameservers_delete_account_custom_nameserver_4xx_response

type empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [JSON]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type account_level_custom_nameservers_delete_account_custom_nameserver_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_update_default_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "default_device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_update_default_device_settings_policy_4xx_response") = default_device_settings_response | devices_update_default_device_settings_policy_4xx_response

type devices_update_default_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input devices_update_default_device_settings_policy_request_Input {
  "Whether to allow the user to switch WARP between modes."
  allow_mode_switch: Boolean
  "Whether to receive update notifications when a new version of the client is available."
  allow_updates: Boolean
  "Whether to allow devices to leave the organization."
  allowed_to_leave: Boolean
  "The amount of time in minutes to reconnect after having been disabled."
  auto_connect: Float
  "Turn on the captive portal after the specified amount of time."
  captive_portal: Float
  "If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set."
  disable_auto_fallback: Boolean
  service_mode_v2: service_mode_v2_Input
  "The URL to launch when the Send Feedback button is clicked."
  support_url: URL
  "Whether to allow the user to turn off the WARP switch and disconnect the client."
  switch_locked: Boolean
}

input service_mode_v2_Input {
  "The mode to run the WARP client under."
  mode: String
  "The port number when used with proxy mode."
  port: Float
}

union devices_create_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_create_device_settings_policy_4xx_response") = device_settings_response | devices_create_device_settings_policy_4xx_response

type devices_create_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input devices_create_device_settings_policy_request_Input {
  "Whether to allow the user to switch WARP between modes."
  allow_mode_switch: Boolean
  "Whether to receive update notifications when a new version of the client is available."
  allow_updates: Boolean
  "Whether to allow devices to leave the organization."
  allowed_to_leave: Boolean
  "The amount of time in minutes to reconnect after having been disabled."
  auto_connect: Float
  "Turn on the captive portal after the specified amount of time."
  captive_portal: Float
  "If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set."
  disable_auto_fallback: Boolean
  "Whether the policy will be applied to matching devices."
  enabled: Boolean
  "The wirefilter expression to match devices."
  match: components_schemas_match!
  "The name of the device settings policy."
  name: mutationInput_devices_create_device_settings_policy_input_name!
  "The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field."
  precedence: Float!
  service_mode_v2: service_mode_v2_Input
  "The URL to launch when the Send Feedback button is clicked."
  support_url: URL
  "Whether to allow the user to turn off the WARP switch and disconnect the client."
  switch_locked: Boolean
}

"The name of the device settings policy."
scalar mutationInput_devices_create_device_settings_policy_input_name @length(min: null, max: 100)

union devices_set_split_tunnel_exclude_list_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_split_tunnel_exclude_list_4xx_response") = split_tunnel_response_collection | devices_set_split_tunnel_exclude_list_4xx_response

type devices_set_split_tunnel_exclude_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input split_tunnel_Input {
  "The address in CIDR format to exclude from the tunnel. If address is present, host must not be present."
  address: String!
  "A description of the split tunnel item, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_exclude_items_description!
  "The domain name to exclude from the tunnel. If host is present, address must not be present."
  host: String
}

union devices_set_local_domain_fallback_list_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_local_domain_fallback_list_4xx_response") = fallback_domain_response_collection | devices_set_local_domain_fallback_list_4xx_response

type devices_set_local_domain_fallback_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input fallback_domain_Input {
  "A description of the fallback domain, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_fallback_domains_items_description
  "A list of IP addresses to handle domain resolution."
  dns_server: [JSON]
  "The domain suffix to match when resolving locally."
  suffix: String!
}

union devices_set_split_tunnel_include_list_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_include_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_split_tunnel_include_list_4xx_response") = split_tunnel_include_response_collection | devices_set_split_tunnel_include_list_4xx_response

type devices_set_split_tunnel_include_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input split_tunnel_include_Input {
  "The address in CIDR format to include in the tunnel. If address is present, host must not be present."
  address: String!
  "A description of the split tunnel item, displayed in the client UI."
  description: query_devices_list_device_settings_policies_oneOf_0_allOf_1_result_items_include_items_description!
  "The domain name to include in the tunnel. If host is present, address must not be present."
  host: String
}

union devices_delete_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "device_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_delete_device_settings_policy_4xx_response") = device_settings_response_collection | devices_delete_device_settings_policy_4xx_response

type devices_delete_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_update_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_update_device_settings_policy_4xx_response") = device_settings_response | devices_update_device_settings_policy_4xx_response

type devices_update_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input devices_update_device_settings_policy_request_Input {
  "Whether to allow the user to switch WARP between modes."
  allow_mode_switch: Boolean
  "Whether to receive update notifications when a new version of the client is available."
  allow_updates: Boolean
  "Whether to allow devices to leave the organization."
  allowed_to_leave: Boolean
  "The amount of time in minutes to reconnect after having been disabled."
  auto_connect: Float
  "Turn on the captive portal after the specified amount of time."
  captive_portal: Float
  "If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers, unless this policy option is set."
  disable_auto_fallback: Boolean
  "Whether the policy will be applied to matching devices."
  enabled: Boolean
  "The wirefilter expression to match devices."
  match: components_schemas_match
  "The name of the device settings policy."
  name: mutationInput_devices_update_device_settings_policy_input_name
  "The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field."
  precedence: Float
  service_mode_v2: service_mode_v2_Input
  "The URL to launch when the Send Feedback button is clicked."
  support_url: URL
  "Whether to allow the user to turn off the WARP switch and disconnect the client."
  switch_locked: Boolean
}

"The name of the device settings policy."
scalar mutationInput_devices_update_device_settings_policy_input_name @length(min: null, max: 100)

union devices_set_split_tunnel_exclude_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response") = split_tunnel_response_collection | devices_set_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response

type devices_set_split_tunnel_exclude_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_set_local_domain_fallback_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_domain_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_local_domain_fallback_list_for_a_device_settings_policy_4xx_response") = fallback_domain_response_collection | devices_set_local_domain_fallback_list_for_a_device_settings_policy_4xx_response

type devices_set_local_domain_fallback_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union devices_set_split_tunnel_include_list_for_a_device_settings_policy_response @statusCodeTypeName(statusCode: 200, typeName: "split_tunnel_include_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_set_split_tunnel_include_list_for_a_device_settings_policy_4xx_response") = split_tunnel_include_response_collection | devices_set_split_tunnel_include_list_for_a_device_settings_policy_4xx_response

type devices_set_split_tunnel_include_list_for_a_device_settings_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union device_posture_rules_create_device_posture_rule_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_rules_create_device_posture_rule_4xx_response") = device_posture_rules_components_schemas_single_response | device_posture_rules_create_device_posture_rule_4xx_response

type device_posture_rules_create_device_posture_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input device_posture_rules_create_device_posture_rule_request_Input {
  "The description of the Device Posture Rule."
  description: String
  "Expire posture results after the specified amount of time."
  expiration: String
  input: schemas_input_Input
  "The conditions that the client must match to run the rule."
  match: [match_item_Input]
  "The name of the Device Posture Rule."
  name: String!
  "Tells the client when to run the device posture check."
  schedule: String
  type: device_posture_rules_components_schemas_type!
}

"The value to be checked against."
input schemas_input_Input {
  "API uuid tag."
  id: device_posture_rules_components_schemas_uuid!
}

input match_item_Input {
  platform: platform
}

union device_posture_integrations_create_device_posture_integration_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_integrations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_integrations_create_device_posture_integration_4xx_response") = device_posture_integrations_components_schemas_single_response | device_posture_integrations_create_device_posture_integration_4xx_response

type device_posture_integrations_create_device_posture_integration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input device_posture_integrations_create_device_posture_integration_request_Input {
  config: config_request_Input!
  "The interval between each posture check with the third party API. Use \\"m\\" for minutes (e.g. \\"5m\\") and \\"h\\" for hours (e.g. \\"12h\\")."
  interval: String!
  "The name of the Device Posture Integration."
  name: String!
  type: device_posture_integrations_components_schemas_type!
}

input config_request_Input @oneOf {
  workspace_one_config_request_Input: workspace_one_config_request_Input
  crowdstrike_config_request_Input: crowdstrike_config_request_Input
  uptycs_config_request_Input: uptycs_config_request_Input
  intune_config_request_Input: intune_config_request_Input
}

input workspace_one_config_request_Input {
  "The Workspace One API URL provided in the Workspace One Admin Dashboard."
  api_url: URL!
  "The Workspace One Authorization URL depending on your region."
  auth_url: URL!
  "The Workspace One client ID provided in the Workspace One Admin Dashboard."
  client_id: String!
  "The Workspace One client secret provided in the Workspace One Admin Dashboard."
  client_secret: String!
}

input crowdstrike_config_request_Input {
  "The Crowdstrike API URL."
  api_url: URL!
  "The Crowdstrike client ID."
  client_id: String!
  "The Crowdstrike client secret."
  client_secret: String!
  "The Crowdstrike customer ID."
  customer_id: String!
}

input uptycs_config_request_Input {
  "The Uptycs client secret."
  client_key: String!
  "The Uptycs client secret."
  client_secret: String!
  "The Uptycs customer ID."
  customer_id: String!
}

input intune_config_request_Input {
  "The Intune client ID."
  client_id: String!
  "The Intune client secret."
  client_secret: String!
  "The Intune customer ID."
  customer_id: String!
}

union device_posture_integrations_delete_device_posture_integration_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_integrations_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_integrations_delete_device_posture_integration_4xx_response") = device_posture_integrations_components_schemas_id_response | device_posture_integrations_delete_device_posture_integration_4xx_response

type device_posture_integrations_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type device_posture_integrations_delete_device_posture_integration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union device_posture_integrations_update_device_posture_integration_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_integrations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_integrations_update_device_posture_integration_4xx_response") = device_posture_integrations_components_schemas_single_response | device_posture_integrations_update_device_posture_integration_4xx_response

type device_posture_integrations_update_device_posture_integration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input device_posture_integrations_update_device_posture_integration_request_Input {
  config: config_request_Input
  "The interval between each posture check with the third party API. Use \\"m\\" for minutes (e.g. \\"5m\\") and \\"h\\" for hours (e.g. \\"12h\\")."
  interval: String
  "The name of the Device Posture Integration."
  name: String
  type: device_posture_integrations_components_schemas_type
}

union device_posture_rules_delete_device_posture_rule_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_rules_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_rules_delete_device_posture_rule_4xx_response") = device_posture_rules_components_schemas_id_response | device_posture_rules_delete_device_posture_rule_4xx_response

type device_posture_rules_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_device_posture_rules_delete_device_posture_rule_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_device_posture_rules_delete_device_posture_rule_oneOf_0_allOf_1_result {
  "API uuid tag."
  id: device_posture_rules_components_schemas_uuid!
}

type device_posture_rules_delete_device_posture_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union device_posture_rules_update_device_posture_rule_response @statusCodeTypeName(statusCode: 200, typeName: "device_posture_rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "device_posture_rules_update_device_posture_rule_4xx_response") = device_posture_rules_components_schemas_single_response | device_posture_rules_update_device_posture_rule_4xx_response

type device_posture_rules_update_device_posture_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input device_posture_rules_update_device_posture_rule_request_Input {
  "The description of the Device Posture Rule."
  description: String
  "Expire posture results after the specified amount of time."
  expiration: String
  input: schemas_input_Input
  "The conditions that the client must match to run the rule."
  match: [match_item_Input]
  "The name of the Device Posture Rule."
  name: String!
  "Tells the client when to run the device posture check."
  schedule: String
  type: device_posture_rules_components_schemas_type!
}

union devices_revoke_devices_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_revoke_devices_4xx_response") = api_response_single | devices_revoke_devices_4xx_response

type devices_revoke_devices_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_accounts_update_device_settings_for_the_zero_trust_account_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_device_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_update_device_settings_for_the_zero_trust_account_4xx_response") = gateway_account_device_settings_response | zero_trust_accounts_update_device_settings_for_the_zero_trust_account_4xx_response

type zero_trust_accounts_update_device_settings_for_the_zero_trust_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input gateway_account_device_settings_Input {
  "Enable gateway proxy filtering on TCP."
  gateway_proxy_enabled: Boolean
  "Enable gateway proxy filtering on UDP."
  gateway_udp_proxy_enabled: Boolean
}

union devices_unrevoke_devices_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "devices_unrevoke_devices_4xx_response") = api_response_single | devices_unrevoke_devices_4xx_response

type devices_unrevoke_devices_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_accounts_create_zero_trust_account_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_create_zero_trust_account_4xx_response") = gateway_account | zero_trust_accounts_create_zero_trust_account_4xx_response

type zero_trust_accounts_create_zero_trust_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_accounts_create_zero_trust_account_request_Input {
  "Cloudflare account tag."
  account_id: cf_account_id!
}

union zero_trust_accounts_update_zero_trust_account_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_config") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_update_zero_trust_account_configuration_4xx_response") = gateway_account_config | zero_trust_accounts_update_zero_trust_account_configuration_4xx_response

type zero_trust_accounts_update_zero_trust_account_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"account settings."
input gateway_account_settings_Input {
  settings: query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result_allOf_0_settings_Input
}

"account settings."
input query_zero_trust_accounts_get_zero_trust_account_configuration_oneOf_0_allOf_1_result_allOf_0_settings_Input {
  activity_log: activity_log_settings_Input
  antivirus: anti_virus_settings_Input
  block_page: block_page_settings_Input
  browser_isolation: browser_isolation_settings_Input
  fips: fips_settings_Input
  tls_decrypt: tls_settings_Input
}

"Activity log settings."
input activity_log_settings_Input {
  "Enable activity logging."
  enabled: Boolean
}

"Anti virus settings."
input anti_virus_settings_Input {
  "Set to enable antivirus scan on downloads."
  enabled_download_phase: Boolean
  "Set to enable antivirus scan on uploads."
  enabled_upload_phase: Boolean
  "Block requests for files that cannot be scanned."
  fail_closed: Boolean
}

"Block page layout settings."
input block_page_settings_Input {
  "Block page background color in #rrggbb format."
  background_color: String
  "Enable only cipher suites and TLS versions compliant with FIPS 140-2."
  enabled: Boolean
  "Block page footer text."
  footer_text: String
  "Block page header text."
  header_text: String
  "Full URL to the logo file."
  logo_path: URL
  "Admin email for users to contact."
  mailto_address: EmailAddress
  "Subject line for emails created from block page."
  mailto_subject: String
  "Block page title."
  name: String
  "Suppress detailed info at the bottom of the block page."
  suppress_footer: Boolean
}

"Browser isolation settings."
input browser_isolation_settings_Input {
  "Enable Browser Isolation."
  url_browser_isolation_enabled: Boolean
}

"FIPS settings."
input fips_settings_Input {
  "Enable only cipher suites and TLS versions compliant with FIPS 140-2."
  tls: Boolean
}

"TLS interception settings."
input tls_settings_Input {
  "Enable inspecting encrypted HTTP traffic."
  enabled: Boolean
}

union zero_trust_lists_create_zero_trust_list_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_with_list_items") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_create_zero_trust_list_4xx_response") = single_response_with_list_items | zero_trust_lists_create_zero_trust_list_4xx_response

type single_response_with_list_items {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_zero_trust_lists_create_zero_trust_list_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_zero_trust_lists_create_zero_trust_list_oneOf_0_allOf_1_result {
  created_at: DateTime
  "The description of the List."
  description: String
  "API Resource UUID tag."
  id: lists_components_schemas_uuid!
  "The items in the List."
  items: [query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items]
  "The name of the List."
  name: String
  type: lists_components_schemas_type
  updated_at: DateTime
}

type zero_trust_lists_create_zero_trust_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_lists_create_zero_trust_list_request_Input {
  "The description of the List."
  description: String
  "The items in the List."
  items: [query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items_Input]
  "The name of the List."
  name: String!
  type: lists_components_schemas_type!
}

input query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items_Input {
  created_at: DateTime
  "The value of the item in a List."
  value: String
}

union zero_trust_lists_delete_zero_trust_list_response @statusCodeTypeName(statusCode: 200, typeName: "lists_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_delete_zero_trust_list_4xx_response") = lists_components_schemas_empty_response | zero_trust_lists_delete_zero_trust_list_4xx_response

type lists_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_lists_delete_zero_trust_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_lists_patch_zero_trust_list_response @statusCodeTypeName(statusCode: 200, typeName: "lists_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_patch_zero_trust_list_4xx_response") = lists_components_schemas_single_response | zero_trust_lists_patch_zero_trust_list_4xx_response

type zero_trust_lists_patch_zero_trust_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_lists_patch_zero_trust_list_request_Input {
  "The items in the List."
  append: [query_zero_trust_lists_zero_trust_list_items_oneOf_0_allOf_1_result_items_items_Input]
  "A list of the item values you want to remove."
  remove: [String]
}

union zero_trust_lists_update_zero_trust_list_response @statusCodeTypeName(statusCode: 200, typeName: "lists_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_lists_update_zero_trust_list_4xx_response") = lists_components_schemas_single_response | zero_trust_lists_update_zero_trust_list_4xx_response

type zero_trust_lists_update_zero_trust_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_lists_update_zero_trust_list_request_Input {
  "The description of the List."
  description: String
  "The name of the List."
  name: String!
}

union zero_trust_gateway_locations_create_zero_trust_gateway_location_response @statusCodeTypeName(statusCode: 200, typeName: "locations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_locations_create_zero_trust_gateway_location_4xx_response") = locations_components_schemas_single_response | zero_trust_gateway_locations_create_zero_trust_gateway_location_4xx_response

type zero_trust_gateway_locations_create_zero_trust_gateway_location_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_locations_create_zero_trust_gateway_location_request_Input {
  "Set if the location is the default one."
  client_default: Boolean
  "Set if the location needs to resolve EDNS queries."
  ecs_support: Boolean
  "The name of the Location."
  name: String!
  "A list of network ranges that requests from this location would originate from."
  networks: [String]
}

union zero_trust_gateway_locations_delete_zero_trust_gateway_location_response @statusCodeTypeName(statusCode: 200, typeName: "locations_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_locations_delete_zero_trust_gateway_location_4xx_response") = locations_components_schemas_empty_response | zero_trust_gateway_locations_delete_zero_trust_gateway_location_4xx_response

type locations_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_locations_delete_zero_trust_gateway_location_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_locations_update_zero_trust_gateway_location_response @statusCodeTypeName(statusCode: 200, typeName: "locations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_locations_update_zero_trust_gateway_location_4xx_response") = locations_components_schemas_single_response | zero_trust_gateway_locations_update_zero_trust_gateway_location_4xx_response

type zero_trust_gateway_locations_update_zero_trust_gateway_location_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_locations_update_zero_trust_gateway_location_request_Input {
  "Set if the location is the default one."
  client_default: Boolean
  "Set if the location needs to resolve EDNS queries."
  ecs_support: Boolean
  "The name of the Location."
  name: String!
  "A list of network ranges that requests from this location would originate from."
  networks: [String]
}

union zero_trust_accounts_update_logging_settings_for_the_zero_trust_account_response @statusCodeTypeName(statusCode: 200, typeName: "gateway_account_logging_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_accounts_update_logging_settings_for_the_zero_trust_account_4xx_response") = gateway_account_logging_settings_response | zero_trust_accounts_update_logging_settings_for_the_zero_trust_account_4xx_response

type zero_trust_accounts_update_logging_settings_for_the_zero_trust_account_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input gateway_account_logging_settings_Input {
  "Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent)."
  redact_pii: Boolean
  settings_by_rule_type: query_zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_oneOf_0_allOf_1_result_settings_by_rule_type_Input
}

"Logging settings by rule type."
input query_zero_trust_accounts_get_logging_settings_for_the_zero_trust_account_oneOf_0_allOf_1_result_settings_by_rule_type_Input {
  dns: JSON
  http: JSON
  l4: JSON
}

union zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_response @statusCodeTypeName(statusCode: 200, typeName: "proxy_endpoints_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_4xx_response") = proxy_endpoints_components_schemas_single_response | zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_4xx_response

type zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_proxy_endpoints_create_proxy_endpoint_request_Input {
  "A list of CIDRs to restrict ingress connections."
  ips: [String]!
  "The name of the Proxy Endpoint."
  name: String!
  "The subdomain to be used as the destination in the proxy client."
  subdomain: String
}

union zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint_response @statusCodeTypeName(statusCode: 200, typeName: "proxy_endpoints_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint_4xx_response") = proxy_endpoints_components_schemas_empty_response | zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint_4xx_response

type proxy_endpoints_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_proxy_endpoints_delete_proxy_endpoint_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_response @statusCodeTypeName(statusCode: 200, typeName: "proxy_endpoints_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_4xx_response") = proxy_endpoints_components_schemas_single_response | zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_4xx_response

type zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_proxy_endpoints_update_proxy_endpoint_request_Input {
  "A list of CIDRs to restrict ingress connections."
  ips: [String]
  "The name of the Proxy Endpoint."
  name: String
  "The subdomain to be used as the destination in the proxy client."
  subdomain: String
}

union zero_trust_gateway_rules_create_zero_trust_gateway_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_rules_create_zero_trust_gateway_rule_4xx_response") = rules_components_schemas_single_response | zero_trust_gateway_rules_create_zero_trust_gateway_rule_4xx_response

type zero_trust_gateway_rules_create_zero_trust_gateway_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_rules_create_zero_trust_gateway_rule_request_Input {
  action: rules_components_schemas_action_2!
  "The description of the Rule."
  description: String
  "The wirefilter expression to be used for device posture check matching."
  device_posture: String
  "Set if the rule is enabled."
  enabled: Boolean
  "The protocol or layer to evaluate the traffic, identity, and device posture expressions."
  filters: [query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_filters_items]
  "The wirefilter expression to be used for identity matching."
  identity: String
  "The name of the Rule."
  name: String!
  "Precedence sets the ordering of the rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value."
  precedence: Int
  rule_settings: rule_settings_Input
  "The wirefilter expression to be used for traffic matching."
  traffic: String
}

"Additional settings that modify the rule's action."
input rule_settings_Input {
  add_headers: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_add_headers_Input
  biso_admin_controls: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_biso_admin_controls_Input
  "Enable the custom block page."
  block_page_enabled: Boolean
  "The text describing why this block occurred that will be displayed on the custom block page (if enabled)."
  block_reason: String
  check_session: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_check_session_Input
  "INSECURE - disable DNSSEC validation (for allow actions)."
  insecure_disable_dnssec_validation: Boolean
  "Include IPs in DNS resolver category blocks. By default categories only block on domain names."
  ip_categories: Boolean
  l4override: query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_l4override_Input
  "Override matching DNS queries with this."
  override_host: String
  "Override matching DNS queries with this."
  override_ips: [String]
}

"Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s)."
input query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_add_headers_Input {
  My_Next_Header: [String] @resolveRootField(field: "My-Next-Header")
  X_Custom_Header_Name: [String] @resolveRootField(field: "X-Custom-Header-Name")
}

"Configure how browser isolation behaves."
input query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_biso_admin_controls_Input {
  "Disable copy-paste."
  dcp: Boolean
  "Disable download."
  dd: Boolean
  "Disable keyboard usage."
  dk: Boolean
  "Disable printing."
  dp: Boolean
  "Disable upload."
  du: Boolean
}

"Configure how session check behaves."
input query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_check_session_Input {
  "Configure how fresh the session needs to be to be considered valid."
  duration: String
  "Enable session enforcement for this fule."
  enforce: Boolean
}

"Send matching traffic to the supplied destination IP address and port."
input query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_rule_settings_l4override_Input {
  "IPv4 or IPv6 address."
  ip: String
  "A port number to use for TCP/UDP overrides."
  port: Int
}

union zero_trust_gateway_rules_delete_zero_trust_gateway_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rules_components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_rules_delete_zero_trust_gateway_rule_4xx_response") = rules_components_schemas_empty_response | zero_trust_gateway_rules_delete_zero_trust_gateway_rule_4xx_response

type rules_components_schemas_empty_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type zero_trust_gateway_rules_delete_zero_trust_gateway_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zero_trust_gateway_rules_update_zero_trust_gateway_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rules_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zero_trust_gateway_rules_update_zero_trust_gateway_rule_4xx_response") = rules_components_schemas_single_response | zero_trust_gateway_rules_update_zero_trust_gateway_rule_4xx_response

type zero_trust_gateway_rules_update_zero_trust_gateway_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zero_trust_gateway_rules_update_zero_trust_gateway_rule_request_Input {
  action: rules_components_schemas_action_2!
  "The description of the Rule."
  description: String
  "The wirefilter expression to be used for device posture check matching."
  device_posture: String
  "Set if the rule is enabled."
  enabled: Boolean
  "The protocol or layer to evaluate the traffic, identity, and device posture expressions."
  filters: [query_zero_trust_gateway_rules_list_zero_trust_gateway_rules_oneOf_0_allOf_1_result_items_filters_items]
  "The wirefilter expression to be used for identity matching."
  identity: String
  "The name of the Rule."
  name: String!
  "Precedence sets the ordering of the rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value."
  precedence: Int
  rule_settings: rule_settings_Input
  "The wirefilter expression to be used for traffic matching."
  traffic: String
}

union origin_ca_create_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "origin_ca_create_certificate_4xx_response") = schemas_certificate_response_single | origin_ca_create_certificate_4xx_response

type origin_ca_create_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input origin_ca_create_certificate_request_Input {
  "The Certificate Signing Request (CSR). Must be newline-encoded."
  csr: String
  "Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate."
  hostnames: [JSON]
  request_type: request_type
  requested_validity: requested_validity = _5475
}

union origin_ca_revoke_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "origin_ca_revoke_certificate_4xx_response") = certificate_response_single_id | origin_ca_revoke_certificate_4xx_response

type certificate_response_single_id {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_origin_ca_revoke_certificate_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_origin_ca_revoke_certificate_oneOf_0_allOf_1_result {
  "The x509 serial number of the Origin CA certificate."
  id: String!
}

type origin_ca_revoke_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_SINGLE_QUOTE__s_account_memberships_delete_membership_response @statusCodeTypeName(statusCode: 200, typeName: "user_SINGLE_QUOTE__s_account_memberships_delete_membership_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_account_memberships_delete_membership_4xx_response") = user_SINGLE_QUOTE__s_account_memberships_delete_membership_200_response | user_SINGLE_QUOTE__s_account_memberships_delete_membership_4xx_response

type user_SINGLE_QUOTE__s_account_memberships_delete_membership_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_user_SINGLE_QUOTE__s_account_memberships_delete_membership_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_user_SINGLE_QUOTE__s_account_memberships_delete_membership_oneOf_0_allOf_1_result {
  "Membership identifier tag."
  id: membership_components_schemas_identifier!
}

type user_SINGLE_QUOTE__s_account_memberships_delete_membership_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_SINGLE_QUOTE__s_account_memberships_update_membership_response @statusCodeTypeName(statusCode: 200, typeName: "single_membership_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_account_memberships_update_membership_4xx_response") = single_membership_response | user_SINGLE_QUOTE__s_account_memberships_update_membership_4xx_response

type user_SINGLE_QUOTE__s_account_memberships_update_membership_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input user_SINGLE_QUOTE__s_account_memberships_update_membership_request_Input {
  status: mutationInput_user_SINGLE_QUOTE__s_account_memberships_update_membership_input_status!
}

"Whether to accept or reject this account invitation."
enum mutationInput_user_SINGLE_QUOTE__s_account_memberships_update_membership_input_status {
  accepted
  rejected
}

union organizations__deprecated_edit_organization_response @statusCodeTypeName(statusCode: 200, typeName: "single_organization_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organizations__deprecated_edit_organization_4xx_response") = single_organization_response | organizations__deprecated_edit_organization_4xx_response

type organizations__deprecated_edit_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organizations__deprecated_edit_organization_request_Input {
  "Organization name."
  name: schemas_name
}

union organization_invites_create_invitation_response @statusCodeTypeName(statusCode: 200, typeName: "single_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_invites_create_invitation_4xx_response") = single_invite_response | organization_invites_create_invitation_4xx_response

type organization_invites_create_invitation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organization_invites_create_invitation_request_Input {
  "When present and set to true, allows for the invited user to be automatically accepted to the organization. No invitation is sent."
  auto_accept: Boolean
  "Email address of the user to add to the organization."
  invited_member_email: EmailAddress!
  "Array of Roles associated with the invited user."
  roles: [mutationInput_organization_invites_create_invitation_input_roles_items_Input]!
}

input mutationInput_organization_invites_create_invitation_input_roles_items_Input {
  "Description of role's permissions."
  description: String
  "Role identifier tag."
  id: role_components_schemas_identifier
  "Role Name."
  name: components_schemas_name
  "Access permissions for this User."
  permissions: [query_organization_invites_list_invitations_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_roles_items_permissions_items]
}

union organization_invites_cancel_invitation_response @statusCodeTypeName(statusCode: 200, typeName: "organization_invites_cancel_invitation_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_invites_cancel_invitation_4xx_response") = organization_invites_cancel_invitation_200_response | organization_invites_cancel_invitation_4xx_response

type organization_invites_cancel_invitation_200_response {
  "Invite identifier tag."
  id: invite_components_schemas_identifier!
}

type organization_invites_cancel_invitation_4xx_response {
  "Invite identifier tag."
  id: invite_components_schemas_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_invites_edit_invitation_roles_response @statusCodeTypeName(statusCode: 200, typeName: "single_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_invites_edit_invitation_roles_4xx_response") = single_invite_response | organization_invites_edit_invitation_roles_4xx_response

type organization_invites_edit_invitation_roles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organization_invites_edit_invitation_roles_request_Input {
  "Array of Roles associated with the invited user."
  roles: [role_components_schemas_identifier]
}

union organization_members_remove_member_response @statusCodeTypeName(statusCode: 200, typeName: "organization_members_remove_member_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_members_remove_member_4xx_response") = organization_members_remove_member_200_response | organization_members_remove_member_4xx_response

type organization_members_remove_member_200_response {
  "Identifier"
  id: common_components_schemas_identifier!
}

type organization_members_remove_member_4xx_response {
  "Identifier"
  id: common_components_schemas_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_members_edit_member_roles_response @statusCodeTypeName(statusCode: 200, typeName: "single_member_response") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_members_edit_member_roles_4xx_response") = single_member_response | organization_members_edit_member_roles_4xx_response

type organization_members_edit_member_roles_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organization_members_edit_member_roles_request_Input {
  "Array of Roles associated with this Member."
  roles: [role_components_schemas_identifier]
}

union organization_railgun_create_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_create_railgun_4xx_response") = railgun_response_single | organization_railgun_create_railgun_4xx_response

type organization_railgun_create_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organization_railgun_create_railgun_request_Input {
  "Readable identifier of the Railgun."
  name: railgun_components_schemas_name!
}

union organization_railgun_delete_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_delete_railgun_4xx_response") = railgun_response_single_id | organization_railgun_delete_railgun_4xx_response

type organization_railgun_delete_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union organization_railgun_enable_or_disable_a_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "organization_railgun_enable_or_disable_a_railgun_4xx_response") = railgun_response_single | organization_railgun_enable_or_disable_a_railgun_4xx_response

type organization_railgun_enable_or_disable_a_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input organization_railgun_enable_or_disable_a_railgun_request_Input {
  "Flag to determine if the Railgun is accepting connections."
  enabled: Boolean!
}

union radar_datasets_get_dataset_download_url_response @statusCodeTypeName(statusCode: 200, typeName: "radar_datasets_get_dataset_download_url_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "radar_datasets_get_dataset_download_url_4xx_response") = radar_datasets_get_dataset_download_url_200_response | radar_datasets_get_dataset_download_url_4xx_response

type radar_datasets_get_dataset_download_url_200_response {
  dataset: [mutation_radar_datasets_get_dataset_download_url_oneOf_0_dataset_items]
}

type mutation_radar_datasets_get_dataset_download_url_oneOf_0_dataset_items {
  url: URL
}

type radar_datasets_get_dataset_download_url_4xx_response {
  dataset: [mutation_radar_datasets_get_dataset_download_url_oneOf_1_allOf_0_dataset_items]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_radar_datasets_get_dataset_download_url_oneOf_1_allOf_0_dataset_items {
  url: URL
}

input radar_datasets_get_dataset_download_url_request_Input {
  datasetId: Int
}

union railgun_create_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_create_railgun_4xx_response") = railgun_response_single | railgun_create_railgun_4xx_response

type railgun_create_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input railgun_create_railgun_request_Input {
  "Readable identifier of the Railgun."
  name: railgun_components_schemas_name!
}

union railgun_delete_a_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_delete_a_railgun_4xx_response") = railgun_response_single_id | railgun_delete_a_railgun_4xx_response

type railgun_delete_a_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union railgun_enable_or_disable_a_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_enable_or_disable_a_railgun_4xx_response") = railgun_response_single | railgun_enable_or_disable_a_railgun_4xx_response

type railgun_enable_or_disable_a_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input railgun_enable_or_disable_a_railgun_request_Input {
  "Flag to determine if the Railgun is accepting connections."
  enabled: Boolean!
}

union user_edit_user_response @statusCodeTypeName(statusCode: 200, typeName: "single_user_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_edit_user_4xx_response") = single_user_response | user_edit_user_4xx_response

type user_edit_user_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input user_edit_user_request_Input {
  "The country in which the user lives."
  country: country
  "User's first name"
  first_name: first_name
  "User's last name"
  last_name: last_name
  "User's telephone number"
  telephone: telephone
  "The zipcode or postal code where the user lives."
  zipcode: zipcode
}

union ip_access_rules_for_a_user_create_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_user_create_an_ip_access_rule_4xx_response") = rule_single_response | ip_access_rules_for_a_user_create_an_ip_access_rule_4xx_response

type rule_single_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: rule
  "Whether the API call was successful"
  success: Boolean!
}

type ip_access_rules_for_a_user_create_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_a_user_create_an_ip_access_rule_request_Input {
  configuration: schemas_configuration_Input!
  mode: schemas_mode!
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
}

union ip_access_rules_for_a_user_delete_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_user_delete_an_ip_access_rule_4xx_response") = rule_single_id_response | ip_access_rules_for_a_user_delete_an_ip_access_rule_4xx_response

type rule_single_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_ip_access_rules_for_a_user_delete_an_ip_access_rule_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_ip_access_rules_for_a_user_delete_an_ip_access_rule_oneOf_0_allOf_1_result {
  "The unique identifier of the IP Access rule."
  id: rule_components_schemas_identifier!
}

type ip_access_rules_for_a_user_delete_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_a_user_update_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_user_update_an_ip_access_rule_4xx_response") = rule_single_response | ip_access_rules_for_a_user_update_an_ip_access_rule_4xx_response

type ip_access_rules_for_a_user_update_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_a_user_update_an_ip_access_rule_request_Input {
  mode: schemas_mode
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
}

union user_SINGLE_QUOTE__s_invites_respond_to_invitation_response @statusCodeTypeName(statusCode: 200, typeName: "single_invite_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_invites_respond_to_invitation_4xx_response") = single_invite_response | user_SINGLE_QUOTE__s_invites_respond_to_invitation_4xx_response

type user_SINGLE_QUOTE__s_invites_respond_to_invitation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input user_SINGLE_QUOTE__s_invites_respond_to_invitation_request_Input {
  status: mutationInput_user_SINGLE_QUOTE__s_invites_respond_to_invitation_input_status!
}

"Status of your response to the invitation (rejected or accepted)."
enum mutationInput_user_SINGLE_QUOTE__s_invites_respond_to_invitation_input_status {
  accepted
  rejected
}

union load_balancer_monitors_create_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_create_monitor_4xx_response") = monitor_components_schemas_single_response | load_balancer_monitors_create_monitor_4xx_response

type load_balancer_monitors_create_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_monitors_create_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union load_balancer_monitors_delete_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_delete_monitor_4xx_response") = monitor_components_schemas_id_response | load_balancer_monitors_delete_monitor_4xx_response

type load_balancer_monitors_delete_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_monitors_patch_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_patch_monitor_4xx_response") = monitor_components_schemas_single_response | load_balancer_monitors_patch_monitor_4xx_response

type load_balancer_monitors_patch_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_monitors_patch_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union load_balancer_monitors_update_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "monitor_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_update_monitor_4xx_response") = monitor_components_schemas_single_response | load_balancer_monitors_update_monitor_4xx_response

type load_balancer_monitors_update_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_monitors_update_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "Object description."
  description: String
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations."
  interval: Int = 60
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors."
  probe_zone: String
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union load_balancer_monitors_preview_monitor_response @statusCodeTypeName(statusCode: 200, typeName: "preview_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_monitors_preview_monitor_4xx_response") = preview_response | load_balancer_monitors_preview_monitor_4xx_response

type load_balancer_monitors_preview_monitor_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_monitors_preview_monitor_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union load_balancer_pools_patch_pools_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_patch_pools_4xx_response") = pool_components_schemas_response_collection | load_balancer_pools_patch_pools_4xx_response

type load_balancer_pools_patch_pools_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input load_balancer_pools_patch_pools_request_Input {
  notification_email: patch_pools_notification_email
}

union load_balancer_pools_create_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_create_pool_4xx_response") = pool_components_schemas_single_response | load_balancer_pools_create_pool_4xx_response

type load_balancer_pools_create_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_pools_create_pool_request_Input {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  "A human-readable description of the pool."
  description: String
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String!
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]!
}

union load_balancer_pools_delete_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_delete_pool_4xx_response") = pool_components_schemas_id_response | load_balancer_pools_delete_pool_4xx_response

type load_balancer_pools_delete_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancer_pools_patch_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_patch_pool_4xx_response") = pool_components_schemas_single_response | load_balancer_pools_patch_pool_4xx_response

type load_balancer_pools_patch_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_pools_patch_pool_request_Input {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  "A human-readable description of the pool."
  description: String
  "This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at."
  disabled_at: DateTime
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]
}

union load_balancer_pools_update_pool_response @statusCodeTypeName(statusCode: 200, typeName: "pool_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_update_pool_4xx_response") = pool_components_schemas_single_response | load_balancer_pools_update_pool_4xx_response

type load_balancer_pools_update_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_pools_update_pool_request_Input {
  "A list of regions from which to run health checks. Null means every Cloudflare data center."
  check_regions: [query_account_load_balancer_pools_list_pools_oneOf_0_allOf_1_result_items_check_regions_items]
  "A human-readable description of the pool."
  description: String
  "This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at."
  disabled_at: DateTime
  "Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any)."
  enabled: Boolean = true
  "The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set."
  latitude: Float
  load_shedding: load_shedding_Input
  "The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set."
  longitude: Float
  "The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool."
  minimum_origins: Int = 1
  "The ID of the Monitor to use for checking the health of origins within this pool."
  monitor: JSON
  "A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed."
  name: String!
  "The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list."
  notification_email: String
  notification_filter: notification_filter_Input
  origin_steering: origin_steering_Input
  "The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy."
  origins: [schemas_origin_Input]!
}

union load_balancer_pools_preview_pool_response @statusCodeTypeName(statusCode: 200, typeName: "preview_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancer_pools_preview_pool_4xx_response") = preview_response | load_balancer_pools_preview_pool_4xx_response

type load_balancer_pools_preview_pool_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancer_pools_preview_pool_request_Input {
  "Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors."
  expected_body: String
  "The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors."
  expected_codes: String! = "200"
  "Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors."
  follow_redirects: Boolean
  header: header_Input
  "The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks."
  method: String = "GET"
  "The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors."
  path: String = "/"
  "Port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443)."
  port: Int
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  type: monitor_components_schemas_type = http
}

union user_SINGLE_QUOTE__s_organizations_leave_organization_response @statusCodeTypeName(statusCode: 200, typeName: "user_SINGLE_QUOTE__s_organizations_leave_organization_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_SINGLE_QUOTE__s_organizations_leave_organization_4xx_response") = user_SINGLE_QUOTE__s_organizations_leave_organization_200_response | user_SINGLE_QUOTE__s_organizations_leave_organization_4xx_response

type user_SINGLE_QUOTE__s_organizations_leave_organization_200_response {
  "Identifier"
  id: common_components_schemas_identifier!
}

type user_SINGLE_QUOTE__s_organizations_leave_organization_4xx_response {
  "Identifier"
  id: common_components_schemas_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_subscription_delete_user_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "user_subscription_delete_user_subscription_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_subscription_delete_user_subscription_4xx_response") = user_subscription_delete_user_subscription_200_response | user_subscription_delete_user_subscription_4xx_response

type user_subscription_delete_user_subscription_200_response {
  "Subscription identifier tag."
  subscription_id: subscription_v2_components_schemas_identifier!
}

type user_subscription_delete_user_subscription_4xx_response {
  "Subscription identifier tag."
  subscription_id: subscription_v2_components_schemas_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_subscription_update_user_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "user_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_subscription_update_user_subscription_4xx_response") = user_subscription_response_single | user_subscription_update_user_subscription_4xx_response

type user_subscription_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type user_subscription_update_user_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_api_tokens_create_token_response @statusCodeTypeName(statusCode: 200, typeName: "response_create") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_create_token_4xx_response") = response_create | user_api_tokens_create_token_4xx_response

type response_create {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_user_api_tokens_create_token_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_user_api_tokens_create_token_oneOf_0_allOf_1_result {
  JSON: JSON @resolveRoot
  "The token value."
  value: value
}

"The token value."
scalar value @length(min: 40, max: 80)

type user_api_tokens_create_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_payload_Input {
  condition: condition_Input
  "The expiration time on or after which the JWT MUST NOT be accepted for processing."
  expires_on: DateTime
  "Token name."
  name: name!
  "The time before which the token MUST NOT be accepted for processing."
  not_before: DateTime
  "List of access policies assigned to the token."
  policies: [policy_with_permission_groups_Input]!
}

input condition_Input {
  request_ip: request_ip_Input @resolveRootField(field: "request.ip")
}

"Client IP restrictions."
input request_ip_Input {
  "List of IPv4/IPv6 CIDR addresses."
  in: [String]
  "List of IPv4/IPv6 CIDR addresses."
  not_in: [String]
}

"Token name."
scalar name @length(min: null, max: 120)

input policy_with_permission_groups_Input {
  effect: effect!
  "Policy identifier."
  id: String
  "A set of permission groups that are specified to the policy."
  permission_groups: [permission_group_Input]!
  resources: resources_Input!
}

"Allow or deny operations against the resources."
enum effect {
  allow
  deny
}

"A named group of permissions that map to a group of operations against resources."
input permission_group_Input {
  "Identifier of the group."
  id: String
  "Name of the group."
  name: String
}

"A list of resource names that the policy applies to."
input resources_Input {
  com_cloudflare_api_account_zone_22b1de5f1c0e4b3ea97bb1e963b06a43: String @resolveRootField(field: "com.cloudflare.api.account.zone.22b1de5f1c0e4b3ea97bb1e963b06a43")
  com_cloudflare_api_account_zone_eb78d65290b24279ba6f44721b3ea3c4: String @resolveRootField(field: "com.cloudflare.api.account.zone.eb78d65290b24279ba6f44721b3ea3c4")
}

union user_api_tokens_delete_token_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_delete_token_4xx_response") = api_response_single_id | user_api_tokens_delete_token_4xx_response

type user_api_tokens_delete_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_api_tokens_update_token_response @statusCodeTypeName(statusCode: 200, typeName: "response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_update_token_4xx_response") = response_single | user_api_tokens_update_token_4xx_response

type user_api_tokens_update_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_token_Input {
  condition: condition_Input
  "The expiration time on or after which the JWT MUST NOT be accepted for processing."
  expires_on: DateTime
  "Token identifier tag."
  id: components_schemas_identifier
  "The time on which the token was created."
  issued_on: DateTime
  "Last time the token was modified."
  modified_on: DateTime
  "Token name."
  name: name!
  "The time before which the token MUST NOT be accepted for processing."
  not_before: DateTime
  "List of access policies assigned to the token."
  policies: [policy_with_permission_groups_Input]!
  status: status!
}

union user_api_tokens_roll_token_response @statusCodeTypeName(statusCode: 200, typeName: "response_single_value") @statusCodeTypeName(statusCode: "4xx", typeName: "user_api_tokens_roll_token_4xx_response") = response_single_value | user_api_tokens_roll_token_4xx_response

type response_single_value {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The token value."
  result: value
  "Whether the API call was successful"
  success: Boolean!
}

type user_api_tokens_roll_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_create_zone_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_create_zone_4xx_response") = components_schemas_response_single | zone_create_zone_4xx_response

type zone_create_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_create_Input {
  account: mutationInput_zone_create_zone_input_account_Input
  name: properties_name
  type: components_schemas_type
}

"Account in which the zone was created."
input mutationInput_zone_create_zone_input_account_Input {
  "Identifier"
  id: common_components_schemas_identifier
}

"A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup."
enum components_schemas_type {
  full
  partial
}

union load_balancers_delete_load_balancer_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_delete_load_balancer_4xx_response") = load_balancer_components_schemas_id_response | load_balancers_delete_load_balancer_4xx_response

type load_balancer_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_load_balancers_delete_load_balancer_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_load_balancers_delete_load_balancer_oneOf_0_allOf_1_result {
  id: String!
}

type load_balancers_delete_load_balancer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancers_patch_load_balancer_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_patch_load_balancer_4xx_response") = load_balancer_components_schemas_single_response | load_balancers_patch_load_balancer_4xx_response

type load_balancers_patch_load_balancer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancers_patch_load_balancer_request_Input {
  adaptive_routing: adaptive_routing_Input
  country_pools: country_pools_Input
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]
  "Object description."
  description: String
  "Whether to enable (the default) this load balancer."
  enabled: Boolean = true
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON
  location_strategy: location_strategy_Input
  "The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used."
  name: String
  pop_pools: pop_pools_Input
  "Whether the hostname should be gray clouded (false) or orange clouded (true)."
  proxied: Boolean
  random_steering: random_steering_Input
  region_pools: region_pools_Input
  "BETA Field Not General Access: A list of rules for this load balancer to execute."
  rules: [query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_Input]
  session_affinity: session_affinity = _QUOTATION_MARK__QUOTATION_MARK_
  session_affinity_attributes: session_affinity_attributes_Input
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy = _QUOTATION_MARK__QUOTATION_MARK_
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

"Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin."
input adaptive_routing_Input {
  "Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See \`session_affinity_attributes\` for control over when sessions are broken or reassigned."
  failover_across_pools: Boolean
}

"A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools."
input country_pools_Input {
  GB: [String]
  US: [String]
}

"Controls location-based steering for non-proxied requests. See \`steering_policy\` to learn how steering is affected."
input location_strategy_Input {
  mode: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_mode = pop
  prefer_ecs: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_location_strategy_prefer_ecs = proximity
}

"(Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools."
input pop_pools_Input {
  LAX: [String]
  LHR: [String]
  SJC: [String]
}

"Configures pool weights for random steering. When steering_policy is 'random', a random pool is selected with probability proportional to these pool weights."
input random_steering_Input {
  "The default weight for pools in the load balancer that are not specified in the pool_weights map."
  default_weight: NonNegativeFloat = 1
  pool_weights: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_random_steering_pool_weights_Input
}

"A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer."
input query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_random_steering_pool_weights_Input {
  _9290f38c5d07c2e2f4df57b1f61d4196: Float @resolveRootField(field: "9290f38c5d07c2e2f4df57b1f61d4196")
  de90f38ced07c2e2f4df50b1f61d4194: Float
}

"A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools."
input region_pools_Input {
  ENAM: [String]
  WNAM: [String]
}

"A rule object containing conditions and overrides for this load balancer to evaluate."
input query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_Input {
  "The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions."
  condition: String
  "Disable this specific rule. It will no longer be evaluated by this load balancer."
  disabled: Boolean
  fixed_response: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_Input
  "Name of this rule. Only used for human readability."
  name: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_name
  overrides: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_Input
  "The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority."
  priority: Int
  "If this rule's condition is true, this causes rule evaluation to stop after processing this rule."
  terminates: Boolean
}

"A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates."
input query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_Input {
  "The http 'Content-Type' header to include in the response."
  content_type: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_content_type
  "The http 'Location' header to include in the response."
  location: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_location
  "Text to include as the http body."
  message_body: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_fixed_response_message_body
  "The http status code to respond with."
  status_code: Int
}

"A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional."
input query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_Input {
  adaptive_routing: adaptive_routing_Input
  country_pools: country_pools_Input
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON
  location_strategy: location_strategy_Input
  pop_pools: pop_pools_Input
  random_steering: random_steering_Input
  region_pools: region_pools_Input
  session_affinity: session_affinity = _QUOTATION_MARK__QUOTATION_MARK_
  session_affinity_attributes: session_affinity_attributes_Input
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy = _QUOTATION_MARK__QUOTATION_MARK_
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

"Configures cookie attributes for session affinity cookie."
input session_affinity_attributes_Input {
  "Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer."
  drain_duration: Float
  samesite: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_samesite = Auto
  secure: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_secure = Auto
  zero_downtime_failover: query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_overrides_session_affinity_attributes_zero_downtime_failover = none
}

union load_balancers_update_load_balancer_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_update_load_balancer_4xx_response") = load_balancer_components_schemas_single_response | load_balancers_update_load_balancer_4xx_response

type load_balancers_update_load_balancer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancers_update_load_balancer_request_Input {
  adaptive_routing: adaptive_routing_Input
  country_pools: country_pools_Input
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]!
  "Object description."
  description: String
  "Whether to enable (the default) this load balancer."
  enabled: Boolean = true
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON!
  location_strategy: location_strategy_Input
  "The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used."
  name: String!
  pop_pools: pop_pools_Input
  "Whether the hostname should be gray clouded (false) or orange clouded (true)."
  proxied: Boolean
  random_steering: random_steering_Input
  region_pools: region_pools_Input
  "BETA Field Not General Access: A list of rules for this load balancer to execute."
  rules: [query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_Input]
  session_affinity: session_affinity = _QUOTATION_MARK__QUOTATION_MARK_
  session_affinity_attributes: session_affinity_attributes_Input
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy = _QUOTATION_MARK__QUOTATION_MARK_
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

union zone_delete_zone_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_delete_zone_4xx_response") = api_response_single_id | zone_delete_zone_4xx_response

type zone_delete_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_edit_zone_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_edit_zone_4xx_response") = components_schemas_response_single | zone_edit_zone_4xx_response

type zone_edit_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_patch_Input {
  "Indicates whether the zone is only using Cloudflare DNS services. A true value means the zone will not receive security or performance benefits."
  paused: Boolean
  plan: mutationInput_zone_edit_zone_input_plan_Input
  type: mutationInput_zone_edit_zone_input_type
  "An array of domains used for custom name servers. This is only\\navailable for Business and Enterprise plans."
  vanity_name_servers: [Hostname]
}

"The desired plan for the zone. Changing this value will create/cancel associated subscriptions. To view available plans for this zone, see Zone Plans."
input mutationInput_zone_edit_zone_input_plan_Input {
  "Identifier"
  id: common_components_schemas_identifier
}

"A full zone implies that DNS is hosted with Cloudflare. A partial zone is typically a partner-hosted zone or a CNAME setup. This parameter is only available to Enterprise customers or if it has been explicitly enabled on a zone."
enum mutationInput_zone_edit_zone_input_type {
  full
  partial
}

union zone_level_access_applications_add_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "zone_level_access_applications_add_a_bookmark_application_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_add_a_bookmark_application_4xx_response") = zone_level_access_applications_add_a_bookmark_application_200_response | zone_level_access_applications_add_a_bookmark_application_4xx_response

type zone_level_access_applications_add_a_bookmark_application_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_zone_level_access_applications_add_a_bookmark_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_zone_level_access_applications_add_a_bookmark_application_oneOf_0_allOf_1_result {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  app_launcher_visible: JSON
  "The URL or domain of the bookmark."
  domain: String
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "The application type."
  type: String
}

type zone_level_access_applications_add_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_applications_add_a_bookmark_application_request_Input {
  name: JSON!
  type: JSON!
  domain: JSON!
}

union zone_level_access_applications_delete_an_access_application_response @statusCodeTypeName(statusCode: 200, typeName: "apps_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_delete_an_access_application_4xx_response") = apps_components_schemas_id_response | zone_level_access_applications_delete_an_access_application_4xx_response

type zone_level_access_applications_delete_an_access_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_applications_update_a_bookmark_application_response @statusCodeTypeName(statusCode: 200, typeName: "zone_level_access_applications_update_a_bookmark_application_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_update_a_bookmark_application_4xx_response") = zone_level_access_applications_update_a_bookmark_application_200_response | zone_level_access_applications_update_a_bookmark_application_4xx_response

type zone_level_access_applications_update_a_bookmark_application_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_zone_level_access_applications_update_a_bookmark_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_zone_level_access_applications_update_a_bookmark_application_oneOf_0_allOf_1_result {
  "Audience tag."
  aud: schemas_aud
  created_at: DateTime
  "UUID"
  id: uuid!
  updated_at: DateTime
  app_launcher_visible: JSON
  "The URL or domain of the bookmark."
  domain: String
  "The image URL for the logo shown in the App Launcher dashboard."
  logo_url: URL
  "The name of the application."
  name: String
  "The application type."
  type: String
}

type zone_level_access_applications_update_a_bookmark_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_applications_update_a_bookmark_application_request_Input {
  name: JSON!
  type: JSON!
  domain: JSON!
}

union zone_level_access_applications_revoke_service_tokens_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_applications_revoke_service_tokens_4xx_response") = components_schemas_empty_response | zone_level_access_applications_revoke_service_tokens_4xx_response

type zone_level_access_applications_revoke_service_tokens_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

union zone_level_access_policies_delete_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_policies_delete_an_access_policy_4xx_response") = policies_components_schemas_id_response | zone_level_access_policies_delete_an_access_policy_4xx_response

type zone_level_access_policies_delete_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_policies_update_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_policies_update_an_access_policy_4xx_response") = policies_components_schemas_single_response | zone_level_access_policies_update_an_access_policy_4xx_response

type zone_level_access_policies_update_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_policies_update_an_access_policy_request_Input {
  "Administrators who can approve a temporary authentication request."
  approval_groups: [approval_group_Input]
  "Requires the user to request access from an administrator at the start of each session."
  approval_required: Boolean
  decision: decision!
  "Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access policy."
  name: String!
  "The order of execution for this policy. Must be unique for each policy."
  precedence: Int
  "A custom message that will appear on the purpose justification screen."
  purpose_justification_prompt: String
  "Require users to enter a justification when they log in to the application."
  purpose_justification_required: Boolean
  "Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_id_response | zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response

type zone_level_access_short_lived_certificate_c_as_delete_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_response @statusCodeTypeName(statusCode: 200, typeName: "ca_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response") = ca_components_schemas_single_response | zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response

type zone_level_access_short_lived_certificate_c_as_create_a_short_lived_certificate_ca_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_policies_create_an_access_policy_response @statusCodeTypeName(statusCode: 200, typeName: "policies_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_policies_create_an_access_policy_4xx_response") = policies_components_schemas_single_response | zone_level_access_policies_create_an_access_policy_4xx_response

type zone_level_access_policies_create_an_access_policy_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_policies_create_an_access_policy_request_Input {
  "Administrators who can approve a temporary authentication request."
  approval_groups: [approval_group_Input]
  "Requires the user to request access from an administrator at the start of each session."
  approval_required: Boolean
  decision: decision!
  "Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access policy."
  name: String!
  "The order of execution for this policy. Must be unique for each policy."
  precedence: Int
  "A custom message that will appear on the purpose justification screen."
  purpose_justification_prompt: String
  "Require users to enter a justification when they log in to the application."
  purpose_justification_required: Boolean
  "Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union zone_level_access_m_tls_authentication_add_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_m_tls_authentication_add_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | zone_level_access_m_tls_authentication_add_an_m_tls_certificate_4xx_response

type zone_level_access_m_tls_authentication_add_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_m_tls_authentication_add_an_m_tls_certificate_request_Input {
  "The hostnames of the applications that will use this certificate."
  associated_hostnames: [String]
  "The certificate content."
  certificate: String!
  "The name of the certificate."
  name: String!
}

union zone_level_access_m_tls_authentication_delete_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response") = certificates_components_schemas_id_response | zone_level_access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response

type zone_level_access_m_tls_authentication_delete_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_m_tls_authentication_update_an_m_tls_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificates_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_m_tls_authentication_update_an_m_tls_certificate_4xx_response") = certificates_components_schemas_single_response | zone_level_access_m_tls_authentication_update_an_m_tls_certificate_4xx_response

type zone_level_access_m_tls_authentication_update_an_m_tls_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_m_tls_authentication_update_an_m_tls_certificate_request_Input {
  "The hostnames of the applications that will use this certificate."
  associated_hostnames: [String]!
  "The name of the certificate."
  name: String!
}

union zone_level_access_groups_create_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_groups_create_an_access_group_4xx_response") = groups_components_schemas_single_response | zone_level_access_groups_create_an_access_group_4xx_response

type zone_level_access_groups_create_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_groups_create_an_access_group_request_Input {
  "Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access group."
  name: String!
  "Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union zone_level_access_groups_delete_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_groups_delete_an_access_group_4xx_response") = groups_components_schemas_id_response | zone_level_access_groups_delete_an_access_group_4xx_response

type zone_level_access_groups_delete_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_groups_update_an_access_group_response @statusCodeTypeName(statusCode: 200, typeName: "groups_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_groups_update_an_access_group_4xx_response") = groups_components_schemas_single_response | zone_level_access_groups_update_an_access_group_4xx_response

type zone_level_access_groups_update_an_access_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_groups_update_an_access_group_request_Input {
  "Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules."
  exclude: [rule_components_schemas_rule_Input]
  "Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules."
  include: [rule_components_schemas_rule_Input]!
  "The name of the Access group."
  name: String!
  "Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules."
  require: [rule_components_schemas_rule_Input]
}

union zone_level_access_identity_providers_add_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_identity_providers_add_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | zone_level_access_identity_providers_add_an_access_identity_provider_4xx_response

type zone_level_access_identity_providers_add_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_identity_providers_add_an_access_identity_provider_request_Input {
  config: JSON!
  "The name of the identity provider, shown to users on the login page."
  name: String!
  "The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/)."
  type: String!
}

union zone_level_access_identity_providers_delete_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_identity_providers_delete_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | zone_level_access_identity_providers_delete_an_access_identity_provider_4xx_response

type zone_level_access_identity_providers_delete_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_identity_providers_update_an_access_identity_provider_response @statusCodeTypeName(statusCode: 200, typeName: "identity_providers_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_identity_providers_update_an_access_identity_provider_4xx_response") = identity_providers_components_schemas_single_response | zone_level_access_identity_providers_update_an_access_identity_provider_4xx_response

type zone_level_access_identity_providers_update_an_access_identity_provider_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_identity_providers_update_an_access_identity_provider_request_Input {
  config: JSON!
  "The name of the identity provider, shown to users on the login page."
  name: String!
  "The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/)."
  type: String!
}

union zone_level_zero_trust_organization_create_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_zero_trust_organization_create_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zone_level_zero_trust_organization_create_your_zero_trust_organization_4xx_response

type zone_level_zero_trust_organization_create_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_zero_trust_organization_create_your_zero_trust_organization_request_Input {
  "The unique subdomain assigned to your Zero Trust organization."
  auth_domain: String!
  "Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled."
  is_ui_read_only: Boolean
  login_design: login_design_Input
  "The name of your Zero Trust organization."
  name: String!
}

union zone_level_zero_trust_organization_update_your_zero_trust_organization_response @statusCodeTypeName(statusCode: 200, typeName: "organizations_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_zero_trust_organization_update_your_zero_trust_organization_4xx_response") = organizations_components_schemas_single_response | zone_level_zero_trust_organization_update_your_zero_trust_organization_4xx_response

type zone_level_zero_trust_organization_update_your_zero_trust_organization_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_zero_trust_organization_update_your_zero_trust_organization_request_Input {
  "The unique subdomain assigned to your Zero Trust organization."
  auth_domain: String
  "Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled."
  is_ui_read_only: Boolean
  login_design: login_design_Input
  "The name of your Zero Trust organization."
  name: String
}

union zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response") = schemas_empty_response | zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response

type zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_4xx_response {
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
}

input zone_level_zero_trust_organization_revoke_all_access_tokens_for_a_user_request_Input {
  "The email of the user to revoke."
  email: EmailAddress!
}

union zone_level_access_service_tokens_create_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "create_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_service_tokens_create_a_service_token_4xx_response") = create_response | zone_level_access_service_tokens_create_a_service_token_4xx_response

type zone_level_access_service_tokens_create_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_service_tokens_create_a_service_token_request_Input {
  "The name of the service token."
  name: String!
}

union zone_level_access_service_tokens_delete_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_service_tokens_delete_a_service_token_4xx_response") = service_tokens_components_schemas_single_response | zone_level_access_service_tokens_delete_a_service_token_4xx_response

type zone_level_access_service_tokens_delete_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_access_service_tokens_update_a_service_token_response @statusCodeTypeName(statusCode: 200, typeName: "service_tokens_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_access_service_tokens_update_a_service_token_4xx_response") = service_tokens_components_schemas_single_response | zone_level_access_service_tokens_update_a_service_token_4xx_response

type zone_level_access_service_tokens_update_a_service_token_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_access_service_tokens_update_a_service_token_request_Input {
  "The name of the service token."
  name: String
}

union zone_zone_activation_check_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_zone_activation_check_4xx_response") = api_response_single_id | zone_zone_activation_check_4xx_response

type zone_zone_activation_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union load_balancers_create_load_balancer_response @statusCodeTypeName(statusCode: 200, typeName: "load_balancer_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "load_balancers_create_load_balancer_4xx_response") = load_balancer_components_schemas_single_response | load_balancers_create_load_balancer_4xx_response

type load_balancers_create_load_balancer_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input load_balancers_create_load_balancer_request_Input {
  adaptive_routing: adaptive_routing_Input
  country_pools: country_pools_Input
  "A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region."
  default_pools: [String]!
  "Object description."
  description: String
  "The pool ID to use when all other pools are detected as unhealthy."
  fallback_pool: JSON!
  location_strategy: location_strategy_Input
  "The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used."
  name: String!
  pop_pools: pop_pools_Input
  "Whether the hostname should be gray clouded (false) or orange clouded (true)."
  proxied: Boolean
  random_steering: random_steering_Input
  region_pools: region_pools_Input
  "BETA Field Not General Access: A list of rules for this load balancer to execute."
  rules: [query_load_balancers_load_balancer_details_oneOf_0_allOf_1_result_rules_items_Input]
  session_affinity: session_affinity = _QUOTATION_MARK__QUOTATION_MARK_
  session_affinity_attributes: session_affinity_attributes_Input
  "Time, in seconds, until this load balancer's session affinity cookie expires after being created. This parameter is ignored unless a supported session affinity policy is set. The current default of 23 hours will be used unless session_affinity_ttl is explicitly set. The accepted range of values is between [1800, 604800]. Once the expiry time has been reached, subsequent requests may get sent to a different origin server."
  session_affinity_ttl: Float
  steering_policy: steering_policy = _QUOTATION_MARK__QUOTATION_MARK_
  "Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers."
  ttl: Float
}

union zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix_4xx_response") = api_response_single_id | zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix_4xx_response

type zone_purge_files_by_cache_tags_COMMA__host_COMMA__or_prefix_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input purge_by_cache_tags_or_hosts_or_prefixes_Input {
  "Any assets at URLs with a host that matches one of the provided values will be purged from the Cloudflare cache."
  hosts: [String]
  "Any assets at URLs that match the prefix will be purged from the Cloudflare cache. For example, a.com/b will purge a.com/b/c/d.png but not a.com/bc.png. The prefixes a.com/b and a.com/b/c are redundant."
  prefixes: [String]
  "Any assets served with a Cache-Tag header that matches one of the provided values will be purged from the Cloudflare cache."
  tags: [String]
}

union secondary_dns__secondary_zone_force_axfr_response @statusCodeTypeName(statusCode: 200, typeName: "force_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__secondary_zone_force_axfr_4xx_response") = force_response | secondary_dns__secondary_zone_force_axfr_4xx_response

type force_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When force_axfr query parameter is set to true, the response is a simple string"
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__secondary_zone_force_axfr_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__secondary_zone_delete_secondary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__secondary_zone_delete_secondary_zone_configuration_4xx_response") = id_response | secondary_dns__secondary_zone_delete_secondary_zone_configuration_4xx_response

type id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_secondary_dns__secondary_zone_delete_secondary_zone_configuration_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_secondary_dns__secondary_zone_delete_secondary_zone_configuration_oneOf_0_allOf_1_result {
  id: String!
}

type secondary_dns__secondary_zone_delete_secondary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__secondary_zone_create_secondary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_incoming") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__secondary_zone_create_secondary_zone_configuration_4xx_response") = single_response_incoming | secondary_dns__secondary_zone_create_secondary_zone_configuration_4xx_response

type secondary_dns__secondary_zone_create_secondary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_secondary_secondary_zone_Input {
  "How often should a secondary zone auto refresh regardless of DNS NOTIFY.\\nNot applicable for primary zones."
  auto_refresh_seconds: Float!
  id: String!
  "Zone name."
  name: String!
  "A list of peer tags."
  peers: [JSON]!
}

union secondary_dns__secondary_zone_update_secondary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_incoming") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__secondary_zone_update_secondary_zone_configuration_4xx_response") = single_response_incoming | secondary_dns__secondary_zone_update_secondary_zone_configuration_4xx_response

type secondary_dns__secondary_zone_update_secondary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_delete_primary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_delete_primary_zone_configuration_4xx_response") = schemas_id_response | secondary_dns__primary_zone_delete_primary_zone_configuration_4xx_response

type schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_secondary_dns__primary_zone_delete_primary_zone_configuration_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_secondary_dns__primary_zone_delete_primary_zone_configuration_oneOf_0_allOf_1_result {
  id: String!
}

type secondary_dns__primary_zone_delete_primary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_create_primary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_outgoing") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_create_primary_zone_configuration_4xx_response") = single_response_outgoing | secondary_dns__primary_zone_create_primary_zone_configuration_4xx_response

type secondary_dns__primary_zone_create_primary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input single_request_outgoing_Input {
  id: String!
  "Zone name."
  name: String!
  "A list of peer tags."
  peers: [JSON]!
}

union secondary_dns__primary_zone_update_primary_zone_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "single_response_outgoing") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_update_primary_zone_configuration_4xx_response") = single_response_outgoing | secondary_dns__primary_zone_update_primary_zone_configuration_4xx_response

type secondary_dns__primary_zone_update_primary_zone_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_disable_outgoing_zone_transfers_response @statusCodeTypeName(statusCode: 200, typeName: "disable_transfer_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_disable_outgoing_zone_transfers_4xx_response") = disable_transfer_response | secondary_dns__primary_zone_disable_outgoing_zone_transfers_4xx_response

type disable_transfer_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The zone transfer status of a primary zone"
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__primary_zone_disable_outgoing_zone_transfers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_enable_outgoing_zone_transfers_response @statusCodeTypeName(statusCode: 200, typeName: "enable_transfer_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_enable_outgoing_zone_transfers_4xx_response") = enable_transfer_response | secondary_dns__primary_zone_enable_outgoing_zone_transfers_4xx_response

type secondary_dns__primary_zone_enable_outgoing_zone_transfers_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union secondary_dns__primary_zone_force_dns_notify_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_force_response") @statusCodeTypeName(statusCode: "4xx", typeName: "secondary_dns__primary_zone_force_dns_notify_4xx_response") = schemas_force_response | secondary_dns__primary_zone_force_dns_notify_4xx_response

type schemas_force_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When force_notify query parameter is set to true, the response is a simple string"
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type secondary_dns__primary_zone_force_dns_notify_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union analyze_certificate_analyze_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_analyze_response") @statusCodeTypeName(statusCode: "4xx", typeName: "analyze_certificate_analyze_certificate_4xx_response") = certificate_analyze_response | analyze_certificate_analyze_certificate_4xx_response

type certificate_analyze_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type analyze_certificate_analyze_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input analyze_certificate_analyze_certificate_request_Input {
  bundle_method: bundle_method = ubiquitous
  "The zone's SSL certificate or certificate and the intermediate(s)."
  certificate: String
}

union zone_subscription_create_zone_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "zone_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_subscription_create_zone_subscription_4xx_response") = zone_subscription_response_single | zone_subscription_create_zone_subscription_4xx_response

type zone_subscription_create_zone_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_subscription_update_zone_subscription_response @statusCodeTypeName(statusCode: 200, typeName: "zone_subscription_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_subscription_update_zone_subscription_4xx_response") = zone_subscription_response_single | zone_subscription_update_zone_subscription_4xx_response

type zone_subscription_update_zone_subscription_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union total_tls_enable_or_disable_total_tls_response @statusCodeTypeName(statusCode: 200, typeName: "total_tls_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "total_tls_enable_or_disable_total_tls_4xx_response") = total_tls_settings_response | total_tls_enable_or_disable_total_tls_4xx_response

type total_tls_enable_or_disable_total_tls_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input total_tls_enable_or_disable_total_tls_request_Input {
  certificate_authority: schemas_certificate_authority
  "If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone."
  enabled: Boolean!
}

union argo_smart_routing_patch_argo_smart_routing_setting_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "argo_smart_routing_patch_argo_smart_routing_setting_4xx_response") = schemas_response_single | argo_smart_routing_patch_argo_smart_routing_setting_4xx_response

type argo_smart_routing_patch_argo_smart_routing_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

"Update enablement of Argo Smart Routing"
input patch_Input {
  value: schemas_value!
}

"Enables Argo Smart Routing."
enum schemas_value {
  on
  off
}

union zone_cache_settings_change_cache_reserve_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_cache_settings_change_cache_reserve_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_cache_settings_change_cache_reserve_setting_4xx_response") = zone_cache_settings_change_cache_reserve_setting_200_response | zone_cache_settings_change_cache_reserve_setting_4xx_response

type zone_cache_settings_change_cache_reserve_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_cache_settings_get_cache_reserve_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type zone_cache_settings_change_cache_reserve_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_cache_settings_change_cache_reserve_setting_request_Input {
  value: cache_reserve_value! = off
}

union zone_cache_settings_delete_variants_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_cache_settings_delete_variants_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_cache_settings_delete_variants_setting_4xx_response") = zone_cache_settings_delete_variants_setting_200_response | zone_cache_settings_delete_variants_setting_4xx_response

type zone_cache_settings_delete_variants_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers."
  result: Variants_Caching
  "Whether the API call was successful"
  success: Boolean!
}

"Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers."
type Variants_Caching {
  id: variants_const
  "last time this setting was modified."
  modified_on: DateTime
}

type zone_cache_settings_delete_variants_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_cache_settings_change_variants_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_cache_settings_change_variants_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_cache_settings_change_variants_setting_4xx_response") = zone_cache_settings_change_variants_setting_200_response | zone_cache_settings_change_variants_setting_4xx_response

type zone_cache_settings_change_variants_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_cache_settings_get_variants_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type zone_cache_settings_change_variants_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_cache_settings_change_variants_setting_request_Input {
  value: variants_value_Input!
}

"Value of the zone setting."
input variants_value_Input {
  "List of strings with the MIME types of all the variants that should be served for avif."
  avif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for bmp."
  bmp: [JSON]
  "List of strings with the MIME types of all the variants that should be served for gif."
  gif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jp2."
  jp2: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpeg."
  jpeg: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpg."
  jpg: [JSON]
  "List of strings with the MIME types of all the variants that should be served for jpg2."
  jpg2: [JSON]
  "List of strings with the MIME types of all the variants that should be served for png."
  png: [JSON]
  "List of strings with the MIME types of all the variants that should be served for tif."
  tif: [JSON]
  "List of strings with the MIME types of all the variants that should be served for tiff."
  tiff: [JSON]
  "List of strings with the MIME types of all the variants that should be served for webp."
  webp: [JSON]
}

union custom_ssl_for_a_zone_create_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_create_ssl_configuration_4xx_response") = certificate_response_single | custom_ssl_for_a_zone_create_ssl_configuration_4xx_response

type custom_ssl_for_a_zone_create_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_ssl_for_a_zone_create_ssl_configuration_request_Input {
  bundle_method: bundle_method = ubiquitous
  "The zone's SSL certificate or certificate and the intermediate(s)."
  certificate: String!
  geo_restrictions: geo_restrictions_Input
  "Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected."
  policy: String
  "The zone's private key."
  private_key: String!
  type: custom_certificate_components_schemas_type = legacy_custom
}

"Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance."
input geo_restrictions_Input {
  label: query_custom_ssl_for_a_zone_list_ssl_configurations_oneOf_0_allOf_1_result_items_geo_restrictions_label
}

"The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake."
enum custom_certificate_components_schemas_type {
  legacy_custom
  sni_custom
}

union custom_ssl_for_a_zone_re_prioritize_ssl_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_re_prioritize_ssl_certificates_4xx_response") = certificate_response_collection | custom_ssl_for_a_zone_re_prioritize_ssl_certificates_4xx_response

type custom_ssl_for_a_zone_re_prioritize_ssl_certificates_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input custom_ssl_for_a_zone_re_prioritize_ssl_certificates_request_Input {
  "Array of ordered certificates."
  certificates: [mutationInput_custom_ssl_for_a_zone_re_prioritize_ssl_certificates_input_certificates_items_Input]!
}

input mutationInput_custom_ssl_for_a_zone_re_prioritize_ssl_certificates_input_certificates_items_Input {
  "Custom certificate identifier tag."
  id: custom_certificate_components_schemas_identifier
  "The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates."
  priority: Float = 20
}

union custom_ssl_for_a_zone_delete_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_id_only") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_delete_ssl_configuration_4xx_response") = certificate_response_id_only | custom_ssl_for_a_zone_delete_ssl_configuration_4xx_response

type certificate_response_id_only {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_custom_ssl_for_a_zone_delete_ssl_configuration_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_custom_ssl_for_a_zone_delete_ssl_configuration_oneOf_0_allOf_1_result {
  "Custom certificate identifier tag."
  id: custom_certificate_components_schemas_identifier!
}

type custom_ssl_for_a_zone_delete_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_ssl_for_a_zone_edit_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_ssl_for_a_zone_edit_ssl_configuration_4xx_response") = certificate_response_single | custom_ssl_for_a_zone_edit_ssl_configuration_4xx_response

type custom_ssl_for_a_zone_edit_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_ssl_for_a_zone_edit_ssl_configuration_request_Input {
  bundle_method: bundle_method = ubiquitous
  "The zone's SSL certificate or certificate and the intermediate(s)."
  certificate: String
  geo_restrictions: geo_restrictions_Input
  "Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected."
  policy: String
  "The zone's private key."
  private_key: String
}

union custom_hostname_for_a_zone_create_custom_hostname_response @statusCodeTypeName(statusCode: 200, typeName: "custom_hostname_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_for_a_zone_create_custom_hostname_4xx_response") = custom_hostname_response_single | custom_hostname_for_a_zone_create_custom_hostname_4xx_response

type custom_hostname_for_a_zone_create_custom_hostname_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_hostname_for_a_zone_create_custom_hostname_request_Input {
  "The custom hostname that will point to your hostname via CNAME."
  hostname: hostname
  ssl: mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_Input!
}

input mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_Input {
  bundle_method: mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_bundle_method = ubiquitous
  "If a custom uploaded certificate is used."
  custom_certificate: String
  "The key for a custom uploaded certificate."
  custom_key: String
  method: mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_method
  settings: sslsettings_Input
  type: dv_const
  "Indicates whether the certificate covers a wildcard."
  wildcard: Boolean
}

"A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it."
enum mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_bundle_method {
  ubiquitous
  optimal
  force
}

"Domain control validation (DCV) method used for this hostname."
enum mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_method {
  http
  txt
  email
}

"SSL specific settings."
input sslsettings_Input {
  "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
  ciphers: [String]
  early_hints: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_early_hints
  http2: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_http2
  min_tls_version: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_min_tls_version
  tls_1_3: query_custom_hostname_for_a_zone_list_custom_hostnames_oneOf_0_allOf_1_result_items_allOf_0_ssl_settings_tls_1_3
}

union custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_origin_response") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames_4xx_response") = fallback_origin_response | custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames_4xx_response

type custom_hostname_fallback_origin_for_a_zone_delete_fallback_origin_for_custom_hostnames_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_response @statusCodeTypeName(statusCode: 200, typeName: "fallback_origin_response") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_4xx_response") = fallback_origin_response | custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_4xx_response

type custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_hostname_fallback_origin_for_a_zone_update_fallback_origin_for_custom_hostnames_request_Input {
  "Your origin hostname that requests to your custom hostnames will be sent to."
  origin: origin!
}

"Your origin hostname that requests to your custom hostnames will be sent to."
scalar origin @length(min: null, max: 255)

union custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_response @statusCodeTypeName(statusCode: 200, typeName: "custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_4xx_response") = custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_200_response | custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_4xx_response

type custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_200_response {
  "Custom hostname identifier tag."
  id: custom_hostname_components_schemas_identifier!
}

type custom_hostname_for_a_zone_delete_custom_hostname__and_any_issued_ssl_certificates_4xx_response {
  "Custom hostname identifier tag."
  id: custom_hostname_components_schemas_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_hostname_for_a_zone_edit_custom_hostname_response @statusCodeTypeName(statusCode: 200, typeName: "custom_hostname_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_hostname_for_a_zone_edit_custom_hostname_4xx_response") = custom_hostname_response_single | custom_hostname_for_a_zone_edit_custom_hostname_4xx_response

type custom_hostname_for_a_zone_edit_custom_hostname_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_hostname_for_a_zone_edit_custom_hostname_request_Input {
  custom_metadata: custom_metadata_Input
  "a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record."
  custom_origin_server: String
  "A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server."
  custom_origin_sni: String
  ssl: mutationInput_custom_hostname_for_a_zone_create_custom_hostname_input_ssl_Input
}

"These are per-hostname (customer) settings."
input custom_metadata_Input {
  "Unique metadata for this hostname."
  key: String
}

union account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata_response @statusCodeTypeName(statusCode: 200, typeName: "empty_response") @statusCodeTypeName(statusCode: "4xx", typeName: "account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata_4xx_response") = empty_response | account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata_4xx_response

type account_level_custom_nameservers_usage_for_a_zone_set_account_custom_nameserver_related_zone_metadata_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input zone_metadata_Input {
  "Whether zone uses account-level custom nameservers."
  enabled: Boolean
}

union custom_pages_for_a_zone_update_a_custom_page_response @statusCodeTypeName(statusCode: 200, typeName: "custom_pages_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_pages_for_a_zone_update_a_custom_page_4xx_response") = custom_pages_response_single | custom_pages_for_a_zone_update_a_custom_page_4xx_response

type custom_pages_for_a_zone_update_a_custom_page_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input custom_pages_for_a_zone_update_a_custom_page_request_Input {
  state: schemas_state!
  "The URL associated with the custom page."
  url: URL!
}

"The custom page state."
enum schemas_state {
  default
  customized
}

union dns_records_for_a_zone_create_dns_record_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_create_dns_record_4xx_response") = dns_response_single | dns_records_for_a_zone_create_dns_record_4xx_response

type dns_records_for_a_zone_create_dns_record_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_records_for_a_zone_create_dns_record_request_Input {
  "DNS record content."
  content: String!
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name!
  "Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred."
  priority: NonNegativeFloat
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float!
  type: dns_record_components_schemas_type
}

"DNS record type."
enum dns_record_components_schemas_type {
  A
  AAAA
  CNAME
  HTTPS
  TXT
  SRV
  LOC
  MX
  NS
  CERT
  DNSKEY
  DS
  NAPTR
  SMIMEA
  SSHFP
  SVCB
  TLSA
  URI
}

union dns_records_for_a_zone_import_dns_records_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_import_scan") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_import_dns_records_4xx_response") = dns_response_import_scan | dns_records_for_a_zone_import_dns_records_4xx_response

type dns_response_import_scan {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
  timing: mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_timing
}

type mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_result {
  "Number of DNS records added."
  recs_added: Float
  "Total number of DNS records parsed."
  total_records_parsed: Float
}

type mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_timing {
  "When the file parsing ended."
  end_time: DateTime
  "Processing time of the file in seconds."
  process_time: Float
  "When the file parsing started."
  start_time: DateTime
}

type dns_records_for_a_zone_import_dns_records_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  timing: mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_timing
}

input dns_records_for_a_zone_import_dns_records_request_Input {
  "BIND config to upload."
  file: String!
  "Whether or not proxiable records should receive the performance and security benefits of Cloudflare."
  proxied: Boolean
}

union dns_records_for_a_zone_scan_dns_records_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_import_scan") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_scan_dns_records_4xx_response") = dns_response_import_scan | dns_records_for_a_zone_scan_dns_records_4xx_response

type dns_records_for_a_zone_scan_dns_records_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  timing: mutation_dns_records_for_a_zone_import_dns_records_oneOf_0_allOf_1_timing
}

union dns_records_for_a_zone_delete_dns_record_response @statusCodeTypeName(statusCode: 200, typeName: "dns_records_for_a_zone_delete_dns_record_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_delete_dns_record_4xx_response") = dns_records_for_a_zone_delete_dns_record_200_response | dns_records_for_a_zone_delete_dns_record_4xx_response

type dns_records_for_a_zone_delete_dns_record_200_response {
  result: mutation_dns_records_for_a_zone_delete_dns_record_oneOf_0_result
}

type mutation_dns_records_for_a_zone_delete_dns_record_oneOf_0_result {
  "DNS record identifier tag."
  id: dns_record_components_schemas_identifier!
}

type dns_records_for_a_zone_delete_dns_record_4xx_response {
  result: Void
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Whether the API call was successful"
  success: Boolean!
}

union dns_records_for_a_zone_patch_dns_record_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_patch_dns_record_4xx_response") = dns_response_single | dns_records_for_a_zone_patch_dns_record_4xx_response

type dns_records_for_a_zone_patch_dns_record_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_records_for_a_zone_patch_dns_record_request_Input {
  "DNS record content."
  content: String
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float
  type: dns_record_components_schemas_type
}

union dns_records_for_a_zone_update_dns_record_response @statusCodeTypeName(statusCode: 200, typeName: "dns_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dns_records_for_a_zone_update_dns_record_4xx_response") = dns_response_single | dns_records_for_a_zone_update_dns_record_4xx_response

type dns_records_for_a_zone_update_dns_record_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dns_records_for_a_zone_update_dns_record_request_Input {
  "DNS record content."
  content: String!
  "DNS record name (or @ for the zone apex)."
  name: dns_record_components_schemas_name!
  "Whether the record is receiving the performance and security benefits of Cloudflare."
  proxied: Boolean
  "Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'."
  ttl: Float!
  type: dns_record_components_schemas_type
}

union dnssec_delete_dnssec_records_response @statusCodeTypeName(statusCode: 200, typeName: "delete_dnssec_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dnssec_delete_dnssec_records_4xx_response") = delete_dnssec_response_single | dnssec_delete_dnssec_records_4xx_response

type delete_dnssec_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: String
  "Whether the API call was successful"
  success: Boolean!
}

type dnssec_delete_dnssec_records_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union dnssec_edit_dnssec_status_response @statusCodeTypeName(statusCode: 200, typeName: "dnssec_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "dnssec_edit_dnssec_status_4xx_response") = dnssec_response_single | dnssec_edit_dnssec_status_4xx_response

type dnssec_edit_dnssec_status_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input dnssec_edit_dnssec_status_request_Input {
  status: mutationInput_dnssec_edit_dnssec_status_input_status!
}

"Status of DNSSEC, based on user-desired state and presence of necessary records."
enum mutationInput_dnssec_edit_dnssec_status_input_status {
  active
  disabled
}

union email_routing_settings_disable_email_routing_response @statusCodeTypeName(statusCode: 200, typeName: "email_settings_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_settings_disable_email_routing_4xx_response") = email_settings_response_single | email_routing_settings_disable_email_routing_4xx_response

type email_routing_settings_disable_email_routing_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_settings_enable_email_routing_response @statusCodeTypeName(statusCode: 200, typeName: "email_settings_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_settings_enable_email_routing_4xx_response") = email_settings_response_single | email_routing_settings_enable_email_routing_4xx_response

type email_routing_settings_enable_email_routing_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_routing_rules_create_routing_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_create_routing_rule_4xx_response") = rule_response_single | email_routing_routing_rules_create_routing_rule_4xx_response

type email_routing_routing_rules_create_routing_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_rule_properties_Input {
  "List actions patterns."
  actions: [schemas_action_Input]!
  "Routing rule status."
  enabled: Boolean = true
  "Matching patterns to forward to your actions."
  matchers: [matcher_Input]!
  "Routing rule name."
  name: rules_components_schemas_name
  "Priority of the routing rule."
  priority: NonNegativeFloat
}

"Actions pattern."
input schemas_action_Input {
  type: query_email_routing_routing_rules_list_routing_rules_oneOf_0_allOf_1_result_items_allOf_0_actions_items_type!
  value: [EmailAddress]!
}

"Matching pattern to forward your actions."
input matcher_Input {
  field: to_const!
  type: literal_const!
  "Value for matcher."
  value: EmailAddress!
}

union email_routing_routing_rules_update_catch_all_rule_response @statusCodeTypeName(statusCode: 200, typeName: "catch_all_rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_update_catch_all_rule_4xx_response") = catch_all_rule_response_single | email_routing_routing_rules_update_catch_all_rule_4xx_response

type email_routing_routing_rules_update_catch_all_rule_4xx_response {
  "List actions for the catch-all routing rule."
  actions: [catchall_action]
  "Routing rule status."
  enabled: Boolean
  "List of matchers for the catch-all routing rule."
  matchers: [catchall_matcher]
  "Routing rule name."
  name: rules_components_schemas_name
  "Routing rule identifier."
  tag: rule_identifier!
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input update_catch_all_rule_properties_Input {
  "List actions for the catch-all routing rule."
  actions: [catchall_action_Input]!
  "Routing rule status."
  enabled: Boolean = true
  "List of matchers for the catch-all routing rule."
  matchers: [catchall_matcher_Input]!
  "Routing rule name."
  name: rules_components_schemas_name
}

"Action for the catch-all routing rule."
input catchall_action_Input {
  type: query_email_routing_routing_rules_get_catch_all_rule_oneOf_0_actions_items_type!
  value: [EmailAddress]
}

"Matcher for catch-all routing rule."
input catchall_matcher_Input {
  type: all_const!
}

union email_routing_routing_rules_delete_routing_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_delete_routing_rule_4xx_response") = rule_response_single | email_routing_routing_rules_delete_routing_rule_4xx_response

type email_routing_routing_rules_delete_routing_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union email_routing_routing_rules_update_routing_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "email_routing_routing_rules_update_routing_rule_4xx_response") = rule_response_single | email_routing_routing_rules_update_routing_rule_4xx_response

type email_routing_routing_rules_update_routing_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input update_rule_properties_Input {
  "List actions patterns."
  actions: [schemas_action_Input]!
  "Routing rule status."
  enabled: Boolean = true
  "Matching patterns to forward to your actions."
  matchers: [matcher_Input]!
  "Routing rule name."
  name: rules_components_schemas_name
  "Priority of the routing rule."
  priority: NonNegativeFloat
}

union filters_delete_filters_response @statusCodeTypeName(statusCode: 200, typeName: "filter_delete_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_delete_filters_4xx_response") = filter_delete_response_collection | filters_delete_filters_4xx_response

type filter_delete_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [mutation_filters_delete_filters_oneOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type mutation_filters_delete_filters_oneOf_0_allOf_1_result_items {
  "An informative summary of the filter."
  description: filters_components_schemas_description
  "The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/)."
  expression: String
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
  "When true, indicates that the filter is currently paused."
  paused: Boolean
  "A short reference tag. Allows you to select related filters."
  ref: schemas_ref
  JSON: JSON @resolveRoot
}

type filters_delete_filters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input filters_delete_filters_request_Input {
  "The unique identifier of the filter."
  id: filters_components_schemas_id
}

union filters_create_filters_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_filter_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_create_filters_4xx_response") = schemas_filter_response_collection | filters_create_filters_4xx_response

type filters_create_filters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input filters_create_filters_request_Input {
  expression: JSON!
}

union filters_update_filters_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_filter_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_update_filters_4xx_response") = schemas_filter_response_collection | filters_update_filters_4xx_response

type filters_update_filters_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input filters_update_filters_request_Input {
  id: JSON!
}

union filters_delete_a_filter_response @statusCodeTypeName(statusCode: 200, typeName: "filter_delete_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_delete_a_filter_4xx_response") = filter_delete_response_single | filters_delete_a_filter_4xx_response

type filter_delete_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_filters_delete_a_filter_oneOf_0_allOf_1_result!
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_filters_delete_a_filter_oneOf_0_allOf_1_result {
  "An informative summary of the filter."
  description: filters_components_schemas_description
  "The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/)."
  expression: String
  "The unique identifier of the filter."
  id: filters_components_schemas_id!
  "When true, indicates that the filter is currently paused."
  paused: Boolean
  "A short reference tag. Allows you to select related filters."
  ref: schemas_ref
  JSON: JSON @resolveRoot
}

type filters_delete_a_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union filters_update_a_filter_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_filter_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "filters_update_a_filter_4xx_response") = schemas_filter_response_single | filters_update_a_filter_4xx_response

type filters_update_a_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input filters_update_a_filter_request_Input {
  id: JSON!
}

union zone_lockdown_create_a_zone_lockdown_rule_response @statusCodeTypeName(statusCode: 200, typeName: "zonelockdown_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_lockdown_create_a_zone_lockdown_rule_4xx_response") = zonelockdown_response_single | zone_lockdown_create_a_zone_lockdown_rule_4xx_response

type zone_lockdown_create_a_zone_lockdown_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_lockdown_create_a_zone_lockdown_rule_request_Input {
  urls: JSON!
  configurations: JSON!
}

union zone_lockdown_delete_a_zone_lockdown_rule_response @statusCodeTypeName(statusCode: 200, typeName: "zone_lockdown_delete_a_zone_lockdown_rule_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_lockdown_delete_a_zone_lockdown_rule_4xx_response") = zone_lockdown_delete_a_zone_lockdown_rule_200_response | zone_lockdown_delete_a_zone_lockdown_rule_4xx_response

type zone_lockdown_delete_a_zone_lockdown_rule_200_response {
  result: mutation_zone_lockdown_delete_a_zone_lockdown_rule_oneOf_0_result
}

type mutation_zone_lockdown_delete_a_zone_lockdown_rule_oneOf_0_result {
  "The unique identifier of the Zone Lockdown rule."
  id: lockdowns_components_schemas_id!
}

type zone_lockdown_delete_a_zone_lockdown_rule_4xx_response {
  result: Void
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Whether the API call was successful"
  success: Boolean!
}

union zone_lockdown_update_a_zone_lockdown_rule_response @statusCodeTypeName(statusCode: 200, typeName: "zonelockdown_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_lockdown_update_a_zone_lockdown_rule_4xx_response") = zonelockdown_response_single | zone_lockdown_update_a_zone_lockdown_rule_4xx_response

type zone_lockdown_update_a_zone_lockdown_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_lockdown_update_a_zone_lockdown_rule_request_Input {
  urls: JSON!
  configurations: JSON!
}

union firewall_rules_delete_firewall_rules_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection_delete") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_delete_firewall_rules_4xx_response") = filter_rules_response_collection_delete | firewall_rules_delete_firewall_rules_4xx_response

type filter_rules_response_collection_delete {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [mutation_firewall_rules_delete_firewall_rules_oneOf_0_allOf_1_result_items]!
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type mutation_firewall_rules_delete_firewall_rules_oneOf_0_allOf_1_result_items {
  action: firewall_rules_components_schemas_action
  "An informative summary of the firewall rule."
  description: firewall_rules_components_schemas_description
  "The unique identifier of the firewall rule."
  id: firewall_rules_components_schemas_id!
  "When true, indicates that the firewall rule is currently paused."
  paused: Boolean
  "The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority."
  priority: NonNegativeFloat
  products: [query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_products_items]
  "A short reference tag. Allows you to select related firewall rules."
  ref: ref
  filter: query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_filter
  JSON: JSON @resolveRoot
}

type firewall_rules_delete_firewall_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input firewall_rules_delete_firewall_rules_request_Input {
  "The unique identifier of the firewall rule."
  id: firewall_rules_components_schemas_id
}

union firewall_rules_update_priority_of_firewall_rules_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_update_priority_of_firewall_rules_4xx_response") = filter_rules_response_collection | firewall_rules_update_priority_of_firewall_rules_4xx_response

type firewall_rules_update_priority_of_firewall_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input firewall_rules_update_priority_of_firewall_rules_request_Input {
  id: JSON!
}

union firewall_rules_create_firewall_rules_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_create_firewall_rules_4xx_response") = filter_rules_response_collection | firewall_rules_create_firewall_rules_4xx_response

type firewall_rules_create_firewall_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input firewall_rules_create_firewall_rules_request_Input {
  filter: JSON!
  action: JSON!
}

union firewall_rules_update_firewall_rules_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_update_firewall_rules_4xx_response") = filter_rules_response_collection | firewall_rules_update_firewall_rules_4xx_response

type firewall_rules_update_firewall_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input firewall_rules_update_firewall_rules_request_Input {
  id: JSON!
}

union firewall_rules_delete_a_firewall_rule_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_single_response_delete") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_delete_a_firewall_rule_4xx_response") = filter_rules_single_response_delete | firewall_rules_delete_a_firewall_rule_4xx_response

type filter_rules_single_response_delete {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_firewall_rules_delete_a_firewall_rule_oneOf_0_allOf_1_result!
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_firewall_rules_delete_a_firewall_rule_oneOf_0_allOf_1_result {
  action: firewall_rules_components_schemas_action
  "An informative summary of the firewall rule."
  description: firewall_rules_components_schemas_description
  "The unique identifier of the firewall rule."
  id: firewall_rules_components_schemas_id!
  "When true, indicates that the firewall rule is currently paused."
  paused: Boolean
  "The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority."
  priority: NonNegativeFloat
  products: [query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_0_products_items]
  "A short reference tag. Allows you to select related firewall rules."
  ref: ref
  filter: query_firewall_rules_list_firewall_rules_oneOf_0_allOf_1_result_items_allOf_0_allOf_1_filter
  JSON: JSON @resolveRoot
}

type firewall_rules_delete_a_firewall_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input firewall_rules_delete_a_firewall_rule_request_Input {
  "When true, indicates that Cloudflare should also delete the associated filter if there are no other firewall rules referencing the filter."
  delete_filter_if_unused: Boolean
}

union firewall_rules_update_priority_of_a_firewall_rule_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_update_priority_of_a_firewall_rule_4xx_response") = filter_rules_response_collection | firewall_rules_update_priority_of_a_firewall_rule_4xx_response

type firewall_rules_update_priority_of_a_firewall_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input firewall_rules_update_priority_of_a_firewall_rule_request_Input {
  id: JSON!
}

union firewall_rules_update_a_firewall_rule_response @statusCodeTypeName(statusCode: 200, typeName: "filter_rules_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "firewall_rules_update_a_firewall_rule_4xx_response") = filter_rules_single_response | firewall_rules_update_a_firewall_rule_4xx_response

type firewall_rules_update_a_firewall_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input firewall_rules_update_a_firewall_rule_request_Input {
  id: JSON!
  filter: JSON!
  action: JSON!
}

union user_agent_blocking_rules_create_a_user_agent_blocking_rule_response @statusCodeTypeName(statusCode: 200, typeName: "firewalluablock_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_agent_blocking_rules_create_a_user_agent_blocking_rule_4xx_response") = firewalluablock_response_single | user_agent_blocking_rules_create_a_user_agent_blocking_rule_4xx_response

type user_agent_blocking_rules_create_a_user_agent_blocking_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input user_agent_blocking_rules_create_a_user_agent_blocking_rule_request_Input {
  mode: JSON!
  configuration: JSON!
}

union user_agent_blocking_rules_delete_a_user_agent_blocking_rule_response @statusCodeTypeName(statusCode: 200, typeName: "user_agent_blocking_rules_delete_a_user_agent_blocking_rule_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "user_agent_blocking_rules_delete_a_user_agent_blocking_rule_4xx_response") = user_agent_blocking_rules_delete_a_user_agent_blocking_rule_200_response | user_agent_blocking_rules_delete_a_user_agent_blocking_rule_4xx_response

type user_agent_blocking_rules_delete_a_user_agent_blocking_rule_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_user_agent_blocking_rules_delete_a_user_agent_blocking_rule_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_user_agent_blocking_rules_delete_a_user_agent_blocking_rule_oneOf_0_allOf_1_result {
  "The unique identifier of the User Agent Blocking rule."
  id: ua_rules_components_schemas_id!
}

type user_agent_blocking_rules_delete_a_user_agent_blocking_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union user_agent_blocking_rules_update_a_user_agent_blocking_rule_response @statusCodeTypeName(statusCode: 200, typeName: "firewalluablock_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "user_agent_blocking_rules_update_a_user_agent_blocking_rule_4xx_response") = firewalluablock_response_single | user_agent_blocking_rules_update_a_user_agent_blocking_rule_4xx_response

type user_agent_blocking_rules_update_a_user_agent_blocking_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input user_agent_blocking_rules_update_a_user_agent_blocking_rule_request_Input {
  id: JSON!
  mode: JSON!
  configuration: JSON!
}

union waf_overrides_create_a_waf_override_response @statusCodeTypeName(statusCode: 200, typeName: "override_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_overrides_create_a_waf_override_4xx_response") = override_response_single | waf_overrides_create_a_waf_override_4xx_response

type waf_overrides_create_a_waf_override_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input waf_overrides_create_a_waf_override_request_Input {
  urls: JSON!
}

union waf_overrides_delete_a_waf_override_response @statusCodeTypeName(statusCode: 200, typeName: "waf_overrides_delete_a_waf_override_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_overrides_delete_a_waf_override_4xx_response") = waf_overrides_delete_a_waf_override_200_response | waf_overrides_delete_a_waf_override_4xx_response

type waf_overrides_delete_a_waf_override_200_response {
  result: mutation_waf_overrides_delete_a_waf_override_oneOf_0_result
}

type mutation_waf_overrides_delete_a_waf_override_oneOf_0_result {
  "The unique identifier of the WAF override."
  id: overrides_components_schemas_id!
}

type waf_overrides_delete_a_waf_override_4xx_response {
  result: Void
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Whether the API call was successful"
  success: Boolean!
}

union waf_overrides_update_waf_override_response @statusCodeTypeName(statusCode: 200, typeName: "override_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_overrides_update_waf_override_4xx_response") = override_response_single | waf_overrides_update_waf_override_4xx_response

type waf_overrides_update_waf_override_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input waf_overrides_update_waf_override_request_Input {
  id: JSON!
  urls: JSON!
  rules: JSON!
  rewrite_action: JSON!
}

union waf_packages_update_a_waf_package_response @statusCodeTypeName(statusCode: 200, typeName: "waf_packages_update_a_waf_package_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_packages_update_a_waf_package_4xx_response") = waf_packages_update_a_waf_package_200_response | waf_packages_update_a_waf_package_4xx_response

type waf_packages_update_a_waf_package_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Anomaly_detection_WAF_package_OWASP
  "Whether the API call was successful"
  success: Boolean!
}

type waf_packages_update_a_waf_package_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input waf_packages_update_a_waf_package_request_Input {
  action_mode: action_mode = challenge
  sensitivity: sensitivity = high
}

union waf_rule_groups_update_a_waf_rule_group_response @statusCodeTypeName(statusCode: 200, typeName: "rule_group_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rule_groups_update_a_waf_rule_group_4xx_response") = rule_group_response_single | waf_rule_groups_update_a_waf_rule_group_4xx_response

type waf_rule_groups_update_a_waf_rule_group_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input waf_rule_groups_update_a_waf_rule_group_request_Input {
  mode: components_schemas_mode = on
}

union health_checks_create_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_create_health_check_4xx_response") = healthchecks_components_schemas_single_response | health_checks_create_health_check_4xx_response

type health_checks_create_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input query_healthcheck_Input {
  "The hostname or IP address of the origin server to run health checks on."
  address: String!
  "A list of regions from which to run health checks. Null means Cloudflare will pick a default region."
  check_regions: [query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_check_regions_items]
  "The number of consecutive fails required from a health check before changing the health to unhealthy."
  consecutive_fails: Int = 1
  "The number of consecutive successes required from a health check before changing the health to healthy."
  consecutive_successes: Int = 1
  "A human-readable description of the health check."
  description: String
  http_config: http_config_Input
  "The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations."
  interval: Int = 60
  "A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String!
  "The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately."
  retries: Int = 2
  "If suspended, no health checks are sent to the origin."
  suspended: Boolean
  tcp_config: tcp_config_Input
  "The timeout (in seconds) before marking the health check as failed."
  timeout: Int = 5
  "The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'."
  type: String = "HTTP"
}

"Parameters specific to an HTTP or HTTPS health check."
input http_config_Input {
  "Do not validate the certificate when the health check uses HTTPS."
  allow_insecure: Boolean
  "A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy."
  expected_body: String
  "The expected HTTP response codes (e.g. \\"200\\") or code ranges (e.g. \\"2xx\\" for all codes starting with 2) of the health check."
  expected_codes: [String] = "200"
  "Follow redirects if the origin returns a 3xx status code."
  follow_redirects: Boolean
  header: query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_header_Input
  method: query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_method = GET
  "The endpoint path to health check against."
  path: String = "/"
  "Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS."
  port: Int = 80
}

"The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden."
input query_health_checks_list_health_checks_oneOf_0_allOf_1_result_items_http_config_header_Input {
  Host: [String]
  X_App_ID: [String] @resolveRootField(field: "X-App-ID")
}

"Parameters specific to TCP health check."
input tcp_config_Input {
  method: connection_established_const
  "Port number to connect to for the health check. Defaults to 80."
  port: Int = 80
}

union health_checks_create_preview_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_create_preview_health_check_4xx_response") = healthchecks_components_schemas_single_response | health_checks_create_preview_health_check_4xx_response

type health_checks_create_preview_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_delete_preview_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_delete_preview_health_check_4xx_response") = healthchecks_components_schemas_id_response | health_checks_delete_preview_health_check_4xx_response

type healthchecks_components_schemas_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_health_checks_delete_preview_health_check_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_health_checks_delete_preview_health_check_oneOf_0_allOf_1_result {
  id: String!
}

type health_checks_delete_preview_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_delete_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_delete_health_check_4xx_response") = healthchecks_components_schemas_id_response | health_checks_delete_health_check_4xx_response

type health_checks_delete_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_patch_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_patch_health_check_4xx_response") = healthchecks_components_schemas_single_response | health_checks_patch_health_check_4xx_response

type health_checks_patch_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union health_checks_update_health_check_response @statusCodeTypeName(statusCode: 200, typeName: "healthchecks_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "health_checks_update_health_check_4xx_response") = healthchecks_components_schemas_single_response | health_checks_update_health_check_4xx_response

type health_checks_update_health_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union keyless_ssl_for_a_zone_create_keyless_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keyless_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "keyless_ssl_for_a_zone_create_keyless_ssl_configuration_4xx_response") = keyless_response_single | keyless_ssl_for_a_zone_create_keyless_ssl_configuration_4xx_response

type keyless_ssl_for_a_zone_create_keyless_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input keyless_ssl_for_a_zone_create_keyless_ssl_configuration_request_Input {
  bundle_method: bundle_method = ubiquitous
  "The zone's SSL certificate or SSL certificate and intermediate(s)."
  certificate: String!
  "The keyless SSL name."
  host: Hostname!
  "The keyless SSL name."
  name: keyless_certificate_components_schemas_name
  "The keyless SSL port used to commmunicate between Cloudflare and the client's Keyless SSL server."
  port: Float! = 24008
}

union keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keyless_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_4xx_response") = keyless_response_single_id | keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_4xx_response

type keyless_response_single_id {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_oneOf_0_allOf_1_result {
  "Keyless certificate identifier tag."
  id: keyless_certificate_components_schemas_identifier!
}

type keyless_ssl_for_a_zone_delete_keyless_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_response @statusCodeTypeName(statusCode: 200, typeName: "keyless_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_4xx_response") = keyless_response_single | keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_4xx_response

type keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input keyless_ssl_for_a_zone_edit_keyless_ssl_configuration_request_Input {
  "Whether or not the Keyless SSL is on or off."
  enabled: Boolean
  "The keyless SSL name."
  host: Hostname
  "The keyless SSL name."
  name: keyless_certificate_components_schemas_name
  "The keyless SSL port used to commmunicate between Cloudflare and the client's Keyless SSL server."
  port: Float = 24008
}

union logpush_jobs_create_logpush_job_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_job_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_create_logpush_job_4xx_response") = logpush_job_response_single | logpush_jobs_create_logpush_job_4xx_response

type logpush_jobs_create_logpush_job_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_create_logpush_job_request_Input {
  dataset: dataset!
  "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included."
  destination_conf: URL!
  "Flag that indicates if the job was enabled."
  enabled: Boolean
  frequency: components_schemas_frequency = high
  "Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately."
  logpull_options: UriReference
  name: logpush_components_schemas_name
  ownership_challenge: ownership_challenge
}

"The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files."
enum components_schemas_frequency {
  high
  low
}

"Represents uri-reference values"
scalar UriReference

scalar logpush_components_schemas_name @regexp(pattern: "^[a-zA-Z0-9\\\\-\\\\.]*$") @typescript(type: "string")

scalar ownership_challenge @regexp(pattern: "^[a-zA-Z0-9/\\\\+\\\\.\\\\-_]*$") @typescript(type: "string")

union logpush_jobs_delete_logpush_job_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_jobs_delete_logpush_job_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_delete_logpush_job_4xx_response") = logpush_jobs_delete_logpush_job_200_response | logpush_jobs_delete_logpush_job_4xx_response

type logpush_jobs_delete_logpush_job_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type logpush_jobs_delete_logpush_job_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union logpush_jobs_update_logpush_job_response @statusCodeTypeName(statusCode: 200, typeName: "logpush_job_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_update_logpush_job_4xx_response") = logpush_job_response_single | logpush_jobs_update_logpush_job_4xx_response

type logpush_jobs_update_logpush_job_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_update_logpush_job_request_Input {
  "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included."
  destination_conf: URL
  "Flag that indicates if the job was enabled."
  enabled: Boolean
  frequency: components_schemas_frequency = high
  "Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately."
  logpull_options: UriReference
  ownership_challenge: ownership_challenge
}

union logpush_jobs_get_ownership_challenge_response @statusCodeTypeName(statusCode: 200, typeName: "get_ownership_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_get_ownership_challenge_4xx_response") = get_ownership_response | logpush_jobs_get_ownership_challenge_4xx_response

type get_ownership_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_logpush_jobs_get_ownership_challenge_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_logpush_jobs_get_ownership_challenge_oneOf_0_allOf_1_result {
  filename: String
  message: String
  valid: Boolean
}

type logpush_jobs_get_ownership_challenge_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_get_ownership_challenge_request_Input {
  "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included."
  destination_conf: URL!
}

union logpush_jobs_validate_ownership_challenge_response @statusCodeTypeName(statusCode: 200, typeName: "validate_ownership_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_validate_ownership_challenge_4xx_response") = validate_ownership_response | logpush_jobs_validate_ownership_challenge_4xx_response

type validate_ownership_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_logpush_jobs_validate_ownership_challenge_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_logpush_jobs_validate_ownership_challenge_oneOf_0_allOf_1_result {
  valid: Boolean
}

type logpush_jobs_validate_ownership_challenge_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_validate_ownership_challenge_request_Input {
  "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included."
  destination_conf: URL!
  ownership_challenge: ownership_challenge!
}

union logpush_jobs_check_destination_exists_response @statusCodeTypeName(statusCode: 200, typeName: "destination_exists_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_check_destination_exists_4xx_response") = destination_exists_response | logpush_jobs_check_destination_exists_4xx_response

type destination_exists_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_logpush_jobs_check_destination_exists_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_logpush_jobs_check_destination_exists_oneOf_0_allOf_1_result {
  exists: Boolean
}

type logpush_jobs_check_destination_exists_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_check_destination_exists_request_Input {
  "Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included."
  destination_conf: URL!
}

union logpush_jobs_validate_origin_response @statusCodeTypeName(statusCode: 200, typeName: "validate_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logpush_jobs_validate_origin_4xx_response") = validate_response | logpush_jobs_validate_origin_4xx_response

type validate_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_logpush_jobs_validate_origin_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_logpush_jobs_validate_origin_oneOf_0_allOf_1_result {
  message: String
  valid: Boolean
}

type logpush_jobs_validate_origin_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logpush_jobs_validate_origin_request_Input {
  "Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately."
  logpull_options: UriReference
}

union logs_received_update_log_retention_flag_response @statusCodeTypeName(statusCode: 200, typeName: "flag_response") @statusCodeTypeName(statusCode: "4xx", typeName: "logs_received_update_log_retention_flag_4xx_response") = flag_response | logs_received_update_log_retention_flag_4xx_response

type logs_received_update_log_retention_flag_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input logs_received_update_log_retention_flag_request_Input {
  "The log retention flag for Logpull API."
  flag: Boolean!
}

union zone_level_authenticated_origin_pulls_upload_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_upload_certificate_4xx_response") = certificate_response_single | zone_level_authenticated_origin_pulls_upload_certificate_4xx_response

type zone_level_authenticated_origin_pulls_upload_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_authenticated_origin_pulls_upload_certificate_request_Input {
  "The zone's leaf certificate."
  certificate: String!
  "The zone's private key."
  private_key: String!
}

union per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_response @statusCodeTypeName(statusCode: 200, typeName: "hostname_aop_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_4xx_response") = hostname_aop_response_collection | per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_4xx_response

type hostname_aop_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: [hostname_authenticated_origin_pull]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input per_hostname_authenticated_origin_pull_enable_or_disable_a_hostname_for_client_authentication_request_Input {
  config: [hostname_certid_input_Input]!
}

input hostname_certid_input_Input {
  "Certificate identifier tag."
  cert_id: hostname_authenticated_origin_pull_components_schemas_identifier
  "Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association."
  enabled: Boolean
  "The hostname on the origin for which the client certificate uploaded will be used."
  hostname: schemas_hostname!
}

union per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_4xx_response") = components_schemas_certificate_response_single | per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_4xx_response

type per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input per_hostname_authenticated_origin_pull_upload_a_hostname_client_certificate_request_Input {
  "The hostname certificate."
  certificate: String!
  "The hostname certificate's private key."
  private_key: String!
}

union per_hostname_authenticated_origin_pull_delete_hostname_client_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "components_schemas_certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "per_hostname_authenticated_origin_pull_delete_hostname_client_certificate_4xx_response") = components_schemas_certificate_response_single | per_hostname_authenticated_origin_pull_delete_hostname_client_certificate_4xx_response

type per_hostname_authenticated_origin_pull_delete_hostname_client_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_level_authenticated_origin_pulls_set_enablement_for_zone_response @statusCodeTypeName(statusCode: 200, typeName: "enabled_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_set_enablement_for_zone_4xx_response") = enabled_response | zone_level_authenticated_origin_pulls_set_enablement_for_zone_4xx_response

type zone_level_authenticated_origin_pulls_set_enablement_for_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_level_authenticated_origin_pulls_set_enablement_for_zone_request_Input {
  "Indicates whether zone-level authenticated origin pulls is enabled."
  enabled: Boolean!
}

union zone_level_authenticated_origin_pulls_delete_certificate_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_level_authenticated_origin_pulls_delete_certificate_4xx_response") = certificate_response_single | zone_level_authenticated_origin_pulls_delete_certificate_4xx_response

type zone_level_authenticated_origin_pulls_delete_certificate_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_rules_create_a_page_rule_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_create_a_page_rule_4xx_response") = pagerule_response_single | page_rules_create_a_page_rule_4xx_response

type page_rules_create_a_page_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input page_rules_create_a_page_rule_request_Input {
  "The set of actions to perform if the targets of this rule match the request. Actions can redirect to another URL or override settings, but not both."
  actions: [route_Input]!
  "The priority of the rule, used to define which Page Rule is processed over another. A higher number indicates a higher priority. For example, if you have a catch-all Page Rule (rule A: \`/images/*\`) but want a more specific Page Rule to take precedence (rule B: \`/images/special/*\`), specify a higher priority for rule B so it overrides rule A."
  priority: Int = 1
  status: page_rule_components_schemas_status = disabled
  "The rule targets to evaluate on each request."
  targets: [url_target_Input]!
}

input route_Input {
  "The timestamp of when the override was last modified."
  modified_on: DateTime
  name: forward_url_const
  value: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value_Input
}

input query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value_Input {
  type: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_actions_items_value_type
  "The URL to redirect the request to.\\nNotes: \${num} refers to the position of '*' in the constraint value."
  url: URL
}

"URL target."
input url_target_Input {
  constraint: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_Input
  target: url_const
}

"The constraint of a target."
input query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_Input {
  operator: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_0_operator! = contains
  value: query_page_rules_list_page_rules_oneOf_0_allOf_1_result_items_targets_items_constraint_allOf_1_value
}

union page_rules_delete_a_page_rule_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_delete_a_page_rule_4xx_response") = api_response_single_id | page_rules_delete_a_page_rule_4xx_response

type page_rules_delete_a_page_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union page_rules_edit_a_page_rule_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_edit_a_page_rule_4xx_response") = pagerule_response_single | page_rules_edit_a_page_rule_4xx_response

type page_rules_edit_a_page_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input page_rules_edit_a_page_rule_request_Input {
  "The set of actions to perform if the targets of this rule match the request. Actions can redirect to another URL or override settings, but not both."
  actions: [route_Input]
  "The priority of the rule, used to define which Page Rule is processed over another. A higher number indicates a higher priority. For example, if you have a catch-all Page Rule (rule A: \`/images/*\`) but want a more specific Page Rule to take precedence (rule B: \`/images/special/*\`), specify a higher priority for rule B so it overrides rule A."
  priority: Int = 1
  status: page_rule_components_schemas_status = disabled
  "The rule targets to evaluate on each request."
  targets: [url_target_Input]
}

union page_rules_update_a_page_rule_response @statusCodeTypeName(statusCode: 200, typeName: "pagerule_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "page_rules_update_a_page_rule_4xx_response") = pagerule_response_single | page_rules_update_a_page_rule_4xx_response

type page_rules_update_a_page_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input page_rules_update_a_page_rule_request_Input {
  "The set of actions to perform if the targets of this rule match the request. Actions can redirect to another URL or override settings, but not both."
  actions: [route_Input]!
  "The priority of the rule, used to define which Page Rule is processed over another. A higher number indicates a higher priority. For example, if you have a catch-all Page Rule (rule A: \`/images/*\`) but want a more specific Page Rule to take precedence (rule B: \`/images/special/*\`), specify a higher priority for rule B so it overrides rule A."
  priority: Int = 1
  status: page_rule_components_schemas_status = disabled
  "The rule targets to evaluate on each request."
  targets: [url_target_Input]!
}

union railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_response @statusCodeTypeName(statusCode: 200, typeName: "railgun_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_4xx_response") = railgun_response_single | railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_4xx_response

type railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input railgun_connections_for_a_zone_connect_or_disconnect_a_railgun_request_Input {
  "A flag indicating whether the given zone is connected to the Railgun."
  connected: Boolean!
}

union rate_limits_for_a_zone_create_a_rate_limit_response @statusCodeTypeName(statusCode: 200, typeName: "ratelimit_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "rate_limits_for_a_zone_create_a_rate_limit_4xx_response") = ratelimit_response_single | rate_limits_for_a_zone_create_a_rate_limit_4xx_response

type rate_limits_for_a_zone_create_a_rate_limit_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input rate_limits_for_a_zone_create_a_rate_limit_request_Input {
  match: JSON!
  threshold: JSON!
  period: JSON!
  action: JSON!
}

union rate_limits_for_a_zone_delete_a_rate_limit_response @statusCodeTypeName(statusCode: 200, typeName: "rate_limits_for_a_zone_delete_a_rate_limit_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "rate_limits_for_a_zone_delete_a_rate_limit_4xx_response") = rate_limits_for_a_zone_delete_a_rate_limit_200_response | rate_limits_for_a_zone_delete_a_rate_limit_4xx_response

type rate_limits_for_a_zone_delete_a_rate_limit_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_rate_limits_for_a_zone_delete_a_rate_limit_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_rate_limits_for_a_zone_delete_a_rate_limit_oneOf_0_allOf_1_result {
  "The unique identifier of the rate limit."
  id: rate_limits_components_schemas_id!
}

type rate_limits_for_a_zone_delete_a_rate_limit_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union rate_limits_for_a_zone_update_a_rate_limit_response @statusCodeTypeName(statusCode: 200, typeName: "ratelimit_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "rate_limits_for_a_zone_update_a_rate_limit_4xx_response") = ratelimit_response_single | rate_limits_for_a_zone_update_a_rate_limit_4xx_response

type rate_limits_for_a_zone_update_a_rate_limit_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input rate_limits_for_a_zone_update_a_rate_limit_request_Input {
  id: JSON!
  match: JSON!
  threshold: JSON!
  period: JSON!
  action: JSON!
}

union zone_settings_edit_zone_settings_info_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_edit_zone_settings_info_4xx_response") = zone_settings_response_collection | zone_settings_edit_zone_settings_info_4xx_response

type zone_settings_edit_zone_settings_info_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input zone_settings_edit_zone_settings_info_request_Input {
  "One or more zone setting objects. Must contain an ID and a value."
  items: [setting_Input]!
}

input setting_Input @oneOf {
  Always_Online_Mode_Input: Always_Online_Mode_Input
  Advanced_DDoS_Protection_Input: Advanced_DDoS_Protection_Input
  Brotli_Compression_Input: Brotli_Compression_Input
  Browser_Cache_TTL_Input: Browser_Cache_TTL_Input
  Browser_Check_Input: Browser_Check_Input
  Cloudflare_CNAME_Flattening_Input: Cloudflare_CNAME_Flattening_Input
  Cloudflare_Cache_Level_Input: Cloudflare_Cache_Level_Input
  Challenge_Page_TTL_Input: Challenge_Page_TTL_Input
  Development_Mode_Input: Development_Mode_Input
  Early_Hints_Input: Early_Hints_Input
  Edge_Cache_TTL_Input: Edge_Cache_TTL_Input
  Error_Pages_On_Input: Error_Pages_On_Input
  Get_String_Sort_Input: Get_String_Sort_Input
  Email_Obfuscation_Input: Email_Obfuscation_Input
  Hotlink_Protection_Input: Hotlink_Protection_Input
  IP_Geolocation_Input: IP_Geolocation_Input
  IPv6_Input: IPv6_Input
  WebSockets_Input: WebSockets_Input
  Toggle_SHA1_support_Input: Toggle_SHA1_support_Input
  TLS1_2_only_Input: TLS1_2_only_Input
  Auto_Minify_Assets_Input: Auto_Minify_Assets_Input
  Max_Upload_Input: Max_Upload_Input
  Mobile_Redirect_Input: Mobile_Redirect_Input
  Mirage_Image_Optimization_Input: Mirage_Image_Optimization_Input
  Network_Error_Logging_Input: Network_Error_Logging_Input
  Polish_Image_Optimization_Input: Polish_Image_Optimization_Input
  Polish_WebP_Conversion_Input: Polish_WebP_Conversion_Input
  Prefetch_preload_Input: Prefetch_preload_Input
  Privacy_Pass_Input: Privacy_Pass_Input
  Response_Buffering_Input: Response_Buffering_Input
  Rocket_Loader_Input: Rocket_Loader_Input
  Security_Header_Input: Security_Header_Input
  Security_Level_Input: Security_Level_Input
  Server_Side_Exclude_Input: Server_Side_Exclude_Input
  SSL_Input: SSL_Input
  SSL_TLS_Recommender_Input: SSL_TLS_Recommender_Input
  TLS_Client_Authentication_Input: TLS_Client_Authentication_Input
  True_Client_IP_Header_Input: True_Client_IP_Header_Input
  Proxy_Read_Timeout_Input: Proxy_Read_Timeout_Input
  Web_Application_Firewall_Input: Web_Application_Firewall_Input
  Zone_Minimum_TLS_Version_value_Input: Zone_Minimum_TLS_Version_value_Input
  Zone_ciphers_allowed_for_TLS_termination_Input: Zone_ciphers_allowed_for_TLS_termination_Input
  Enable_TLS_1_3_value_for_a_zone_Input: Enable_TLS_1_3_value_for_a_zone_Input
  Enable_Opportunistic_Encryption_for_a_zone_Input: Enable_Opportunistic_Encryption_for_a_zone_Input
  Zone_Enable_Automatic_HTTPS_Rewrites_Input: Zone_Enable_Automatic_HTTPS_Rewrites_Input
  HTTP2_Value_Input: HTTP2_Value_Input
  HTTP3_Value_Input: HTTP3_Value_Input
  Origin_Max_HTTP_version_Input: Origin_Max_HTTP_version_Input
  _0_RTT_Value_Input: _0_RTT_Value_Input
  Pseudo_IPv4_Value_Input: Pseudo_IPv4_Value_Input
  Zone_Enable_Always_Use_HTTPS_Input: Zone_Enable_Always_Use_HTTPS_Input
  Zone_Enable_Onion_Routing_Input: Zone_Enable_Onion_Routing_Input
  Orange_to_Orange_Input: Orange_to_Orange_Input
  Image_Resizing_Input: Image_Resizing_Input
  HTTP_2_Edge_Prioritization_Input: HTTP_2_Edge_Prioritization_Input
  Automatic_Platform_Optimization_for_WordPress_Input: Automatic_Platform_Optimization_for_WordPress_Input
}

"When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
input Always_Online_Mode_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: always_online_const
  "last time this setting was modified."
  modified_on: DateTime
  value: always_online_value = on
}

"Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones."
input Advanced_DDoS_Protection_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: advanced_ddos_const
  "last time this setting was modified."
  modified_on: DateTime
  value: advanced_ddos_value = off
}

"When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
input Brotli_Compression_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: brotli_const
  "last time this setting was modified."
  modified_on: DateTime
  value: brotli_value = off
}

"Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
input Browser_Cache_TTL_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: browser_cache_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: browser_cache_ttl_value = _14400
}

"Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
input Browser_Check_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: browser_check_const
  "last time this setting was modified."
  modified_on: DateTime
  value: browser_check_value = on
}

"Whether or not cname flattening is on."
input Cloudflare_CNAME_Flattening_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: cname_flattening_const
  "last time this setting was modified."
  modified_on: DateTime
  value: cname_flattening_value = flatten_at_root
}

"Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
input Cloudflare_Cache_Level_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: cache_level_const
  "last time this setting was modified."
  modified_on: DateTime
  value: cache_level_value = aggressive
}

"Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
input Challenge_Page_TTL_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: challenge_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: challenge_ttl_value = _1800
}

"Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
input Development_Mode_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: development_mode_const
  "last time this setting was modified."
  modified_on: DateTime
  value: development_mode_value = off
  "Value of the zone setting.\\nNotes: The interval (in seconds) from when development mode expires (positive integer) or last expired (negative integer) for the domain. If development mode has never been enabled, this value is false."
  time_remaining: Float
}

"When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
input Early_Hints_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: early_hints_const
  "last time this setting was modified."
  modified_on: DateTime
  value: early_hints_value = off
}

"Time (in seconds) that a resource will be ensured to remain on Cloudflare's cache servers."
input Edge_Cache_TTL_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: edge_cache_ttl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: edge_cache_ttl_value = _7200
}

"Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
input Error_Pages_On_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: origin_error_page_pass_thru_const
  "last time this setting was modified."
  modified_on: DateTime
  value: origin_error_page_pass_thru_value = off
}

"Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
input Get_String_Sort_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: sort_query_string_for_cache_const
  "last time this setting was modified."
  modified_on: DateTime
  value: sort_query_string_for_cache_value = off
}

"Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
input Email_Obfuscation_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: email_obfuscation_const
  "last time this setting was modified."
  modified_on: DateTime
  value: email_obfuscation_value = on
}

"When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
input Hotlink_Protection_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: hotlink_protection_const
  "last time this setting was modified."
  modified_on: DateTime
  value: hotlink_protection_value = off
}

"Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
input IP_Geolocation_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: ip_geolocation_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ip_geolocation_value = on
}

"Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
input IPv6_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: ipv6_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ipv6_value = off
}

"WebSockets are open connections sustained between the client and the origin server. Inside a WebSockets connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSockets connection fast. WebSockets are often used for real-time applications such as live chat and gaming. For more information refer to [Can I use Cloudflare with Websockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-Cloudflare-with-WebSockets-)."
input WebSockets_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: websockets_const
  "last time this setting was modified."
  modified_on: DateTime
  value: websockets_value = off
}

"Allow SHA1 support."
input Toggle_SHA1_support_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: sha1_support_const
  "last time this setting was modified."
  modified_on: DateTime
  value: sha1_support_value = off
}

"Only allows TLS1.2."
input TLS1_2_only_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: tls_1_2_only_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_1_2_only_value = off
}

"Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
input Auto_Minify_Assets_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: minify_const
  "last time this setting was modified."
  modified_on: DateTime
  value: minify_value_Input
}

"Value of the zone setting."
input minify_value_Input {
  css: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_css = off
  html: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_html = off
  js: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_20_allOf_1_value_js = off
}

"Maximum size of an allowable upload."
input Max_Upload_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: max_upload_const
  "last time this setting was modified."
  modified_on: DateTime
  value: max_upload_value = _100
}

"Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
input Mobile_Redirect_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: mobile_redirect_const
  "last time this setting was modified."
  modified_on: DateTime
  value: mobile_redirect_value_Input
}

"Value of the zone setting."
input mobile_redirect_value_Input {
  "Which subdomain prefix you wish to redirect visitors on mobile devices to (subdomain must already exist)."
  mobile_subdomain: NonEmptyString
  status: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_22_allOf_1_value_status = off
  "Whether to drop the current page path and redirect to the mobile subdomain URL root, or keep the path and redirect to the same page on the mobile subdomain."
  strip_uri: Boolean
}

"Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
input Mirage_Image_Optimization_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: mirage_const
  "last time this setting was modified."
  modified_on: DateTime
  value: mirage_value = off
}

"Enable Network Error Logging reporting on your zone. (Beta)"
input Network_Error_Logging_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: nel_const
  "last time this setting was modified."
  modified_on: DateTime
  value: nel_value_Input
}

"Value of the zone setting."
input nel_value_Input {
  enabled: Boolean
}

"Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
input Polish_Image_Optimization_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: polish_const
  "last time this setting was modified."
  modified_on: DateTime
  value: polish_value = off
}

"When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
input Polish_WebP_Conversion_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: webp_const
  "last time this setting was modified."
  modified_on: DateTime
  value: webp_value = off
}

"Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
input Prefetch_preload_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: prefetch_preload_const
  "last time this setting was modified."
  modified_on: DateTime
  value: prefetch_preload_value = off
}

"Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
input Privacy_Pass_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: privacy_pass_const
  "last time this setting was modified."
  modified_on: DateTime
  value: privacy_pass_value = on
}

"Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
input Response_Buffering_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: response_buffering_const
  "last time this setting was modified."
  modified_on: DateTime
  value: response_buffering_value = off
}

"Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
input Rocket_Loader_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: rocket_loader_const
  "last time this setting was modified."
  modified_on: DateTime
  value: rocket_loader_value = off
}

"Cloudflare security header for a zone."
input Security_Header_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: security_header_const
  "last time this setting was modified."
  modified_on: DateTime
  value: security_header_value_Input
}

input security_header_value_Input {
  strict_transport_security: query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_31_allOf_1_value_strict_transport_security_Input
}

"Strict Transport Security."
input query_zone_settings_get_all_zone_settings_oneOf_0_allOf_1_result_items_oneOf_31_allOf_1_value_strict_transport_security_Input {
  "Whether or not strict transport security is enabled."
  enabled: Boolean
  "Include all subdomains for strict transport security."
  include_subdomains: Boolean
  "Max age in seconds of the strict transport security."
  max_age: Float
  "Whether or not to include 'X-Content-Type-Options: nosniff' header."
  nosniff: Boolean
}

"Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
input Security_Level_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: security_level_const
  "last time this setting was modified."
  modified_on: DateTime
  value: security_level_value = medium
}

"If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
input Server_Side_Exclude_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: server_side_exclude_const
  "last time this setting was modified."
  modified_on: DateTime
  value: server_side_exclude_value = on
}

"SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
input SSL_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: ssl_const
  "last time this setting was modified."
  modified_on: DateTime
  value: ssl_value = off
}

"Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
input SSL_TLS_Recommender_Input {
  "ssl-recommender enrollment setting."
  enabled: Boolean
  id: ssl_recommender_const
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  "last time this setting was modified."
  modified_on: DateTime
}

"TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
input TLS_Client_Authentication_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: tls_client_auth_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_client_auth_value = on
}

"Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
input True_Client_IP_Header_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: true_client_ip_header_const
  "last time this setting was modified."
  modified_on: DateTime
  value: true_client_ip_header_value = off
}

"Maximum time between two read operations from origin."
input Proxy_Read_Timeout_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: proxy_read_timeout_const
  "last time this setting was modified."
  modified_on: DateTime
  "Value of the zone setting.\\nNotes: Value must be between 1 and 6000"
  value: Float = 100
}

"The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
input Web_Application_Firewall_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: waf_const
  "last time this setting was modified."
  modified_on: DateTime
  value: waf_value = off
}

"Only accepts HTTPS requests that use at least the TLS protocol version specified. For example, if TLS 1.1 is selected, TLS 1.0 connections will be rejected, while 1.1, 1.2, and 1.3 (if enabled) will be permitted."
input Zone_Minimum_TLS_Version_value_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: min_tls_version_const
  "last time this setting was modified."
  modified_on: DateTime
  value: min_tls_version_value = _1_0
}

"An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
input Zone_ciphers_allowed_for_TLS_termination_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: ciphers_const
  "last time this setting was modified."
  modified_on: DateTime
  "Value of the zone setting."
  value: [String] = []
}

"Enables Crypto TLS 1.3 feature for a zone."
input Enable_TLS_1_3_value_for_a_zone_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: tls_1_3_const
  "last time this setting was modified."
  modified_on: DateTime
  value: tls_1_3_value = off
}

"Enables the Opportunistic Encryption feature for a zone."
input Enable_Opportunistic_Encryption_for_a_zone_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: opportunistic_encryption_const
  "last time this setting was modified."
  modified_on: DateTime
  value: opportunistic_encryption_value = on
}

"Enable the Automatic HTTPS Rewrites feature for this zone."
input Zone_Enable_Automatic_HTTPS_Rewrites_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: automatic_https_rewrites_const
  "last time this setting was modified."
  modified_on: DateTime
  value: automatic_https_rewrites_value = on
}

"HTTP2 enabled for this zone."
input HTTP2_Value_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: http2_const
  "last time this setting was modified."
  modified_on: DateTime
  value: http2_value = off
}

"HTTP3 enabled for this zone."
input HTTP3_Value_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: http3_const
  "last time this setting was modified."
  modified_on: DateTime
  value: http3_value = off
}

"The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.)."
input Origin_Max_HTTP_version_Input {
  id: origin_max_http_version_const!
  "last time this setting was modified."
  modified_on: DateTime
}

"0-RTT session resumption enabled for this zone."
input _0_RTT_Value_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: _0rtt_const
  "last time this setting was modified."
  modified_on: DateTime
  value: _0rtt_value = off
}

"The value set for the Pseudo IPv4 setting."
input Pseudo_IPv4_Value_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: pseudo_ipv4_const
  "last time this setting was modified."
  modified_on: DateTime
  value: pseudo_ipv4_value = off
}

"Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
input Zone_Enable_Always_Use_HTTPS_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: always_use_https_const
  "last time this setting was modified."
  modified_on: DateTime
  value: always_use_https_value = off
}

"Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
input Zone_Enable_Onion_Routing_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: opportunistic_onion_const
  "last time this setting was modified."
  modified_on: DateTime
  value: opportunistic_onion_value = off
}

"Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
input Orange_to_Orange_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: orange_to_orange_const
  "last time this setting was modified."
  modified_on: DateTime
  value: orange_to_orange_value = on
}

"Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
input Image_Resizing_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: image_resizing_const
  "last time this setting was modified."
  modified_on: DateTime
  value: image_resizing_value = off
}

"HTTP/2 Edge Prioritization optimises the delivery of resources served through HTTP/2 to improve page load performance. It also supports fine control of content delivery when used in conjunction with Workers."
input HTTP_2_Edge_Prioritization_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: h2_prioritization_const
  "last time this setting was modified."
  modified_on: DateTime
  value: h2_prioritization_value = off
}

"[Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts."
input Automatic_Platform_Optimization_for_WordPress_Input {
  "Whether or not this setting can be modified for this zone (based on your Cloudflare plan level)."
  editable: Boolean = true
  id: automatic_platform_optimization_const
  "last time this setting was modified."
  modified_on: DateTime
  value: automatic_platform_optimization_Input
}

input automatic_platform_optimization_Input {
  "Indicates whether or not [cache by device type](https://developers.cloudflare.com/automatic-platform-optimization/reference/cache-device-type/) is enabled."
  cache_by_device_type: Boolean!
  "Indicates whether or not Cloudflare proxy is enabled."
  cf: Boolean!
  "Indicates whether or not Automatic Platform Optimization is enabled."
  enabled: Boolean!
  "An array of hostnames where Automatic Platform Optimization for WordPress is activated."
  hostnames: [Hostname]!
  "Indicates whether or not site is powered by WordPress."
  wordpress: Boolean!
  "Indicates whether or not [Cloudflare for WordPress plugin](https://wordpress.org/plugins/cloudflare/) is installed."
  wp_plugin: Boolean!
}

union zone_settings_change_0_rtt_session_resumption_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_0_rtt_session_resumption_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_0_rtt_session_resumption_setting_4xx_response") = zone_settings_change_0_rtt_session_resumption_setting_200_response | zone_settings_change_0_rtt_session_resumption_setting_4xx_response

type zone_settings_change_0_rtt_session_resumption_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "0-RTT session resumption enabled for this zone."
  result: _0_RTT_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_0_rtt_session_resumption_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_0_rtt_session_resumption_setting_request_Input {
  value: _0rtt_value! = off
}

union zone_settings_change_always_online_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_always_online_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_always_online_setting_4xx_response") = zone_settings_change_always_online_setting_200_response | zone_settings_change_always_online_setting_4xx_response

type zone_settings_change_always_online_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information."
  result: Always_Online_Mode
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_always_online_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_always_online_setting_request_Input {
  value: always_online_value! = on
}

union zone_settings_change_always_use_https_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_always_use_https_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_always_use_https_setting_4xx_response") = zone_settings_change_always_use_https_setting_200_response | zone_settings_change_always_use_https_setting_4xx_response

type zone_settings_change_always_use_https_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Reply to all requests for URLs that use \\"http\\" with a 301 redirect to the equivalent \\"https\\" URL. If you only want to redirect for a subset of requests, consider creating an \\"Always use HTTPS\\" page rule."
  result: Zone_Enable_Always_Use_HTTPS
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_always_use_https_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_always_use_https_setting_request_Input {
  value: always_use_https_value! = off
}

union zone_settings_change_automatic_https_rewrites_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_automatic_https_rewrites_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_automatic_https_rewrites_setting_4xx_response") = zone_settings_change_automatic_https_rewrites_setting_200_response | zone_settings_change_automatic_https_rewrites_setting_4xx_response

type zone_settings_change_automatic_https_rewrites_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable the Automatic HTTPS Rewrites feature for this zone."
  result: Zone_Enable_Automatic_HTTPS_Rewrites
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_automatic_https_rewrites_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_automatic_https_rewrites_setting_request_Input {
  value: automatic_https_rewrites_value! = on
}

union zone_settings_change_automatic_platform_optimization_for_word_press_settings_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_automatic_platform_optimization_for_word_press_settings_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_automatic_platform_optimization_for_word_press_settings_4xx_response") = zone_settings_change_automatic_platform_optimization_for_word_press_settings_200_response | zone_settings_change_automatic_platform_optimization_for_word_press_settings_4xx_response

type zone_settings_change_automatic_platform_optimization_for_word_press_settings_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: automatic_platform_optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_automatic_platform_optimization_for_word_press_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_automatic_platform_optimization_for_word_press_settings_request_Input {
  value: automatic_platform_optimization_Input!
}

union zone_settings_change_brotli_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_brotli_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_brotli_setting_4xx_response") = zone_settings_change_brotli_setting_200_response | zone_settings_change_brotli_setting_4xx_response

type zone_settings_change_brotli_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset."
  result: Brotli_Compression
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_brotli_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_brotli_setting_request_Input {
  value: brotli_value! = off
}

union zone_settings_change_browser_cache_ttl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_browser_cache_ttl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_browser_cache_ttl_setting_4xx_response") = zone_settings_change_browser_cache_ttl_setting_200_response | zone_settings_change_browser_cache_ttl_setting_4xx_response

type zone_settings_change_browser_cache_ttl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276)."
  result: Browser_Cache_TTL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_browser_cache_ttl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_browser_cache_ttl_setting_request_Input {
  value: browser_cache_ttl_value! = _14400
}

union zone_settings_change_browser_check_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_browser_check_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_browser_check_setting_4xx_response") = zone_settings_change_browser_check_setting_200_response | zone_settings_change_browser_check_setting_4xx_response

type zone_settings_change_browser_check_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086)."
  result: Browser_Check
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_browser_check_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_browser_check_setting_request_Input {
  value: browser_check_value! = on
}

union zone_settings_change_cache_level_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_cache_level_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_cache_level_setting_4xx_response") = zone_settings_change_cache_level_setting_200_response | zone_settings_change_cache_level_setting_4xx_response

type zone_settings_change_cache_level_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256)."
  result: Cloudflare_Cache_Level
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_cache_level_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_cache_level_setting_request_Input {
  value: cache_level_value! = aggressive
}

union zone_settings_change_challenge_ttl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_challenge_ttl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_challenge_ttl_setting_4xx_response") = zone_settings_change_challenge_ttl_setting_200_response | zone_settings_change_challenge_ttl_setting_4xx_response

type zone_settings_change_challenge_ttl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136)."
  result: Challenge_Page_TTL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_challenge_ttl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_challenge_ttl_setting_request_Input {
  value: challenge_ttl_value! = _1800
}

union zone_settings_change_ciphers_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_ciphers_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_ciphers_setting_4xx_response") = zone_settings_change_ciphers_setting_200_response | zone_settings_change_ciphers_setting_4xx_response

type zone_settings_change_ciphers_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format."
  result: Zone_ciphers_allowed_for_TLS_termination
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_ciphers_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_ciphers_setting_request_Input {
  "Value of the zone setting."
  value: [String]! = []
}

union zone_settings_change_development_mode_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_development_mode_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_development_mode_setting_4xx_response") = zone_settings_change_development_mode_setting_200_response | zone_settings_change_development_mode_setting_4xx_response

type zone_settings_change_development_mode_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off."
  result: Development_Mode
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_development_mode_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_development_mode_setting_request_Input {
  value: development_mode_value! = off
}

union zone_settings_change_early_hints_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_early_hints_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_early_hints_setting_4xx_response") = zone_settings_change_early_hints_setting_200_response | zone_settings_change_early_hints_setting_4xx_response

type zone_settings_change_early_hints_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, Cloudflare will attempt to speed up overall page loads by serving \`103\` responses with \`Link\` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information."
  result: Early_Hints
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_early_hints_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_early_hints_setting_request_Input {
  value: early_hints_value! = off
}

union zone_settings_change_email_obfuscation_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_email_obfuscation_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_email_obfuscation_setting_4xx_response") = zone_settings_change_email_obfuscation_setting_200_response | zone_settings_change_email_obfuscation_setting_4xx_response

type zone_settings_change_email_obfuscation_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016)."
  result: Email_Obfuscation
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_email_obfuscation_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_email_obfuscation_setting_request_Input {
  value: email_obfuscation_value! = on
}

union zone_settings_change_http__2_edge_prioritization_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_http__2_edge_prioritization_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_http__2_edge_prioritization_setting_4xx_response") = zone_settings_change_http__2_edge_prioritization_setting_200_response | zone_settings_change_http__2_edge_prioritization_setting_4xx_response

type zone_settings_change_http__2_edge_prioritization_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP/2 Edge Prioritization optimises the delivery of resources served through HTTP/2 to improve page load performance. It also supports fine control of content delivery when used in conjunction with Workers."
  result: HTTP_2_Edge_Prioritization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_http__2_edge_prioritization_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_http__2_edge_prioritization_setting_request_Input {
  value: h2_prioritization_value! = off
}

union zone_settings_change_hotlink_protection_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_hotlink_protection_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_hotlink_protection_setting_4xx_response") = zone_settings_change_hotlink_protection_setting_200_response | zone_settings_change_hotlink_protection_setting_4xx_response

type zone_settings_change_hotlink_protection_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026)."
  result: Hotlink_Protection
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_hotlink_protection_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_hotlink_protection_setting_request_Input {
  value: hotlink_protection_value! = off
}

union zone_settings_change_h_t_t_p_2_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_h_t_t_p_2_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_h_t_t_p_2_setting_4xx_response") = zone_settings_change_h_t_t_p_2_setting_200_response | zone_settings_change_h_t_t_p_2_setting_4xx_response

type zone_settings_change_h_t_t_p_2_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP2 enabled for this zone."
  result: HTTP2_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_h_t_t_p_2_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_h_t_t_p_2_setting_request_Input {
  value: http2_value! = off
}

union zone_settings_change_h_t_t_p_3_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_h_t_t_p_3_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_h_t_t_p_3_setting_4xx_response") = zone_settings_change_h_t_t_p_3_setting_200_response | zone_settings_change_h_t_t_p_3_setting_4xx_response

type zone_settings_change_h_t_t_p_3_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "HTTP3 enabled for this zone."
  result: HTTP3_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_h_t_t_p_3_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_h_t_t_p_3_setting_request_Input {
  value: http3_value! = off
}

union zone_settings_change_image_resizing_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_image_resizing_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_image_resizing_setting_4xx_response") = zone_settings_change_image_resizing_setting_200_response | zone_settings_change_image_resizing_setting_4xx_response

type zone_settings_change_image_resizing_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information."
  result: Image_Resizing
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_image_resizing_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_image_resizing_setting_request_Input {
  value: image_resizing_value! = off
}

union zone_settings_change_ip_geolocation_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_ip_geolocation_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_ip_geolocation_setting_4xx_response") = zone_settings_change_ip_geolocation_setting_200_response | zone_settings_change_ip_geolocation_setting_4xx_response

type zone_settings_change_ip_geolocation_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236)."
  result: IP_Geolocation
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_ip_geolocation_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_ip_geolocation_setting_request_Input {
  value: ip_geolocation_value! = on
}

union zone_settings_change_i_pv6_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_i_pv6_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_i_pv6_setting_4xx_response") = zone_settings_change_i_pv6_setting_200_response | zone_settings_change_i_pv6_setting_4xx_response

type zone_settings_change_i_pv6_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586)."
  result: IPv62
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_i_pv6_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_i_pv6_setting_request_Input {
  value: ipv6_value! = off
}

union zone_settings_change_minimum_tls_version_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_minimum_tls_version_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_minimum_tls_version_setting_4xx_response") = zone_settings_change_minimum_tls_version_setting_200_response | zone_settings_change_minimum_tls_version_setting_4xx_response

type zone_settings_change_minimum_tls_version_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Only accepts HTTPS requests that use at least the TLS protocol version specified. For example, if TLS 1.1 is selected, TLS 1.0 connections will be rejected, while 1.1, 1.2, and 1.3 (if enabled) will be permitted."
  result: Zone_Minimum_TLS_Version_value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_minimum_tls_version_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_minimum_tls_version_setting_request_Input {
  value: min_tls_version_value! = _1_0
}

union zone_settings_change_minify_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_minify_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_minify_setting_4xx_response") = zone_settings_change_minify_setting_200_response | zone_settings_change_minify_setting_4xx_response

type zone_settings_change_minify_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information."
  result: Auto_Minify_Assets
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_minify_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_minify_setting_request_Input {
  value: minify_value_Input!
}

union zone_settings_change_mirage_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_mirage_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_mirage_setting_4xx_response") = zone_settings_change_mirage_setting_200_response | zone_settings_change_mirage_setting_4xx_response

type zone_settings_change_mirage_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically optimize image loading for website visitors on mobile devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information."
  result: Mirage_Image_Optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_mirage_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_mirage_setting_request_Input {
  value: mirage_value! = off
}

union zone_settings_change_mobile_redirect_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_mobile_redirect_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_mobile_redirect_setting_4xx_response") = zone_settings_change_mobile_redirect_setting_200_response | zone_settings_change_mobile_redirect_setting_4xx_response

type zone_settings_change_mobile_redirect_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information."
  result: Mobile_Redirect
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_mobile_redirect_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_mobile_redirect_setting_request_Input {
  value: mobile_redirect_value_Input!
}

union zone_settings_change_network_error_logging_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_network_error_logging_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_network_error_logging_setting_4xx_response") = zone_settings_change_network_error_logging_setting_200_response | zone_settings_change_network_error_logging_setting_4xx_response

type zone_settings_change_network_error_logging_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enable Network Error Logging reporting on your zone. (Beta)"
  result: Network_Error_Logging
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_network_error_logging_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_network_error_logging_setting_request_Input {
  value: nel_value_Input!
}

union zone_settings_change_opportunistic_encryption_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_opportunistic_encryption_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_opportunistic_encryption_setting_4xx_response") = zone_settings_change_opportunistic_encryption_setting_200_response | zone_settings_change_opportunistic_encryption_setting_4xx_response

type zone_settings_change_opportunistic_encryption_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables the Opportunistic Encryption feature for a zone."
  result: Enable_Opportunistic_Encryption_for_a_zone
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_opportunistic_encryption_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_opportunistic_encryption_setting_request_Input {
  value: opportunistic_encryption_value! = on
}

union zone_settings_change_opportunistic_onion_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_opportunistic_onion_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_opportunistic_onion_setting_4xx_response") = zone_settings_change_opportunistic_onion_setting_200_response | zone_settings_change_opportunistic_onion_setting_4xx_response

type zone_settings_change_opportunistic_onion_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes."
  result: Zone_Enable_Onion_Routing
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_opportunistic_onion_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_opportunistic_onion_setting_request_Input {
  value: opportunistic_onion_value! = off
}

union zone_settings_change_orange_to_orange__o_2_o_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_orange_to_orange__o_2_o_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_orange_to_orange__o_2_o_4xx_response") = zone_settings_change_orange_to_orange__o_2_o_200_response | zone_settings_change_orange_to_orange__o_2_o_4xx_response

type zone_settings_change_orange_to_orange__o_2_o_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare."
  result: Orange_to_Orange
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_orange_to_orange__o_2_o_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_orange_to_orange__o_2_o_request_Input {
  value: orange_to_orange_value! = on
}

union zone_settings_change_enable_error_pages_on_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_enable_error_pages_on_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_enable_error_pages_on_setting_4xx_response") = zone_settings_change_enable_error_pages_on_setting_200_response | zone_settings_change_enable_error_pages_on_setting_4xx_response

type zone_settings_change_enable_error_pages_on_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones."
  result: Error_Pages_On
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_enable_error_pages_on_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_enable_error_pages_on_setting_request_Input {
  value: origin_error_page_pass_thru_value! = off
}

union zone_settings_change_origin_max_http_version_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_origin_max_http_version_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_origin_max_http_version_setting_4xx_response") = zone_settings_change_origin_max_http_version_setting_200_response | zone_settings_change_origin_max_http_version_setting_4xx_response

type zone_settings_change_origin_max_http_version_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: query_zone_settings_get_origin_max_http_version_setting_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_origin_max_http_version_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_origin_max_http_version_setting_request_Input {
  value: origin_max_http_version_value! = _2
}

union zone_settings_change_polish_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_polish_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_polish_setting_4xx_response") = zone_settings_change_polish_setting_200_response | zone_settings_change_polish_setting_4xx_response

type zone_settings_change_polish_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites."
  result: Polish_Image_Optimization
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_polish_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_polish_setting_request_Input {
  value: polish_value! = off
}

union zone_settings_change_prefetch_preload_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_prefetch_preload_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_prefetch_preload_setting_4xx_response") = zone_settings_change_prefetch_preload_setting_200_response | zone_settings_change_prefetch_preload_setting_4xx_response

type zone_settings_change_prefetch_preload_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones."
  result: Prefetch_preload
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_prefetch_preload_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_prefetch_preload_setting_request_Input {
  value: prefetch_preload_value! = off
}

union zone_settings_change_privacy_pass_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_privacy_pass_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_privacy_pass_setting_4xx_response") = zone_settings_change_privacy_pass_setting_200_response | zone_settings_change_privacy_pass_setting_4xx_response

type zone_settings_change_privacy_pass_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass)."
  result: Privacy_Pass
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_privacy_pass_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_privacy_pass_setting_request_Input {
  value: privacy_pass_value! = on
}

union zone_settings_change_proxy_read_timeout_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_proxy_read_timeout_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_proxy_read_timeout_setting_4xx_response") = zone_settings_change_proxy_read_timeout_setting_200_response | zone_settings_change_proxy_read_timeout_setting_4xx_response

type zone_settings_change_proxy_read_timeout_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Maximum time between two read operations from origin."
  result: Proxy_Read_Timeout
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_proxy_read_timeout_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_proxy_read_timeout_setting_request_Input {
  "Value of the zone setting.\\nNotes: Value must be between 1 and 6000"
  value: Float! = 100
}

union zone_settings_change_pseudo_i_pv4_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_pseudo_i_pv4_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_pseudo_i_pv4_setting_4xx_response") = zone_settings_change_pseudo_i_pv4_setting_200_response | zone_settings_change_pseudo_i_pv4_setting_4xx_response

type zone_settings_change_pseudo_i_pv4_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The value set for the Pseudo IPv4 setting."
  result: Pseudo_IPv4_Value
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_pseudo_i_pv4_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_pseudo_i_pv4_setting_request_Input {
  value: pseudo_ipv4_value! = off
}

union zone_settings_change_response_buffering_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_response_buffering_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_response_buffering_setting_4xx_response") = zone_settings_change_response_buffering_setting_200_response | zone_settings_change_response_buffering_setting_4xx_response

type zone_settings_change_response_buffering_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones."
  result: Response_Buffering
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_response_buffering_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_response_buffering_setting_request_Input {
  value: response_buffering_value! = off
}

union zone_settings_change_rocket_loader_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_rocket_loader_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_rocket_loader_setting_4xx_response") = zone_settings_change_rocket_loader_setting_200_response | zone_settings_change_rocket_loader_setting_4xx_response

type zone_settings_change_rocket_loader_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the \`window.onload\` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information."
  result: Rocket_Loader
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_rocket_loader_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_rocket_loader_setting_request_Input {
  value: rocket_loader_value! = off
}

union zone_settings_change_security_header__hsts_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_security_header__hsts_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_security_header__hsts_setting_4xx_response") = zone_settings_change_security_header__hsts_setting_200_response | zone_settings_change_security_header__hsts_setting_4xx_response

type zone_settings_change_security_header__hsts_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare security header for a zone."
  result: Security_Header
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_security_header__hsts_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_security_header__hsts_setting_request_Input {
  value: security_header_value_Input!
}

union zone_settings_change_security_level_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_security_level_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_security_level_setting_4xx_response") = zone_settings_change_security_level_setting_200_response | zone_settings_change_security_level_setting_4xx_response

type zone_settings_change_security_level_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056)."
  result: Security_Level
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_security_level_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_security_level_setting_request_Input {
  value: security_level_value! = medium
}

union zone_settings_change_server_side_exclude_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_server_side_exclude_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_server_side_exclude_setting_4xx_response") = zone_settings_change_server_side_exclude_setting_200_response | zone_settings_change_server_side_exclude_setting_4xx_response

type zone_settings_change_server_side_exclude_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036)."
  result: Server_Side_Exclude
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_server_side_exclude_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_server_side_exclude_setting_request_Input {
  value: server_side_exclude_value! = on
}

union zone_settings_change_enable_query_string_sort_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_enable_query_string_sort_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_enable_query_string_sort_setting_4xx_response") = zone_settings_change_enable_query_string_sort_setting_200_response | zone_settings_change_enable_query_string_sort_setting_4xx_response

type zone_settings_change_enable_query_string_sort_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones."
  result: Get_String_Sort
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_enable_query_string_sort_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_enable_query_string_sort_setting_request_Input {
  value: sort_query_string_for_cache_value! = off
}

union zone_settings_change_ssl_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_ssl_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_ssl_setting_4xx_response") = zone_settings_change_ssl_setting_200_response | zone_settings_change_ssl_setting_4xx_response

type zone_settings_change_ssl_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416)."
  result: SSL
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_ssl_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_ssl_setting_request_Input {
  value: ssl_value! = off
}

union zone_settings_change_ssl__tls_recommender_enrollment_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_ssl__tls_recommender_enrollment_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_ssl__tls_recommender_enrollment_4xx_response") = zone_settings_change_ssl__tls_recommender_enrollment_200_response | zone_settings_change_ssl__tls_recommender_enrollment_4xx_response

type zone_settings_change_ssl__tls_recommender_enrollment_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support."
  result: SSL_TLS_Recommender
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_ssl__tls_recommender_enrollment_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_ssl__tls_recommender_enrollment_request_Input {
  "ssl-recommender enrollment setting."
  enabled: Boolean!
}

union zone_settings_change_tls_1__3_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_tls_1__3_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_tls_1__3_setting_4xx_response") = zone_settings_change_tls_1__3_setting_200_response | zone_settings_change_tls_1__3_setting_4xx_response

type zone_settings_change_tls_1__3_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Enables Crypto TLS 1.3 feature for a zone."
  result: Enable_TLS_1_3_value_for_a_zone
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_tls_1__3_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_tls_1__3_setting_request_Input {
  value: tls_1_3_value! = off
}

union zone_settings_change_tls_client_auth_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_tls_client_auth_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_tls_client_auth_setting_4xx_response") = zone_settings_change_tls_client_auth_setting_200_response | zone_settings_change_tls_client_auth_setting_4xx_response

type zone_settings_change_tls_client_auth_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only)."
  result: TLS_Client_Authentication
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_tls_client_auth_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_tls_client_auth_setting_request_Input {
  value: tls_client_auth_value! = on
}

union zone_settings_change_true_client_ip_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_true_client_ip_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_true_client_ip_setting_4xx_response") = zone_settings_change_true_client_ip_setting_200_response | zone_settings_change_true_client_ip_setting_4xx_response

type zone_settings_change_true_client_ip_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones."
  result: True_Client_IP_Header
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_true_client_ip_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_true_client_ip_setting_request_Input {
  value: true_client_ip_header_value! = off
}

union zone_settings_change_web_application_firewall__waf_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_web_application_firewall__waf_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_web_application_firewall__waf_setting_4xx_response") = zone_settings_change_web_application_firewall__waf_setting_200_response | zone_settings_change_web_application_firewall__waf_setting_4xx_response

type zone_settings_change_web_application_firewall__waf_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016)."
  result: Web_Application_Firewall
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_web_application_firewall__waf_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_web_application_firewall__waf_setting_request_Input {
  value: waf_value! = off
}

union zone_settings_change_web_p_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_web_p_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_web_p_setting_4xx_response") = zone_settings_change_web_p_setting_200_response | zone_settings_change_web_p_setting_4xx_response

type zone_settings_change_web_p_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image."
  result: Polish_WebP_Conversion
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_web_p_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_web_p_setting_request_Input {
  value: webp_value! = off
}

union zone_settings_change_web_sockets_setting_response @statusCodeTypeName(statusCode: 200, typeName: "zone_settings_change_web_sockets_setting_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_settings_change_web_sockets_setting_4xx_response") = zone_settings_change_web_sockets_setting_200_response | zone_settings_change_web_sockets_setting_4xx_response

type zone_settings_change_web_sockets_setting_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  "WebSockets are open connections sustained between the client and the origin server. Inside a WebSockets connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSockets connection fast. WebSockets are often used for real-time applications such as live chat and gaming. For more information refer to [Can I use Cloudflare with Websockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-Cloudflare-with-WebSockets-)."
  result: WebSockets
  "Whether the API call was successful"
  success: Boolean!
}

type zone_settings_change_web_sockets_setting_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input zone_settings_change_web_sockets_setting_request_Input {
  value: websockets_value! = off
}

union certificate_packs_order_certificate_pack_response @statusCodeTypeName(statusCode: 200, typeName: "certificate_pack_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_order_certificate_pack_4xx_response") = certificate_pack_response_single | certificate_packs_order_certificate_pack_4xx_response

type certificate_packs_order_certificate_pack_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input certificate_packs_order_certificate_pack_request_Input {
  "Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty."
  hosts: [String]
}

union certificate_packs_order_advanced_certificate_manager_certificate_pack_response @statusCodeTypeName(statusCode: 200, typeName: "advanced_certificate_pack_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_order_advanced_certificate_manager_certificate_pack_4xx_response") = advanced_certificate_pack_response_single | certificate_packs_order_advanced_certificate_manager_certificate_pack_4xx_response

type advanced_certificate_pack_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_certificate_packs_order_advanced_certificate_manager_certificate_pack_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_certificate_packs_order_advanced_certificate_manager_certificate_pack_oneOf_0_allOf_1_result {
  certificate_authority: certificate_authority
  "Whether or not to add Cloudflare Branding for the order.  This will add sni.cloudflaressl.com as the Common Name if set true."
  cloudflare_branding: Boolean
  "Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty."
  hosts: [String]
  "The unique identifier for a certificate_pack."
  id: String!
  status: certificate_packs_components_schemas_status
  type: advanced_type
  validation_method: validation_method
  validity_days: validity_days
}

"Certificate Authority selected for the order.  Selecting Let's Encrypt will reduce customization of other fields: validation_method must be 'txt', validity_days must be 90, cloudflare_branding must be omitted, and hosts must contain only 2 entries, one for the zone name and one for the subdomain wildcard of the zone name (e.g. example.com, *.example.com)."
enum certificate_authority {
  digicert
  google
  lets_encrypt
}

"Status of certificate pack."
enum certificate_packs_components_schemas_status {
  initializing
  pending_validation
  deleted
  pending_issuance
  pending_deployment
  pending_deletion
  pending_expiration
  expired
  active
  initializing_timed_out
  validation_timed_out
  issuance_timed_out
  deployment_timed_out
  deletion_timed_out
  pending_cleanup
  staging_deployment
  staging_active
  deactivating
  inactive
  backup_issued
  holding_deployment
}

enum advanced_type @typescript(type: "\\"advanced\\"") @example(value: "\\"advanced\\"") {
  advanced @enum(value: "\\"advanced\\"")
}

"Validation Method selected for the order."
enum validation_method {
  txt
  http
  email
}

"Validity Days selected for the order."
enum validity_days {
  _14 @enum(value: "14")
  _30 @enum(value: "30")
  _90 @enum(value: "90")
  _365 @enum(value: "365")
}

type certificate_packs_order_advanced_certificate_manager_certificate_pack_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input certificate_packs_order_advanced_certificate_manager_certificate_pack_request_Input {
  certificate_authority: certificate_authority!
  "Whether or not to add Cloudflare Branding for the order.  This will add sni.cloudflaressl.com as the Common Name if set true."
  cloudflare_branding: Boolean
  "Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty."
  hosts: [String]!
  type: advanced_type!
  validation_method: validation_method!
  validity_days: validity_days!
}

union certificate_packs_delete_advanced_certificate_manager_certificate_pack_response @statusCodeTypeName(statusCode: 200, typeName: "delete_advanced_certificate_pack_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_delete_advanced_certificate_manager_certificate_pack_4xx_response") = delete_advanced_certificate_pack_response_single | certificate_packs_delete_advanced_certificate_manager_certificate_pack_4xx_response

type delete_advanced_certificate_pack_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_certificate_packs_delete_advanced_certificate_manager_certificate_pack_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_certificate_packs_delete_advanced_certificate_manager_certificate_pack_oneOf_0_allOf_1_result {
  "The unique identifier for a certificate_pack."
  id: String!
}

type certificate_packs_delete_advanced_certificate_manager_certificate_pack_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack_response @statusCodeTypeName(statusCode: 200, typeName: "advanced_certificate_pack_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack_4xx_response") = advanced_certificate_pack_response_single | certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack_4xx_response

type certificate_packs_restart_validation_for_advanced_certificate_manager_certificate_pack_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union universal_ssl_settings_for_a_zone_edit_universal_ssl_settings_response @statusCodeTypeName(statusCode: 200, typeName: "ssl_universal_settings_response") @statusCodeTypeName(statusCode: "4xx", typeName: "universal_ssl_settings_for_a_zone_edit_universal_ssl_settings_4xx_response") = ssl_universal_settings_response | universal_ssl_settings_for_a_zone_edit_universal_ssl_settings_4xx_response

type universal_ssl_settings_for_a_zone_edit_universal_ssl_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input universal_Input {
  "Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no dedicated certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.\\n\\nBy disabling Universal SSL, you understand that the following Cloudflare settings and preferences will result in visitors being unable to visit your domain unless you have uploaded a custom certificate or purchased a dedicated certificate.\\n\\n* HSTS\\n* Always Use HTTPS\\n* Opportunistic Encryption\\n* Onion Routing\\n* Any Page Rules redirecting traffic to HTTPS\\n\\nSimilarly, any HTTP redirect to HTTPS at the origin while the Cloudflare proxy is enabled will result in users being unable to visit your site without a valid certificate at Cloudflare's edge.\\n\\nIf you do not have a valid custom or dedicated certificate at Cloudflare's edge and are unsure if any of the above Cloudflare settings are enabled, or if any HTTP redirects exist at your origin, we advise leaving Universal SSL enabled for your domain."
  enabled: Boolean
}

union ssl_verification_edit_ssl_certificate_pack_validation_method_response @statusCodeTypeName(statusCode: 200, typeName: "ssl_validation_method_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "ssl_verification_edit_ssl_certificate_pack_validation_method_4xx_response") = ssl_validation_method_response_collection | ssl_verification_edit_ssl_certificate_pack_validation_method_4xx_response

type ssl_validation_method_response_collection {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_ssl_verification_edit_ssl_certificate_pack_validation_method_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_ssl_verification_edit_ssl_certificate_pack_validation_method_oneOf_0_allOf_1_result {
  "Result status."
  status: String
  validation_method: validation_method_definition
}

"Desired validation method."
enum validation_method_definition {
  http
  cname
  txt
  email
}

type ssl_verification_edit_ssl_certificate_pack_validation_method_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input components_schemas_validation_method_Input {
  validation_method: validation_method_definition!
}

union waiting_room_create_waiting_room_response @statusCodeTypeName(statusCode: 200, typeName: "waitingroom_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_create_waiting_room_4xx_response") = waitingroom_components_schemas_single_response | waiting_room_create_waiting_room_4xx_response

type waiting_room_create_waiting_room_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input query_waitingroom_Input {
  cookie_attributes: cookie_attributes_Input
  "Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:\\n1. {{\`waitTimeKnown\`}} Acts like a boolean value that indicates the behavior to take when wait time is not available, for instance when queue_all is **true**. \\n2. {{\`waitTimeFormatted\`}} Estimated wait time for the user. For example, five minutes. Alternatively, you can use: \\n3. {{\`waitTime\`}} Number of minutes of estimated wait for a user.\\n4. {{\`waitTimeHours\`}} Number of hours of estimated wait for a user (\`Math.floor(waitTime/60)\`). \\n5. {{\`waitTimeHourMinutes\`}} Number of minutes above the \`waitTimeHours\` value (\`waitTime%60\`). \\n6. {{\`queueIsFull\`}} Changes to **true** when no more people can be added to the queue.\\n\\nTo view the full list of variables, look at the \`cfWaitingRoom\` object described under the \`json_response_enabled\` property in other Waiting Room API calls."
  custom_page_html: String
  default_template_language: default_template_language = en_US
  "A note that you can use to add more details about the waiting room."
  description: String
  "Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If \`true\`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If \`false\`, a user's session cookie will be automatically renewed on every request."
  disable_session_renewal: Boolean
  "The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique."
  host: String!
  "Only available for the Waiting Room Advanced subscription. If \`true\`, requests to the waiting room with the header \`Accept: application/json\` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property \`cfWaitingRoom\` which is an object containing the following fields:\\n1. \`inWaitingRoom\`: Boolean indicating if the user is in the waiting room (always **true**).\\n2. \`waitTimeKnown\`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.\\n3. \`waitTime\`: Valid only when \`waitTimeKnown\` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When \`queueingMethod\` is **random**, this is set to \`waitTime50Percentile\`.\\n4. \`waitTime25Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).\\n5. \`waitTime50Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before \`waitTime50Percentile\` and half are expected to be let in after it.\\n6. \`waitTime75Percentile\`: Valid only when \`queueingMethod\` is **random** and \`waitTimeKnown\` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).\\n7. \`waitTimeFormatted\`: String displaying the \`waitTime\` formatted in English for users. If \`waitTimeKnown\` is **false**, \`waitTimeFormatted\` will display **unavailable**.\\n8. \`queueIsFull\`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.\\n9. \`queueAll\`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.\\n10. \`lastUpdated\`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after \`refreshIntervalSeconds\` past this time. If the user makes a request too soon, it will be ignored and \`lastUpdated\` will not change.\\n11. \`refreshIntervalSeconds\`: Integer indicating the number of seconds after \`lastUpdated\` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the \`queueingMethod\` is \`reject\`, there is no specified refresh time — it will always be **zero**.\\n12. \`queueingMethod\`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.\\n13. \`isFIFOQueue\`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.\\n14. \`isRandomQueue\`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.\\n15. \`isPassthroughQueue\`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when \`queueAll\` is **true** or \`isEventPrequeueing\` is **true** because in all other cases requests will go directly to the origin.\\n16. \`isRejectQueue\`: Boolean indicating if the waiting room uses a reject queue.\\n17. \`isEventActive\`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties \`prequeue_start_time\`, \`event_start_time\`, and \`event_end_time\` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.\\n18. \`isEventPrequeueing\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.\\n19. \`timeUntilEventStart\`: Valid only when \`isEventPrequeueing\` is **true**. Integer indicating the number of minutes until the event starts.\\n20. \`timeUntilEventStartFormatted\`: String displaying the \`timeUntilEventStart\` formatted in English for users. If \`isEventPrequeueing\` is **false**, \`timeUntilEventStartFormatted\` will display **unavailable**.\\n21. \`timeUntilEventEnd\`: Valid only when \`isEventActive\` is **true**. Integer indicating the number of minutes until the event ends.\\n22. \`timeUntilEventEndFormatted\`: String displaying the \`timeUntilEventEnd\` formatted in English for users. If \`isEventActive\` is **false**, \`timeUntilEventEndFormatted\` will display **unavailable**.\\n23. \`shuffleAtEventStart\`: Valid only when \`isEventActive\` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.\\n\\nAn example cURL to a waiting room could be:\\n\\n\\tcurl -X GET \\"https://example.com/waitingroom\\" \\\\\\n\\t\\t-H \\"Accept: application/json\\"\\n\\nIf \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **fifo** and no event is active could be:\\n\\n\\t{\\n\\t\\t\\"cfWaitingRoom\\": {\\n\\t\\t\\t\\"inWaitingRoom\\": true,\\n\\t\\t\\t\\"waitTimeKnown\\": true,\\n\\t\\t\\t\\"waitTime\\": 10,\\n\\t\\t\\t\\"waitTime25Percentile\\": 0,\\n\\t\\t\\t\\"waitTime50Percentile\\": 0,\\n\\t\\t\\t\\"waitTime75Percentile\\": 0,\\n\\t\\t\\t\\"waitTimeFormatted\\": \\"10 minutes\\",\\n\\t\\t\\t\\"queueIsFull\\": false,\\n\\t\\t\\t\\"queueAll\\": false,\\n\\t\\t\\t\\"lastUpdated\\": \\"2020-08-03T23:46:00.000Z\\",\\n\\t\\t\\t\\"refreshIntervalSeconds\\": 20,\\n\\t\\t\\t\\"queueingMethod\\": \\"fifo\\",\\n\\t\\t\\t\\"isFIFOQueue\\": true,\\n\\t\\t\\t\\"isRandomQueue\\": false,\\n\\t\\t\\t\\"isPassthroughQueue\\": false,\\n\\t\\t\\t\\"isRejectQueue\\": false,\\n\\t\\t\\t\\"isEventActive\\": false,\\n\\t\\t\\t\\"isEventPrequeueing\\": false,\\n\\t\\t\\t\\"timeUntilEventStart\\": 0,\\n\\t\\t\\t\\"timeUntilEventStartFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"timeUntilEventEnd\\": 0,\\n\\t\\t\\t\\"timeUntilEventEndFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"shuffleAtEventStart\\": false\\n\\t\\t}\\n\\t}\\n\\nIf \`json_response_enabled\` is **true** and the request hits the waiting room, an example JSON response when \`queueingMethod\` is **random** and an event is active could be:\\n\\n\\t{\\n\\t\\t\\"cfWaitingRoom\\": {\\n\\t\\t\\t\\"inWaitingRoom\\": true,\\n\\t\\t\\t\\"waitTimeKnown\\": true,\\n\\t\\t\\t\\"waitTime\\": 10,\\n\\t\\t\\t\\"waitTime25Percentile\\": 5,\\n\\t\\t\\t\\"waitTime50Percentile\\": 10,\\n\\t\\t\\t\\"waitTime75Percentile\\": 15,\\n\\t\\t\\t\\"waitTimeFormatted\\": \\"5 minutes to 15 minutes\\",\\n\\t\\t\\t\\"queueIsFull\\": false,\\n\\t\\t\\t\\"queueAll\\": false,\\n\\t\\t\\t\\"lastUpdated\\": \\"2020-08-03T23:46:00.000Z\\",\\n\\t\\t\\t\\"refreshIntervalSeconds\\": 20,\\n\\t\\t\\t\\"queueingMethod\\": \\"random\\",\\n\\t\\t\\t\\"isFIFOQueue\\": false,\\n\\t\\t\\t\\"isRandomQueue\\": true,\\n\\t\\t\\t\\"isPassthroughQueue\\": false,\\n\\t\\t\\t\\"isRejectQueue\\": false,\\n\\t\\t\\t\\"isEventActive\\": true,\\n\\t\\t\\t\\"isEventPrequeueing\\": false,\\n\\t\\t\\t\\"timeUntilEventStart\\": 0,\\n\\t\\t\\t\\"timeUntilEventStartFormatted\\": \\"unavailable\\",\\n\\t\\t\\t\\"timeUntilEventEnd\\": 15,\\n\\t\\t\\t\\"timeUntilEventEndFormatted\\": \\"15 minutes\\",\\n\\t\\t\\t\\"shuffleAtEventStart\\": true\\n\\t\\t}\\n\\t}."
  json_response_enabled: Boolean
  "A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String!
  "Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world."
  new_users_per_minute: PositiveInt!
  "Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported."
  path: String = "/"
  "If queue_all is \`true\`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable."
  queue_all: Boolean
  queueing_method: queueing_method = fifo
  "Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route."
  session_duration: PositiveInt = 5
  "Suspends or allows traffic going to the waiting room. If set to \`true\`, the traffic will not go to the waiting room."
  suspended: Boolean
  "Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world."
  total_active_users: PositiveInt!
}

"Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position."
input cookie_attributes_Input {
  samesite: query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_samesite = auto
  secure: query_waiting_room_list_waiting_rooms_oneOf_0_allOf_1_result_items_cookie_attributes_secure = auto
}

union waiting_room_create_a_custom_waiting_room_page_preview_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_preview_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_create_a_custom_waiting_room_page_preview_4xx_response") = schemas_preview_response | waiting_room_create_a_custom_waiting_room_page_preview_4xx_response

type schemas_preview_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_waiting_room_create_a_custom_waiting_room_page_preview_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_waiting_room_create_a_custom_waiting_room_page_preview_oneOf_0_allOf_1_result {
  "URL where the custom waiting room page can temporarily be previewed."
  preview_url: URL
}

type waiting_room_create_a_custom_waiting_room_page_preview_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input query_preview_Input {
  "Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:\\n1. {{\`waitTimeKnown\`}} Acts like a boolean value that indicates the behavior to take when wait time is not available, for instance when queue_all is **true**. \\n2. {{\`waitTimeFormatted\`}} Estimated wait time for the user. For example, five minutes. Alternatively, you can use: \\n3. {{\`waitTime\`}} Number of minutes of estimated wait for a user.\\n4. {{\`waitTimeHours\`}} Number of hours of estimated wait for a user (\`Math.floor(waitTime/60)\`). \\n5. {{\`waitTimeHourMinutes\`}} Number of minutes above the \`waitTimeHours\` value (\`waitTime%60\`). \\n6. {{\`queueIsFull\`}} Changes to **true** when no more people can be added to the queue.\\n\\nTo view the full list of variables, look at the \`cfWaitingRoom\` object described under the \`json_response_enabled\` property in other Waiting Room API calls."
  custom_html: String!
}

union waiting_room_delete_waiting_room_response @statusCodeTypeName(statusCode: 200, typeName: "waiting_room_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_delete_waiting_room_4xx_response") = waiting_room_id_response | waiting_room_delete_waiting_room_4xx_response

type waiting_room_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_waiting_room_delete_waiting_room_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_waiting_room_delete_waiting_room_oneOf_0_allOf_1_result {
  id: String!
}

type waiting_room_delete_waiting_room_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_patch_waiting_room_response @statusCodeTypeName(statusCode: 200, typeName: "waitingroom_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_patch_waiting_room_4xx_response") = waitingroom_components_schemas_single_response | waiting_room_patch_waiting_room_4xx_response

type waiting_room_patch_waiting_room_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_update_waiting_room_response @statusCodeTypeName(statusCode: 200, typeName: "waitingroom_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_update_waiting_room_4xx_response") = waitingroom_components_schemas_single_response | waiting_room_update_waiting_room_4xx_response

type waiting_room_update_waiting_room_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_create_event_response @statusCodeTypeName(statusCode: 200, typeName: "event_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_create_event_4xx_response") = event_response | waiting_room_create_event_4xx_response

type waiting_room_create_event_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input query_event_Input {
  "If set, the event will override the waiting room's \`custom_page_html\` property while it is active. If null, the event will inherit it."
  custom_page_html: String
  "A note that you can use to add more details about the event."
  description: String
  "If set, the event will override the waiting room's \`disable_session_renewal\` property while it is active. If null, the event will inherit it."
  disable_session_renewal: Boolean
  "An ISO 8601 timestamp that marks the end of the event."
  event_end_time: DateTime!
  "An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before \`event_end_time\`."
  event_start_time: DateTime!
  "A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed."
  name: String!
  "If set, the event will override the waiting room's \`new_users_per_minute\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`total_active_users\` property is also set."
  new_users_per_minute: PositiveInt
  "An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before \`event_start_time\`."
  prequeue_start_time: DateTime
  "If set, the event will override the waiting room's \`queueing_method\` property while it is active. If null, the event will inherit it."
  queueing_method: String
  "If set, the event will override the waiting room's \`session_duration\` property while it is active. If null, the event will inherit it."
  session_duration: PositiveInt
  "If enabled, users in the prequeue will be shuffled randomly at the \`event_start_time\`. Requires that \`prequeue_start_time\` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the \`queueing_method\` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary."
  shuffle_at_event_start: Boolean
  "Suspends or allows an event. If set to \`true\`, the event is ignored and traffic will be handled based on the waiting room configuration."
  suspended: Boolean
  "If set, the event will override the waiting room's \`total_active_users\` property while it is active. If null, the event will inherit it. This can only be set if the event's \`new_users_per_minute\` property is also set."
  total_active_users: PositiveInt
}

union waiting_room_delete_event_response @statusCodeTypeName(statusCode: 200, typeName: "event_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_delete_event_4xx_response") = event_id_response | waiting_room_delete_event_4xx_response

type event_id_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_waiting_room_delete_event_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_waiting_room_delete_event_oneOf_0_allOf_1_result {
  id: String!
}

type waiting_room_delete_event_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_patch_event_response @statusCodeTypeName(statusCode: 200, typeName: "event_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_patch_event_4xx_response") = event_response | waiting_room_patch_event_4xx_response

type waiting_room_patch_event_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_update_event_response @statusCodeTypeName(statusCode: 200, typeName: "event_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_update_event_4xx_response") = event_response | waiting_room_update_event_4xx_response

type waiting_room_update_event_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union waiting_room_create_waiting_room_rule_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_create_waiting_room_rule_4xx_response") = schemas_rules_response_collection | waiting_room_create_waiting_room_rule_4xx_response

type waiting_room_create_waiting_room_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input create_rule_Input {
  action: rule_action!
  "The description of the rule."
  description: String
  "When set to true, the rule is enabled."
  enabled: Boolean = true
  "Criteria defining when there is a match for the current rule."
  expression: String!
}

union waiting_room_replace_waiting_room_rules_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_replace_waiting_room_rules_4xx_response") = schemas_rules_response_collection | waiting_room_replace_waiting_room_rules_4xx_response

type waiting_room_replace_waiting_room_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waiting_room_delete_waiting_room_rule_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_delete_waiting_room_rule_4xx_response") = schemas_rules_response_collection | waiting_room_delete_waiting_room_rule_4xx_response

type waiting_room_delete_waiting_room_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

union waiting_room_patch_waiting_room_rule_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_rules_response_collection") @statusCodeTypeName(statusCode: "4xx", typeName: "waiting_room_patch_waiting_room_rule_4xx_response") = schemas_rules_response_collection | waiting_room_patch_waiting_room_rule_4xx_response

type waiting_room_patch_waiting_room_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input patch_rule_Input {
  action: rule_action!
  "The description of the rule."
  description: String
  "When set to true, the rule is enabled."
  enabled: Boolean = true
  "Criteria defining when there is a match for the current rule."
  expression: String!
  position: rule_position_Input
}

input rule_position_Input @oneOf {
  mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_0_Input: mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_0_Input
  mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_1_Input: mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_1_Input
  mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_2_Input: mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_2_Input
}

input mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_0_Input {
  "Places the rule in the exact position specified by the integer number <POSITION_NUMBER>. Position numbers start with 1. Existing rules in the ruleset from the specified position number onward are shifted one position (no rule is overwritten)."
  index: Int
}

input mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_1_Input {
  "Places the rule before rule <RULE_ID>. Use this argument with an empty rule ID value (\\"\\") to set the rule as the first rule in the ruleset."
  before: String
}

input mutationInput_waiting_room_patch_waiting_room_rule_input_position_oneOf_2_Input {
  "Places the rule after rule <RULE_ID>. Use this argument with an empty rule ID value (\\"\\") to set the rule as the last rule in the ruleset."
  after: String
}

union web3_hostname_create_web3_hostname_response @statusCodeTypeName(statusCode: 200, typeName: "web3_hostname_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_create_web3_hostname_4xx_response") = web3_hostname_components_schemas_single_response | web3_hostname_create_web3_hostname_4xx_response

type web3_hostname_create_web3_hostname_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input create_request_Input {
  "An optional description of the hostname."
  description: web3_hostname_components_schemas_description
  "DNSLink value used if the target is ipfs."
  dnslink: String
  "The hostname that will point to the target gateway via CNAME."
  name: web3_hostname_components_schemas_name
  target: components_schemas_target!
}

union web3_hostname_delete_web3_hostname_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_delete_web3_hostname_4xx_response") = api_response_single_id | web3_hostname_delete_web3_hostname_4xx_response

type web3_hostname_delete_web3_hostname_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union web3_hostname_edit_web3_hostname_response @statusCodeTypeName(statusCode: 200, typeName: "web3_hostname_components_schemas_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_edit_web3_hostname_4xx_response") = web3_hostname_components_schemas_single_response | web3_hostname_edit_web3_hostname_4xx_response

type web3_hostname_edit_web3_hostname_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input modify_request_Input {
  "An optional description of the hostname."
  description: web3_hostname_components_schemas_description
  "DNSLink value used if the target is ipfs."
  dnslink: String
}

union web3_hostname_update_ipfs_universal_path_gateway_content_list_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_details_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_update_ipfs_universal_path_gateway_content_list_4xx_response") = content_list_details_response | web3_hostname_update_ipfs_universal_path_gateway_content_list_4xx_response

type web3_hostname_update_ipfs_universal_path_gateway_content_list_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input content_list_update_request_Input {
  action: content_list_action!
  "Content list entries."
  entries: [content_list_entry_Input]!
}

"Content list entry to be blocked."
input content_list_entry_Input {
  "CID or content path of content to block."
  content: content_list_entry_content
  created_on: DateTime
  "An optional description of the content list entry."
  description: content_list_entry_description
  "Identifier"
  id: common_components_schemas_identifier
  modified_on: DateTime
  type: content_list_entry_type
}

union web3_hostname_create_ipfs_universal_path_gateway_content_list_entry_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_entry_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_create_ipfs_universal_path_gateway_content_list_entry_4xx_response") = content_list_entry_single_response | web3_hostname_create_ipfs_universal_path_gateway_content_list_entry_4xx_response

type web3_hostname_create_ipfs_universal_path_gateway_content_list_entry_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input content_list_entry_create_request_Input {
  "CID or content path of content to block."
  content: content_list_entry_content!
  "An optional description of the content list entry."
  description: content_list_entry_description
  type: content_list_entry_type!
}

union web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry_4xx_response") = api_response_single_id | web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry_4xx_response

type web3_hostname_delete_ipfs_universal_path_gateway_content_list_entry_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry_response @statusCodeTypeName(statusCode: 200, typeName: "content_list_entry_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry_4xx_response") = content_list_entry_single_response | web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry_4xx_response

type web3_hostname_edit_ipfs_universal_path_gateway_content_list_entry_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_script__deprecated_upload_worker_response @statusCodeTypeName(statusCode: 200, typeName: "script_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_script__deprecated_upload_worker_4xx_response") = script_response_single | worker_script__deprecated_upload_worker_4xx_response

type script_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: JSON
  "Whether the API call was successful"
  success: Boolean!
}

type worker_script__deprecated_upload_worker_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union put_zones_zone_id_activation_check_response @statusCodeTypeName(statusCode: 200, typeName: "put_zones_zone_id_activation_check_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "put_zones_zone_id_activation_check_4xx_response") = put_zones_zone_id_activation_check_200_response | put_zones_zone_id_activation_check_4xx_response

type put_zones_zone_id_activation_check_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_put_zones_zone_id_activation_check_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_put_zones_zone_id_activation_check_oneOf_0_allOf_1_result {
  "Identifier"
  id: identifier!
}

"Identifier"
scalar identifier @length(min: null, max: 32)

type put_zones_zone_id_activation_check_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union api_shield_settings_set_configuration_properties_response @statusCodeTypeName(statusCode: 200, typeName: "default_response") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_settings_set_configuration_properties_4xx_response") = default_response | api_shield_settings_set_configuration_properties_4xx_response

type default_response {
  errors: [JSON]
  messages: [JSON]
  result: query_ip_address_management_address_maps_address_map_details_oneOf_0_allOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type api_shield_settings_set_configuration_properties_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input configuration_Input {
  auth_id_characteristics: [query_api_shield_settings_retrieve_information_about_specific_configuration_properties_oneOf_0_allOf_1_result_auth_id_characteristics_items_Input]
}

input query_api_shield_settings_retrieve_information_about_specific_configuration_properties_oneOf_0_allOf_1_result_auth_id_characteristics_items_Input {
  "The name of the characteristic field, i.e., the header or cookie name."
  name: characteristics_components_schemas_name!
  type: schemas_type!
}

union api_shield_endpoint_management_add_operations_to_a_zone_response @statusCodeTypeName(statusCode: 200, typeName: "collection_response") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_add_operations_to_a_zone_4xx_response") = collection_response | api_shield_endpoint_management_add_operations_to_a_zone_4xx_response

type collection_response {
  errors: [JSON]
  messages: [JSON]
  result: [query_api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_oneOf_0_anyOf_0_allOf_0_allOf_1_result_items]
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

type query_api_shield_endpoint_management_retrieve_information_about_all_operations_on_a_zone_oneOf_0_anyOf_0_allOf_0_allOf_1_result_items {
  endpoint: endpoint!
  features: JSON
  "RFC3986-compliant host."
  host: Hostname!
  last_updated: DateTime!
  method: method!
  "The ID that identifies the API operation."
  operation_id: JSON!
}

type api_shield_endpoint_management_add_operations_to_a_zone_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
  result_info: result_info
}

input mutationInput_api_shield_endpoint_management_add_operations_to_a_zone_input_items_Input {
  endpoint: endpoint
  "RFC3986-compliant host."
  host: Hostname
  method: method
}

union api_shield_endpoint_management_delete_an_operation_response @statusCodeTypeName(statusCode: 200, typeName: "default_response") @statusCodeTypeName(statusCode: "4xx", typeName: "api_shield_endpoint_management_delete_an_operation_4xx_response") = default_response | api_shield_endpoint_management_delete_an_operation_4xx_response

type api_shield_endpoint_management_delete_an_operation_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union ip_access_rules_for_a_zone_create_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_zone_create_an_ip_access_rule_4xx_response") = rule_single_response | ip_access_rules_for_a_zone_create_an_ip_access_rule_4xx_response

type ip_access_rules_for_a_zone_create_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_a_zone_create_an_ip_access_rule_request_Input {
  configuration: schemas_configuration_Input!
  mode: schemas_mode!
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String!
}

union ip_access_rules_for_a_zone_delete_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_id_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_zone_delete_an_ip_access_rule_4xx_response") = rule_single_id_response | ip_access_rules_for_a_zone_delete_an_ip_access_rule_4xx_response

type ip_access_rules_for_a_zone_delete_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_a_zone_delete_an_ip_access_rule_request_Input {
  cascade: mutationInput_ip_access_rules_for_a_zone_delete_an_ip_access_rule_input_cascade = none
}

"The level to attempt to delete similar rules defined for other zones with the same owner. The default value is \`none\`, which will only delete the current rule. Using \`basic\` will delete rules that match the same action (mode) and configuration, while using \`aggressive\` will delete rules that match the same configuration."
enum mutationInput_ip_access_rules_for_a_zone_delete_an_ip_access_rule_input_cascade {
  none
  basic
  aggressive
}

union ip_access_rules_for_a_zone_update_an_ip_access_rule_response @statusCodeTypeName(statusCode: 200, typeName: "rule_single_response") @statusCodeTypeName(statusCode: "4xx", typeName: "ip_access_rules_for_a_zone_update_an_ip_access_rule_4xx_response") = rule_single_response | ip_access_rules_for_a_zone_update_an_ip_access_rule_4xx_response

type ip_access_rules_for_a_zone_update_an_ip_access_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input ip_access_rules_for_a_zone_update_an_ip_access_rule_request_Input {
  mode: schemas_mode
  "An informative summary of the rule, typically used as a reminder or explanation."
  notes: String
}

union waf_rules_update_a_waf_rule_response @statusCodeTypeName(statusCode: 200, typeName: "waf_rules_update_a_waf_rule_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "waf_rules_update_a_waf_rule_4xx_response") = waf_rules_update_a_waf_rule_200_response | waf_rules_update_a_waf_rule_4xx_response

type waf_rules_update_a_waf_rule_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_waf_rules_update_a_waf_rule_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

union mutation_waf_rules_update_a_waf_rule_oneOf_0_allOf_1_result = Anomaly_detection_WAF_rule | Traditional_deny_WAF_rule | Traditional_allow_WAF_rule

type waf_rules_update_a_waf_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input waf_rules_update_a_waf_rule_request_Input {
  mode: mutationInput_waf_rules_update_a_waf_rule_input_mode
}

"The mode/action of the rule when triggered. You must use a value from the \`allowed_modes\` array of the current rule."
enum mutationInput_waf_rules_update_a_waf_rule_input_mode {
  default
  disable
  simulate
  block
  challenge
  on
  off
}

union managed_transforms_update_status_of_managed_transforms_response @statusCodeTypeName(statusCode: 200, typeName: "managed_transforms_update_status_of_managed_transforms_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "managed_transforms_update_status_of_managed_transforms_4xx_response") = managed_transforms_update_status_of_managed_transforms_200_response | managed_transforms_update_status_of_managed_transforms_4xx_response

type managed_transforms_update_status_of_managed_transforms_200_response {
  managed_request_headers: [response_model]
  managed_response_headers: [response_model]
}

type response_model {
  "When true, the Managed Transform is available in the current Cloudflare plan."
  available: Boolean
  "When true, the Managed Transform is enabled."
  enabled: Boolean
  "Human-readable identifier of the Managed Transform."
  id: String
}

type managed_transforms_update_status_of_managed_transforms_4xx_response {
  managed_request_headers: [response_model]
  managed_response_headers: [response_model]
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input managed_transforms_update_status_of_managed_transforms_request_Input {
  managed_request_headers: [request_model_Input]!
  managed_response_headers: [request_model_Input]!
}

input request_model_Input {
  "When true, the Managed Transform is enabled."
  enabled: Boolean
  "Human-readable identifier of the Managed Transform."
  id: String
}

union page_shield_update_page_shield_settings_response @statusCodeTypeName(statusCode: 200, typeName: "page_shield_update_page_shield_settings_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "page_shield_update_page_shield_settings_4xx_response") = page_shield_update_page_shield_settings_200_response | page_shield_update_page_shield_settings_4xx_response

type page_shield_update_page_shield_settings_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: update_zone_settings_response
  "Whether the API call was successful"
  success: Boolean!
}

type update_zone_settings_response {
  "When true, indicates that Page Shield is enabled."
  enabled: Boolean
  "The timestamp of when Page Shield was last updated."
  updated_at: DateTime
  "When true, CSP reports will be sent to https://csp-reporting.cloudflare.com/cdn-cgi/script_monitor/report"
  use_cloudflare_reporting_endpoint: Boolean
  "When true, the paths associated with connections URLs will also be analyzed."
  use_connection_url_path: Boolean
}

type page_shield_update_page_shield_settings_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input page_shield_update_page_shield_settings_request_Input {
  "When true, indicates that Page Shield is enabled."
  enabled: Boolean
  "When true, CSP reports will be sent to https://csp-reporting.cloudflare.com/cdn-cgi/script_monitor/report"
  use_cloudflare_reporting_endpoint: Boolean
  "When true, the paths associated with connections URLs will also be analyzed."
  use_connection_url_path: Boolean
}

union zone_rulesets_create_a_zone_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_create_a_zone_ruleset_4xx_response") = ruleset_response | zone_rulesets_create_a_zone_ruleset_4xx_response

type zone_rulesets_create_a_zone_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union custom_error_responses_update_custom_error_responses_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "custom_error_responses_update_custom_error_responses_4xx_response") = api_response_single | custom_error_responses_update_custom_error_responses_4xx_response

type custom_error_responses_update_custom_error_responses_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union transform_rules_update_transform_rules_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "transform_rules_update_transform_rules_4xx_response") = api_response_single | transform_rules_update_transform_rules_4xx_response

type transform_rules_update_transform_rules_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_update_a_zone_entry_point_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_update_a_zone_entry_point_ruleset_4xx_response") = ruleset_response | zone_rulesets_update_a_zone_entry_point_ruleset_4xx_response

type zone_rulesets_update_a_zone_entry_point_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_update_a_zone_ruleset_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_update_a_zone_ruleset_4xx_response") = ruleset_response | zone_rulesets_update_a_zone_ruleset_4xx_response

type zone_rulesets_update_a_zone_ruleset_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_create_a_zone_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_create_a_zone_ruleset_rule_4xx_response") = ruleset_response | zone_rulesets_create_a_zone_ruleset_rule_4xx_response

type zone_rulesets_create_a_zone_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_delete_a_zone_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_delete_a_zone_ruleset_rule_4xx_response") = ruleset_response | zone_rulesets_delete_a_zone_ruleset_rule_4xx_response

type zone_rulesets_delete_a_zone_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union zone_rulesets_update_a_zone_ruleset_rule_response @statusCodeTypeName(statusCode: 200, typeName: "ruleset_response") @statusCodeTypeName(statusCode: "4xx", typeName: "zone_rulesets_update_a_zone_ruleset_rule_4xx_response") = ruleset_response | zone_rulesets_update_a_zone_ruleset_rule_4xx_response

type zone_rulesets_update_a_zone_ruleset_rule_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union url_normalization_update_url_normalization_settings_response @statusCodeTypeName(statusCode: 200, typeName: "schemas_response_model") @statusCodeTypeName(statusCode: "4xx", typeName: "url_normalization_update_url_normalization_settings_4xx_response") = schemas_response_model | url_normalization_update_url_normalization_settings_4xx_response

type url_normalization_update_url_normalization_settings_4xx_response {
  "The scope of the URL normalization."
  scope: String
  "The type of URL normalization performed by Cloudflare."
  type: String
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input schemas_request_model_Input {
  "The scope of the URL normalization."
  scope: String
  "The type of URL normalization performed by Cloudflare."
  type: String
}

union worker_filters__deprecated_create_filter_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_filters__deprecated_create_filter_4xx_response") = api_response_single_id | worker_filters__deprecated_create_filter_4xx_response

type worker_filters__deprecated_create_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input filter_no_id_Input {
  enabled: Boolean!
  pattern: String!
}

union worker_filters__deprecated_delete_filter_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_filters__deprecated_delete_filter_4xx_response") = api_response_single_id | worker_filters__deprecated_delete_filter_4xx_response

type worker_filters__deprecated_delete_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_filters__deprecated_update_filter_response @statusCodeTypeName(statusCode: 200, typeName: "filter_response_single") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_filters__deprecated_update_filter_4xx_response") = filter_response_single | worker_filters__deprecated_update_filter_4xx_response

type filter_response_single {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: filters
  "Whether the API call was successful"
  success: Boolean!
}

type worker_filters__deprecated_update_filter_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_routes_create_route_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_routes_create_route_4xx_response") = api_response_single_id | worker_routes_create_route_4xx_response

type worker_routes_create_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input route_no_id_Input {
  pattern: String!
  script: schemas_script_name
}

union worker_routes_delete_route_response @statusCodeTypeName(statusCode: 200, typeName: "api_response_single_id") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_routes_delete_route_4xx_response") = api_response_single_id | worker_routes_delete_route_4xx_response

type worker_routes_delete_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union worker_routes_update_route_response @statusCodeTypeName(statusCode: 200, typeName: "route_response_single2") @statusCodeTypeName(statusCode: "4xx", typeName: "worker_routes_update_route_4xx_response") = route_response_single2 | worker_routes_update_route_4xx_response

type worker_routes_update_route_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_response @statusCodeTypeName(statusCode: 200, typeName: "response_single_origin_dns") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_4xx_response") = response_single_origin_dns | spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_4xx_response

type response_single_origin_dns {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result {
  "Enables Argo Smart Routing for this application.\\nNotes: Only available for TCP applications with traffic_type set to \\"direct\\"."
  argo_smart_routing: Boolean
  "When the Application was created."
  created_on: DateTime
  dns: dns
  edge_ips: edge_ips
  "Application identifier."
  id: app_id!
  "Enables IP Access Rules for this application.\\nNotes: Only available for TCP applications."
  ip_firewall: Boolean
  "When the Application was last modified."
  modified_on: DateTime
  origin_dns: origin_dns
  "The destination port at the origin. Only specified in conjunction with origin_dns. May use an integer to specify a single origin port, for example \`1000\`, or a string to specify a range of origin ports, for example \`\\"1000-2000\\"\`.\\nNotes: If specifying a port range, the number of ports in the range must match the number of ports specified in the \\"protocol\\" field."
  origin_port: PositiveFloat
  "The port configuration at Cloudflare’s edge. May specify a single port, for example \`\\"tcp/1000\\"\`, or a range of ports, for example \`\\"tcp/1000-2000\\"\`."
  protocol: String
  proxy_protocol: proxy_protocol
  tls: tls
  traffic_type: traffic_type
}

"The name and type of DNS record for the Spectrum application."
type dns {
  "The name of the DNS record associated with the application."
  name: Hostname
  type: dns_type
}

"The type of DNS record associated with the application."
enum dns_type {
  CNAME
  ADDRESS
}

"The anycast edge IP configuration for the hostname of this application."
union edge_ips = mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0 | mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_1

type mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0 {
  connectivity: mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_connectivity
  type: dynamic_const
}

"The IP versions supported for inbound connections on Spectrum anycast IPs."
enum mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_connectivity {
  all
  ipv4
  ipv6
}

enum dynamic_const @typescript(type: "\\"dynamic\\"") @example(value: "\\"dynamic\\"") {
  dynamic @enum(value: "\\"dynamic\\"")
}

type mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_1 {
  "The array of customer owned IPs we broadcast via anycast for this hostname and application."
  ips: [String]
  type: static_const
}

enum static_const @typescript(type: "\\"static\\"") @example(value: "\\"static\\"") {
  static @enum(value: "\\"static\\"")
}

"The name and type of DNS record for the Spectrum application."
type origin_dns {
  "The name of the DNS record associated with the origin."
  name: Hostname
  "The TTL of our resolution of your DNS record in seconds."
  ttl: PositiveInt
  type: origin_dns_type
}

"The type of DNS record associated with the origin. \\"\\" is used to specify a combination of A/AAAA records."
enum origin_dns_type {
  _ @enum(value: "\\"\\"")
  A
  AAAA
  SRV
}

"Enables Proxy Protocol to the origin. Refer to [Enable Proxy protocol](https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/) for implementation details on PROXY Protocol V1, PROXY Protocol V2, and Simple Proxy Protocol."
enum proxy_protocol {
  off
  v1
  v2
  simple
}

"The type of TLS termination associated with the application."
enum tls {
  off
  flexible
  full
  strict
}

"Determines how data travels from the edge to your origin. When set to \\"direct\\", Spectrum will send traffic directly to your origin, and the application's type is derived from the \`protocol\`. When set to \\"http\\" or \\"https\\", Spectrum will apply Cloudflare's HTTP/HTTPS features as it sends traffic to your origin, and the application type matches this property exactly."
enum traffic_type {
  direct
  http
  https
}

type spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_request_Input {
  "Enables Argo Smart Routing for this application.\\nNotes: Only available for TCP applications with traffic_type set to \\"direct\\"."
  argo_smart_routing: Boolean
  dns: dns_Input!
  edge_ips: edge_ips_Input
  "Enables IP Access Rules for this application.\\nNotes: Only available for TCP applications."
  ip_firewall: Boolean
  origin_dns: origin_dns_Input!
  "The destination port at the origin. Only specified in conjunction with origin_dns. May use an integer to specify a single origin port, for example \`1000\`, or a string to specify a range of origin ports, for example \`\\"1000-2000\\"\`.\\nNotes: If specifying a port range, the number of ports in the range must match the number of ports specified in the \\"protocol\\" field."
  origin_port: PositiveFloat!
  "The port configuration at Cloudflare’s edge. May specify a single port, for example \`\\"tcp/1000\\"\`, or a range of ports, for example \`\\"tcp/1000-2000\\"\`."
  protocol: String!
  proxy_protocol: proxy_protocol = off
  tls: tls
  traffic_type: traffic_type = direct
}

"The name and type of DNS record for the Spectrum application."
input dns_Input {
  "The name of the DNS record associated with the application."
  name: Hostname
  type: dns_type
}

input edge_ips_Input @oneOf {
  mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_Input: mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_Input
  mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_1_Input: mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_1_Input
}

input mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_Input {
  connectivity: mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_0_connectivity
  type: dynamic_const
}

input mutation_spectrum_applications_create_spectrum_application_using_a_name_for_the_origin_oneOf_0_allOf_1_result_edge_ips_oneOf_1_Input {
  "The array of customer owned IPs we broadcast via anycast for this hostname and application."
  ips: [String]
  type: static_const
}

"The name and type of DNS record for the Spectrum application."
input origin_dns_Input {
  "The name of the DNS record associated with the origin."
  name: Hostname
  "The TTL of our resolution of your DNS record in seconds."
  ttl: PositiveInt
  type: origin_dns_type
}

union spectrum_applications_delete_spectrum_application_response @statusCodeTypeName(statusCode: 200, typeName: "spectrum_applications_delete_spectrum_application_200_response") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_applications_delete_spectrum_application_4xx_response") = spectrum_applications_delete_spectrum_application_200_response | spectrum_applications_delete_spectrum_application_4xx_response

type spectrum_applications_delete_spectrum_application_200_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: mutation_spectrum_applications_delete_spectrum_application_oneOf_0_allOf_1_result
  "Whether the API call was successful"
  success: Boolean!
}

type mutation_spectrum_applications_delete_spectrum_application_oneOf_0_allOf_1_result {
  "Application identifier."
  id: app_id!
}

type spectrum_applications_delete_spectrum_application_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

union spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_response @statusCodeTypeName(statusCode: 200, typeName: "response_single_origin_dns") @statusCodeTypeName(statusCode: "4xx", typeName: "spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_4xx_response") = response_single_origin_dns | spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_4xx_response

type spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_4xx_response {
  errors: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  messages: [query_accounts_list_accounts_oneOf_0_anyOf_0_errors_items]!
  result: Void
  "Whether the API call was successful"
  success: Boolean!
}

input spectrum_applications_update_spectrum_application_configuration_using_a_name_for_the_origin_request_Input {
  "Enables Argo Smart Routing for this application.\\nNotes: Only available for TCP applications with traffic_type set to \\"direct\\"."
  argo_smart_routing: Boolean
  dns: dns_Input!
  edge_ips: edge_ips_Input
  "Enables IP Access Rules for this application.\\nNotes: Only available for TCP applications."
  ip_firewall: Boolean
  origin_dns: origin_dns_Input!
  "The destination port at the origin. Only specified in conjunction with origin_dns. May use an integer to specify a single origin port, for example \`1000\`, or a string to specify a range of origin ports, for example \`\\"1000-2000\\"\`.\\nNotes: If specifying a port range, the number of ports in the range must match the number of ports specified in the \\"protocol\\" field."
  origin_port: PositiveFloat!
  "The port configuration at Cloudflare’s edge. May specify a single port, for example \`\\"tcp/1000\\"\`, or a range of ports, for example \`\\"tcp/1000-2000\\"\`."
  protocol: String!
  proxy_protocol: proxy_protocol = off
  tls: tls
  traffic_type: traffic_type = direct
}

scalar ObjMap

enum HTTPMethod {
  GET
  HEAD
  POST
  PUT
  DELETE
  CONNECT
  OPTIONS
  TRACE
  PATCH
}"
`;
