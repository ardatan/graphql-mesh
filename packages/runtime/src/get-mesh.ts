/* eslint-disable no-unused-expressions */
import {
  GraphQLSchema,
  DocumentNode,
  GraphQLError,
  GraphQLResolveInfo,
  OperationTypeNode,
  GraphQLObjectType,
  getOperationAST,
  isListType,
  SelectionSetNode,
} from 'graphql';
import { GetMeshOptions, Requester } from './types';
import { MeshPubSub, KeyValueCache, RawSourceOutput } from '@graphql-mesh/types';

import { MESH_CONTEXT_SYMBOL, MESH_API_CONTEXT_SYMBOL } from './constants';
import {
  applySchemaTransforms,
  getInterpolatedStringFactory,
  groupTransforms,
  ResolverDataBasedFactory,
} from '@graphql-mesh/utils';

import { InMemoryLiveQueryStore } from '@n1ru4l/in-memory-live-query-store';
import { delegateToSchema } from '@graphql-tools/delegate';
import AggregateError from '@ardatan/aggregate-error';
import { DefaultLogger } from './logger';
import { batchDelegateToSchema } from '@graphql-tools/batch-delegate';
import { WrapQuery } from '@graphql-tools/wrap';
import { Envelop, envelop, Plugin, useExtendContext, useLogger, useSchema } from '@envelop/core';
import { useGraphQlJit } from '@envelop/graphql-jit';
import { useLiveQuery } from '@envelop/live-query';

export interface MeshInstance {
  meshEnvelop: Envelop;
  rawSources: RawSourceOutput[];
  sdkRequester: Requester;
  destroy: () => void;
  pubsub: MeshPubSub;
  cache: KeyValueCache;
  liveQueryStore: InMemoryLiveQueryStore;
}

export async function getMesh(options: GetMeshOptions): Promise<MeshInstance> {
  const rawSources: RawSourceOutput[] = [];
  const { pubsub, cache, logger = new DefaultLogger('Mesh') } = options;
  const envelopPlugins: Plugin[] = [];
  const envelopLogger = logger.child('Envelop');
  envelopPlugins.push(
    useLogger({
      logFn: (...args: any[]) => (envelopLogger.debug as any)(...(args as any[])),
    })
  );

  const getMeshLogger = logger.child('getMesh/runtime');
  getMeshLogger.debug(`Getting subschemas from source handlers`);
  await Promise.all(
    options.sources.map(async apiSource => {
      const apiName = apiSource.name;
      const sourceLogger = logger.child(apiName);
      sourceLogger.debug(`Schema is being generated`);
      const source = await apiSource.handler.getMeshSource();
      sourceLogger.debug(`Schema has been generated successfully`);

      let apiSchema = source.schema;

      sourceLogger.debug(`Analyzing transforms`);
      const { wrapTransforms, noWrapTransforms } = groupTransforms(apiSource.transforms);

      if (noWrapTransforms?.length) {
        sourceLogger.debug(`${noWrapTransforms.length} bare transforms found and applying`);
        apiSchema = applySchemaTransforms(apiSchema, { schema: apiSchema }, null, noWrapTransforms);
      }

      rawSources.push({
        name: apiName,
        contextBuilder: source.contextBuilder || null,
        schema: apiSchema,
        executor: source.executor,
        subscriber: source.subscriber,
        transforms: wrapTransforms,
        contextVariables: source.contextVariables || [],
        handler: apiSource.handler,
        batch: 'batch' in source ? source.batch : true,
        merge: apiSource.merge,
      });
    })
  );
  getMeshLogger.debug(`Schemas have been generated by the source handlers`);

  getMeshLogger.debug(`Merging schemas using the defined merging strategy.`);
  const unifiedSchema = await options.merger({
    rawSources,
    cache,
    pubsub,
    typeDefs: options.additionalTypeDefs,
    resolvers: options.additionalResolvers,
    transforms: options.transforms,
    logger: logger.child(`Merger`),
  });
  envelopPlugins.push(useSchema(unifiedSchema));

  getMeshLogger.debug(`Attaching resolver hooks to the unified schema`);
  envelopPlugins.push({
    onExecute: ({ args }) => ({
      onResolverCalled: resolverData => {
        pubsub.publish('resolverCalled', { resolverData });
        return ({ result }) => pubsub.publish('resolverDone', { resolverData, result });
      },
      onExecuteDone: ({ result: executionResult }) => pubsub.publish('executionDone', { ...args, executionResult }),
    }),
  });

  getMeshLogger.debug(`Creating JIT Executor`);
  envelopPlugins.push(useGraphQlJit());

  getMeshLogger.debug(`Creating Live Query Store`);
  const liveQueryStore = new InMemoryLiveQueryStore({
    includeIdentifierExtension: true,
  });
  envelopPlugins.push(useLiveQuery({ liveQueryStore }));

  const liveQueryInvalidationFactoryMap = new Map<string, ResolverDataBasedFactory<string>[]>();

  options.liveQueryInvalidations?.forEach(liveQueryInvalidation => {
    const rawInvalidationPaths = liveQueryInvalidation.invalidate;
    const factories = rawInvalidationPaths.map(rawInvalidationPath =>
      getInterpolatedStringFactory(rawInvalidationPath)
    );
    liveQueryInvalidationFactoryMap.set(liveQueryInvalidation.field, factories);
  });

  getMeshLogger.debug(`Creating event listener (resolverDone) for Live Query Store`);
  pubsub.subscribe('resolverDone', ({ result, resolverData }) => {
    if (resolverData?.info?.parentType && resolverData?.info?.fieldName) {
      const path = `${resolverData.info.parentType.name}.${resolverData.info.fieldName}`;
      if (liveQueryInvalidationFactoryMap.has(path)) {
        const invalidationPathFactories = liveQueryInvalidationFactoryMap.get(path);
        const invalidationPaths = invalidationPathFactories.map(invalidationPathFactory =>
          invalidationPathFactory({ ...resolverData, result })
        );
        liveQueryStore.invalidate(invalidationPaths);
      }
    }
  });

  const baseMeshContext: Record<string, any> = {
    pubsub,
    cache,
    liveQueryStore,
    [MESH_CONTEXT_SYMBOL]: true,
  };
  const sourceMap: Map<RawSourceOutput, GraphQLSchema> = unifiedSchema.extensions.sourceMap;
  await Promise.all(
    rawSources.map(async rawSource => {
      const rawSourceLogger = logger.child(`${rawSource.name}`);

      const rawSourceContext: any = {
        rawSource,
        [MESH_API_CONTEXT_SYMBOL]: true,
      };
      const transformedSchema = sourceMap.get(rawSource);
      const rootTypes: Record<OperationTypeNode, GraphQLObjectType> = {
        query: transformedSchema.getQueryType(),
        mutation: transformedSchema.getMutationType(),
        subscription: transformedSchema.getSubscriptionType(),
      };

      rawSourceLogger.debug(`In Context SDK is being generated`);
      for (const operationType in rootTypes) {
        const rootType: GraphQLObjectType = rootTypes[operationType];
        if (rootType) {
          rawSourceContext[rootType.name] = {};
          const rootTypeFieldMap = rootType.getFields();
          for (const fieldName in rootTypeFieldMap) {
            const rootTypeField = rootTypeFieldMap[fieldName];
            const inContextSdkLogger = rawSourceLogger.child(`InContextSDK.${rootType.name}.${fieldName}`);
            rawSourceContext[rootType.name][fieldName] = ({
              root,
              args,
              context,
              info,
              selectionSet,
              key,
              argsFromKeys,
            }: {
              root: any;
              args: any;
              context: any;
              info: GraphQLResolveInfo;
              selectionSet: (subtree: SelectionSetNode) => SelectionSetNode;
              key?: string;
              argsFromKeys?: (keys: string[]) => any;
            }) => {
              inContextSdkLogger.debug(`Called with ${JSON.stringify({ root, args, key })}`);
              const delegationOptions = {
                schema: rawSource,
                rootValue: root,
                operation: operationType as OperationTypeNode,
                fieldName,
                args,
                returnType: rootTypeField.type,
                context,
                transformedSchema,
                skipValidation: true,
                info,
              };
              if (isListType(rootTypeField.type) && key && argsFromKeys) {
                const batchDelegationOptions = {
                  ...delegationOptions,
                  key,
                  argsFromKeys,
                };
                delete batchDelegationOptions.args;
                return batchDelegateToSchema(batchDelegationOptions);
              } else if (selectionSet) {
                return delegateToSchema({
                  ...delegationOptions,
                  transforms: [new WrapQuery([fieldName], selectionSet, res => res)],
                });
              } else {
                return delegateToSchema(delegationOptions);
              }
            };
          }
        }
      }
      baseMeshContext[rawSource.name] = rawSourceContext;
    })
  );

  const buildMeshContextLogger = logger.child(`buildMeshContext`);
  envelopPlugins.push(
    useExtendContext(async function buildMeshContext<TAdditionalContext, TContext extends TAdditionalContext = any>(
      additionalContext: TAdditionalContext = {} as any
    ): Promise<TContext> {
      buildMeshContextLogger.debug(`Building Mesh Context`);
      if (MESH_CONTEXT_SYMBOL in additionalContext) {
        buildMeshContextLogger.debug(`Context is already ready for Mesh then returning the existing context`);
        return additionalContext as TContext;
      }

      buildMeshContextLogger.debug(`Attaching in-context SDK, pubsub, cache and liveQueryStore to the context`);
      const context: TContext = Object.assign(additionalContext as any, baseMeshContext);

      buildMeshContextLogger.debug(`Building context for each source`);
      await Promise.all(
        rawSources.map(async rawSource => {
          const rawSourceLogger = buildMeshContextLogger.child(`${rawSource.name}`);
          const contextBuilder = rawSource.contextBuilder;

          if (contextBuilder) {
            rawSourceLogger.debug(`Building context`);
            const sourceContext = await contextBuilder(context);
            if (sourceContext) {
              Object.assign(context, sourceContext);
            }
            rawSourceLogger.debug(`Context has been built successfully`);
          }
        })
      );

      return context;
    })
  );

  const meshEnvelop = envelop({
    plugins: envelopPlugins,
    enableInternalTracing: true,
  });

  class GraphQLMeshSdkError<Data = any, Variables = any> extends AggregateError {
    constructor(
      errors: ReadonlyArray<GraphQLError>,
      public document: DocumentNode,
      public variables: Variables,
      public data: Data
    ) {
      super(errors);
    }
  }

  const sdkLogger = logger.child('Mesh SDK');
  const localRequester: Requester = async <Result, TVariables, TContext, TRootValue>(
    document: DocumentNode,
    variableValues: TVariables,
    context?: TContext,
    rootValue?: TRootValue,
    operationName?: string
  ) => {
    if (!operationName) {
      const operationAst = getOperationAST(document);
      operationName = operationAst.name?.value;
    }
    const executionLogger = sdkLogger.child(operationName || 'UnnamedOperation');
    executionLogger.debug(`Execution started with;\n ${JSON.stringify(variableValues, null, 2)}`);
    const { execute, contextFactory } = meshEnvelop(context);
    const contextValue = contextFactory();
    const executionResult = await execute({
      schema: unifiedSchema,
      document,
      variableValues,
      contextValue,
      rootValue,
      operationName,
    });

    if ('data' in executionResult || 'errors' in executionResult) {
      if (executionResult.data && !executionResult.errors) {
        executionLogger.debug(`Execution succeeded with;\n ${JSON.stringify(executionResult, null, 2)}`);
        return executionResult.data as Result;
      } else {
        executionLogger.debug(`Execution failed with;\n ${JSON.stringify(executionResult, null, 2)}`);
        throw new GraphQLMeshSdkError(
          executionResult.errors as ReadonlyArray<GraphQLError>,
          document,
          variableValues,
          executionResult.data
        );
      }
    } else {
      throw new Error('Not implemented');
    }
  };

  return {
    meshEnvelop,
    rawSources,
    sdkRequester: localRequester,
    cache,
    pubsub,
    destroy: () => pubsub.publish('destroy', undefined),
    liveQueryStore,
  };
}
