/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface Config {
  serve?: ServeConfig;
  sdk?: SDKConfig;
  /**
   * Codegen Configuration
   */
  codegen?: any;
  require?: string[];
  /**
   * Defines the list of your external data sources for your API mesh
   */
  sources: Source[];
  /**
   * Transform to apply to the unified mesh schema
   */
  transforms?: Transform[];
  /**
   * Additional type definitions, or type definitions overrides you wish to add to the schema mesh
   */
  additionalTypeDefs?: any;
  /**
   * Additional resolvers, or resolvers overrides you wish to add to the schema mesh (Any of: String, AdditionalStitchingResolverObject, AdditionalStitchingBatchResolverObject, AdditionalSubscriptionObject)
   */
  additionalResolvers?: (
    | string
    | AdditionalStitchingResolverObject
    | AdditionalStitchingBatchResolverObject
    | AdditionalSubscriptionObject
  )[];
  cache?: Cache;
  /**
   * Merge method
   */
  merger?: string;
  /**
   * PubSub Implementation (Any of: String, PubSubConfig)
   */
  pubsub?: string | PubSubConfig;
  /**
   * Live Query Invalidations
   */
  liveQueryInvalidations?: LiveQueryInvalidation[];
  /**
   * Provide a query or queries for GraphQL Playground, validation and SDK Generation
   * The value can be the file path, glob expression for the file paths or the SDL.
   * (.js, .jsx, .graphql, .gql, .ts and .tsx files are supported.
   */
  documents?: string[];
  /**
   * Logger instance that matches `Console` interface of NodeJS
   */
  logger?: any;
  /**
   * Allow connections to an SSL endpoint without certificates
   */
  skipSSLValidation?: boolean;
  /**
   * You can provide Envelop plugins
   */
  additionalEnvelopPlugins?: string;
}
/**
 * Configuration for `mesh start` or `mesh dev` command.
 * Those commands won't be available in programmatic usage.
 */
export interface ServeConfig {
  /**
   * Spawn multiple server instances as node clusters (default: `1`) (Any of: Int, Boolean)
   */
  fork?: number | boolean;
  /**
   * TCP Port to listen (default: `3000`) (Any of: Int, String)
   */
  port?: number | string;
  /**
   * The binding hostname (default: `localhost`)
   */
  hostname?: string;
  cors?: CorsConfig;
  /**
   * Express/Connect compatible handlers and middlewares extend GraphQL Mesh HTTP Server (Any of: WebhookHandler, ExpressHandler)
   */
  handlers?: (WebhookHandler | ExpressHandler)[];
  /**
   * Path to your static files you want to be served with GraphQL Mesh HTTP Server
   */
  staticFiles?: string;
  /**
   * Show GraphiQL Playground
   */
  playground?: boolean;
  /**
   * Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to '100kb'. (Any of: Int, String)
   */
  maxRequestBodySize?: number | string;
  sslCredentials?: HTTPSConfig;
  /**
   * Path to GraphQL Endpoint (default: /graphql)
   */
  endpoint?: string;
  /**
   * Path to the browser that will be used by `mesh serve` to open a playground window in development mode
   * This feature can be disable by passing `false` (Any of: String, Boolean)
   */
  browser?: string | boolean;
  /**
   * If you want to use a custom GraphQL server, you can pass the path of the code file that exports a custom Mesh Server Handler
   * With a custom server handler, you won't be able to use the features of GraphQL Mesh HTTP Server
   */
  customServerHandler?: string;
  /**
   * Title of GraphiQL Playground
   */
  playgroundTitle?: string;
}
/**
 * Configuration for CORS
 */
export interface CorsConfig {
  origin?: any;
  allowedHeaders?: string[];
  exposedHeaders?: string[];
  credentials?: boolean;
  maxAge?: number;
  preflightContinue?: boolean;
  optionsSuccessStatus?: number;
}
export interface WebhookHandler {
  /**
   * Path that remote API will ping
   */
  path: string;
  /**
   * HTTP Method that the handler will control (Allowed values: GET, POST, DELETE, PATCH)
   */
  method?: 'GET' | 'POST' | 'DELETE' | 'PATCH';
  /**
   * Name of the topic you want to pass incoming payload
   */
  pubsubTopic: string;
  /**
   * Part of the object you want to pass (e.g. `data.messages`)
   */
  payload?: string;
}
export interface ExpressHandler {
  /**
   * Path that the handler will control
   */
  path: string;
  /**
   * Path of the handler's code
   */
  handler: string;
  /**
   * HTTP Method that the handler will control (Allowed values: GET, POST, DELETE, PATCH)
   */
  method?: 'GET' | 'POST' | 'DELETE' | 'PATCH';
}
/**
 * SSL Credentials for HTTPS Server
 * If this is provided, Mesh will be served via HTTPS
 */
export interface HTTPSConfig {
  key: string;
  cert: string;
}
/**
 * SDK Configuration
 */
export interface SDKConfig {
  generateOperations?: GenerateOperationsConfig;
}
/**
 * Use this only if you don't want to use `documents` for SDK,
 * and let Mesh generate them for you
 */
export interface GenerateOperationsConfig {
  selectionSetDepth?: number;
}
export interface Source {
  /**
   * The name you wish to set to your remote API, this will be used for building the GraphQL context
   */
  name: string;
  handler: Handler;
  /**
   * List of transforms to apply to the current API source, before unifying it with the rest of the sources
   */
  transforms?: Transform[];
}
/**
 * Point to the handler you wish to use, it can either be a predefined handler, or a custom
 */
export interface Handler {
  graphql?: GraphQLHandler;
  grpc?: GrpcHandler;
  JsonSchema?: JsonSchemaHandler;
  mongoose?: MongooseHandler;
  mysql?: MySQLHandler;
  neo4j?: Neo4JHandler;
  newOpenapi?: NewOpenapiHandler;
  odata?: ODataHandler;
  openapi?: OpenapiHandler;
  postgraphile?: PostGraphileHandler;
  raml?: RAMLHandler;
  soap?: SoapHandler;
  thrift?: ThriftHandler;
  tuql?: TuqlHandler;
  [k: string]: any;
}
/**
 * Handler for remote/local/third-party GraphQL schema
 */
export interface GraphQLHandler {
  /**
   * A url or file path to your remote GraphQL endpoint.
   * If you provide a path to a code file(js or ts),
   * other options will be ignored and the schema exported from the file will be used directly.
   */
  endpoint: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for schema introspection
   * You can also provide `.js` or `.ts` file path that exports schemaHeaders as an object
   */
  schemaHeaders?: any;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Use HTTP GET for Query operations
   */
  useGETForQueries?: boolean;
  /**
   * HTTP method used for GraphQL operations (Allowed values: GET, POST)
   */
  method?: 'GET' | 'POST';
  /**
   * Path to a custom W3 Compatible Fetch Implementation
   */
  customFetch?: any;
  /**
   * Path to a custom W3 Compatible WebSocket Implementation
   */
  webSocketImpl?: string;
  /**
   * Path to the introspection
   * You can seperately give schema introspection
   */
  introspection?: string;
  /**
   * Enable multipart/formdata in order to support file uploads
   */
  multipart?: boolean;
  /**
   * Batch requests
   */
  batch?: boolean;
  /**
   * SSE - Server Sent Events
   * WS - New graphql-ws
   * LEGACY_WS - Legacy subscriptions-transport-ws (Allowed values: SSE, WS, LEGACY_WS)
   */
  subscriptionsProtocol?: 'SSE' | 'WS' | 'LEGACY_WS';
}
/**
 * Handler for gRPC and Protobuf schemas
 */
export interface GrpcHandler {
  /**
   * gRPC Endpoint
   */
  endpoint: string;
  /**
   * gRPC Proto file that contains your protobuf schema (Any of: ProtoFilePath, String)
   */
  protoFilePath?: ProtoFilePath | string;
  /**
   * Use a binary-encoded or JSON file descriptor set file (Any of: ProtoFilePath, String)
   */
  descriptorSetFilePath?: ProtoFilePath | string;
  /**
   * Request timeout in milliseconds
   * Default: 200000
   */
  requestTimeout?: number;
  credentialsSsl?: GrpcCredentialsSsl;
  /**
   * Use https instead of http for gRPC connection
   */
  useHTTPS?: boolean;
  /**
   * MetaData
   */
  metaData?: {
    [k: string]: any;
  };
  /**
   * Use gRPC reflection to automatically gather the connection
   */
  useReflection?: boolean;
}
export interface ProtoFilePath {
  file: string;
  load?: LoadOptions;
}
export interface LoadOptions {
  defaults?: boolean;
  includeDirs?: string[];
}
/**
 * SSL Credentials
 */
export interface GrpcCredentialsSsl {
  rootCA?: string;
  certChain?: string;
  privateKey?: string;
}
/**
 * Handler for JSON Schema specification. Source could be a local json file, or a url to it.
 */
export interface JsonSchemaHandler {
  baseUrl?: string;
  operationHeaders?: {
    [k: string]: any;
  };
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Any of: JsonSchemaHTTPOperation, JsonSchemaPubSubOperation
   */
  operations: (JsonSchemaHTTPOperation | JsonSchemaPubSubOperation)[];
  ignoreErrorResponses?: boolean;
}
export interface JsonSchemaHTTPOperation {
  field: string;
  description?: string;
  /**
   * Allowed values: Query, Mutation, Subscription
   */
  type: 'Query' | 'Mutation' | 'Subscription';
  requestSchema?: any;
  requestSample?: any;
  requestTypeName?: string;
  responseSchema?: any;
  responseSample?: any;
  responseTypeName?: string;
  argTypeMap?: {
    [k: string]: any;
  };
  path: string;
  /**
   * Allowed values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH
   */
  method?: 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'PATCH';
  headers?: {
    [k: string]: any;
  };
  /**
   * If true, this operation cannot have requestSchema or requestSample
   * And the request body will be passed as binary with its mime type
   * unless you define an explicit Content-Type header
   */
  binary?: boolean;
}
export interface JsonSchemaPubSubOperation {
  field: string;
  description?: string;
  /**
   * Allowed values: Query, Mutation, Subscription
   */
  type: 'Query' | 'Mutation' | 'Subscription';
  requestSchema?: any;
  requestSample?: any;
  requestTypeName?: string;
  responseSchema?: any;
  responseSample?: any;
  responseTypeName?: string;
  argTypeMap?: {
    [k: string]: any;
  };
  pubsubTopic: string;
}
export interface MongooseHandler {
  connectionString?: string;
  models?: MongooseModel[];
  discriminators?: MongooseModel[];
  /**
   * Enable Automatic Type Merging/Federation support
   */
  autoTypeMerging?: boolean;
}
export interface MongooseModel {
  name: string;
  path: string;
  options?: ComposeWithMongooseOpts;
}
export interface ComposeWithMongooseOpts {
  name?: string;
  description?: string;
  fields?: ComposeWithMongooseFieldsOpts;
  inputType?: ComposeMongooseInputType;
  resolvers?: TypeConverterResolversOpts1;
}
export interface ComposeWithMongooseFieldsOpts {
  only?: string[];
  remove?: string[];
  required?: string[];
}
export interface ComposeMongooseInputType {
  name?: string;
  description?: string;
  fields?: ComposeWithMongooseFieldsOpts1;
  resolvers?: TypeConverterResolversOpts;
}
export interface ComposeWithMongooseFieldsOpts1 {
  only?: string[];
  remove?: string[];
  required?: string[];
}
export interface TypeConverterResolversOpts {
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findByIds?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  count?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, JSON
   */
  connection?:
    | boolean
    | {
        [k: string]: any;
      };
  /**
   * Any of: Boolean, PaginationResolverOpts
   */
  pagination?: boolean | PaginationResolverOpts;
}
export interface ComposeWithMongooseResolverOpts {
  filter?: FilterHelperArgsOpts;
  sort?: SortHelperArgsOpts;
  limit?: LimitHelperArgsOpts;
  record?: RecordHelperArgsOpts;
  skip?: boolean;
}
export interface FilterHelperArgsOpts {
  filterTypeName?: string;
  isRequired?: boolean;
  onlyIndexed?: boolean;
  requiredFields?: string[];
  /**
   * Any of: Boolean, JSON
   */
  operators?:
    | boolean
    | {
        [k: string]: any;
      };
  removeFields?: string[];
}
export interface SortHelperArgsOpts {
  sortTypeName?: string;
}
export interface LimitHelperArgsOpts {
  defaultValue?: number;
}
export interface RecordHelperArgsOpts {
  recordTypeName?: string;
  isRequired?: boolean;
  removeFields?: string[];
  requiredFields?: string[];
}
export interface PaginationResolverOpts {
  perPage?: number;
}
export interface TypeConverterResolversOpts1 {
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findByIds?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  count?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, JSON
   */
  connection?:
    | boolean
    | {
        [k: string]: any;
      };
  /**
   * Any of: Boolean, PaginationResolverOpts
   */
  pagination?: boolean | PaginationResolverOpts;
}
export interface MySQLHandler {
  host?: string;
  port?: number;
  user?: string;
  password?: string;
  database?: string;
  /**
   * Use existing `Pool` instance
   * Format: modulePath#exportName
   */
  pool?: any;
  /**
   * Use specific tables for your schema
   */
  tables?: string[];
  /**
   * Use specific fields of specific tables
   */
  tableFields?: TableField[];
}
export interface TableField {
  table: string;
  fields: string[];
}
/**
 * Handler for Neo4j
 */
export interface Neo4JHandler {
  /**
   * URL for the Neo4j Instance e.g. neo4j://localhost
   */
  url: string;
  /**
   * Username for basic authentication
   */
  username: string;
  /**
   * Password for basic authentication
   */
  password: string;
  /**
   * Specifies whether relationships should always be included in the type definitions as [relationship](https://grandstack.io/docs/neo4j-graphql-js.html#relationship-types) types, even if the relationships do not have properties.
   */
  alwaysIncludeRelationships?: boolean;
  /**
   * Specifies database name
   */
  database?: string;
  /**
   * Provide GraphQL Type Definitions instead of inferring
   */
  typeDefs?: string;
}
/**
 * Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it.
 */
export interface NewOpenapiHandler {
  oasFilePath: string;
  baseUrl?: string;
  schemaHeaders?: {
    [k: string]: any;
  };
  operationHeaders?: {
    [k: string]: any;
  };
  ignoreErrorResponses?: boolean;
  selectQueryOrMutationField?: OASSelectQueryOrMutationFieldConfig[];
}
export interface OASSelectQueryOrMutationFieldConfig {
  /**
   * Allowed values: query, mutation, Query, Mutation
   */
  type: 'query' | 'mutation' | 'Query' | 'Mutation';
  fieldName: string;
}
/**
 * Handler for OData
 */
export interface ODataHandler {
  /**
   * Base URL for OData API
   */
  baseUrl: string;
  /**
   * Custom $metadata File or URL
   */
  metadata?: string;
  /**
   * Headers to be used with the operation requests
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Headers to be used with the $metadata requests
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Enable batching (Allowed values: multipart, json)
   */
  batch?: 'multipart' | 'json';
  /**
   * Use $expand for navigation props instead of seperate HTTP requests (Default: false)
   */
  expandNavProps?: boolean;
  /**
   * Custom Fetch
   */
  customFetch?: any;
}
/**
 * Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it.
 */
export interface OpenapiHandler {
  /**
   * A pointer to your API source - could be a local file, remote file or url endpoint
   */
  source: any;
  /**
   * Format of the source file (Allowed values: json, yaml)
   */
  sourceFormat?: 'json' | 'yaml';
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema.
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Specifies the URL on which all paths will be based on.
   * Overrides the server object in the OAS.
   */
  baseUrl?: string;
  /**
   * JSON object representing the query search parameters to add to the API calls
   */
  qs?: {
    [k: string]: any;
  };
  /**
   * W3 Compatible Fetch Implementation
   */
  customFetch?: any;
  /**
   * Include HTTP Response details to the result object
   */
  includeHttpDetails?: boolean;
  /**
   * Auto-generate a 'limit' argument for all fields that return lists of objects, including ones produced by links
   */
  addLimitArgument?: boolean;
  /**
   * Set argument name for mutation payload to 'requestBody'. If false, name defaults to camelCased pathname
   */
  genericPayloadArgName?: boolean;
  /**
   * Allows to explicitly override the default operation (Query or Mutation) for any OAS operation
   */
  selectQueryOrMutationField?: SelectQueryOrMutationFieldConfig[];
  /**
   * Overwrite automatic wrapping of errors into GraphqlErrors
   */
  provideErrorExtensions?: boolean;
  /**
   * Field names can only be sanitized operationIds
   *
   * By default, query field names are based on the return type type name and mutation field names are based on the operationId, which may be generated if it does not exist.
   *
   * This option forces OpenAPI handler to only create field names based on the operationId.
   */
  operationIdFieldNames?: boolean;
}
export interface SelectQueryOrMutationFieldConfig {
  /**
   * OAS Title
   */
  title?: string;
  /**
   * Operation Path
   */
  path?: string;
  /**
   * Target Root Type for this operation (Allowed values: query, mutation, Query, Mutation)
   */
  type?: 'query' | 'mutation' | 'Query' | 'Mutation';
  /**
   * Which method is used for this operation
   */
  method?: string;
}
/**
 * Handler for Postgres database, based on `postgraphile`
 */
export interface PostGraphileHandler {
  /**
   * A connection string to your Postgres database
   */
  connectionString?: string;
  /**
   * An array of strings which specifies the PostgreSQL schemas that PostGraphile will use to create a GraphQL schema. The default schema is the public schema.
   */
  schemaName?: string[];
  /**
   * Connection Pool instance or settings or you can provide the path of a code file that exports any of those
   */
  pool?: any;
  /**
   * Extra Postgraphile Plugins to append
   */
  appendPlugins?: string[];
  /**
   * Postgraphile Plugins to skip (e.g. "graphile-build#NodePlugin")
   */
  skipPlugins?: string[];
  /**
   * Extra Postgraphile options that will be added to the postgraphile constructor. It can either be an object or a string pointing to the object's path (e.g. "./my-config#options"). See the [postgraphile docs](https://www.graphile.org/postgraphile/usage-library/) for more information. (Any of: JSON, String)
   */
  options?:
    | {
        [k: string]: any;
      }
    | string;
  /**
   * Enable GraphQL websocket transport support for subscriptions (default: true)
   */
  subscriptions?: boolean;
  /**
   * Enables live-query support via GraphQL subscriptions (sends updated payload any time nested collections/records change) (default: true)
   */
  live?: boolean;
}
export interface RAMLHandler {
  ramlFilePath: string;
  baseUrl?: string;
  schemaHeaders?: {
    [k: string]: any;
  };
  operationHeaders?: {
    [k: string]: any;
  };
  ignoreErrorResponses?: boolean;
  selectQueryOrMutationField?: RAMLSelectQueryOrMutationFieldConfig[];
}
export interface RAMLSelectQueryOrMutationFieldConfig {
  /**
   * Allowed values: query, mutation, Query, Mutation
   */
  type: 'query' | 'mutation' | 'Query' | 'Mutation';
  fieldName: string;
}
/**
 * Handler for SOAP
 */
export interface SoapHandler {
  /**
   * A url to your WSDL
   */
  wsdl: string;
  basicAuth?: SoapSecurityBasicAuthConfig;
  securityCert?: SoapSecurityCertificateConfig;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for schema introspection
   * You can also provide `.js` or `.ts` file path that exports schemaHeaders as an object
   */
  schemaHeaders?: any;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * If true, the ports defined in the WSDL will be represented as GraphQL-Type objects in the schema.
   * The fields of the object will be the operations of the port.
   *
   * Most soap-endpoints only define one port; so including it in the schema will just be inconvenient.
   * But if there are multiple ports with operations of the same name, you should set this option to true.
   * Otherwise only one of the identical-named operations will be callable.
   *
   * default: false
   */
  includePorts?: boolean;
  /**
   * If true, the services defined in the WSDL will be represented as GraphQL-Type objects in the schema.
   * The fields of the object will be the ports of the service (or the operation, dependent on 'includePorts').
   *
   * Most soap-endpoints only define one service; so including it in the schema will just be inconvenient.
   * But if there are multiple services with operations of the same name, you should set this option to true.
   * Otherwise only one of the identical-named operations will be callable.
   *
   * default: false
   */
  includeServices?: boolean;
  /**
   * Allows to explicitly override the default operation (Query or Mutation) for any SOAP operation
   */
  selectQueryOrMutationField?: SoapSelectQueryOrMutationFieldConfig[];
  /**
   * Automatically put operations starts with `query` or `get` into the Query type
   */
  selectQueryOperationsAuto?: boolean;
}
/**
 * Basic Authentication Configuration
 * Including username and password fields
 */
export interface SoapSecurityBasicAuthConfig {
  /**
   * Username for Basic Authentication
   */
  username: string;
  /**
   * Password for Basic Authentication
   */
  password: string;
}
/**
 * SSL Certificate Based Authentication Configuration
 * Including public key, private key and password fields
 */
export interface SoapSecurityCertificateConfig {
  /**
   * Your public key
   */
  publicKey?: string;
  /**
   * Your private key
   */
  privateKey?: string;
  /**
   * Password
   */
  password?: string;
  /**
   * Path to the file or URL contains your public key
   */
  publicKeyPath?: string;
  /**
   * Path to the file or URL contains your private key
   */
  privateKeyPath?: string;
  /**
   * Path to the file or URL contains your password
   */
  passwordPath?: string;
}
export interface SoapSelectQueryOrMutationFieldConfig {
  service: string;
  port: string;
  operation: string;
  /**
   * Allowed values: query, mutation
   */
  type: 'query' | 'mutation';
}
/**
 * Handler for OData
 */
export interface ThriftHandler {
  /**
   * The name of the host to connect to.
   */
  hostName: string;
  /**
   * The port number to attach to on the host.
   */
  port: number;
  /**
   * The path on which the Thrift service is listening. Defaults to '/thrift'.
   */
  path?: string;
  /**
   * Boolean value indicating whether to use https. Defaults to false.
   */
  https?: boolean;
  /**
   * Name of the Thrift protocol type to use. Defaults to 'binary'. (Allowed values: binary, compact, json)
   */
  protocol?: 'binary' | 'compact' | 'json';
  /**
   * The name of your service. Used for logging.
   */
  serviceName: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema.
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Path to IDL file
   */
  idl: string;
}
/**
 * Handler for SQLite database, based on `tuql`
 */
export interface TuqlHandler {
  /**
   * Pointer to your SQLite database
   */
  db?: string;
  /**
   * Path to the SQL Dump file if you want to build a in-memory database
   */
  infile?: string;
}
export interface Transform {
  /**
   * Transformer to apply caching for your data sources
   */
  cache?: CacheTransformConfig[];
  encapsulate?: EncapsulateTransformObject;
  extend?: ExtendTransform;
  federation?: FederationTransform;
  /**
   * Transformer to filter (white/black list) GraphQL types, fields and arguments (Any of: FilterSchemaTransform, Any)
   */
  filterSchema?: FilterSchemaTransform | any;
  mock?: MockingConfig;
  namingConvention?: NamingConventionTransformConfig;
  prefix?: PrefixTransformConfig;
  /**
   * Transformer to rename GraphQL types and fields (Any of: RenameTransform, Any)
   */
  rename?: RenameTransform | any;
  replaceField?: ReplaceFieldTransformConfig;
  /**
   * Transformer to apply composition to resolvers (Any of: ResolversCompositionTransform, Any)
   */
  resolversComposition?: ResolversCompositionTransform | any;
  snapshot?: SnapshotTransformConfig;
  typeMerging?: TypeMergingConfig;
  [k: string]: any;
}
export interface CacheTransformConfig {
  /**
   * The type and field to apply cache to, you can use wild cards as well, for example: `Query.*`
   */
  field: string;
  /**
   * Cache key to use to store your resolvers responses.
   * The defualt is: {typeName}-{fieldName}-{argsHash}-{fieldNamesHash}
   *
   * Available variables:
   * - {args.argName} - use resolver argument
   * - {typeName} - use name of the type
   * - {fieldName} - use name of the field
   * - {argsHash} - a hash based on the 'args' object
   * - {fieldNamesHash} - a hash based on the field names selected by the client
   * - {info} - the GraphQLResolveInfo of the resolver
   *
   * Available interpolations:
   * - {format|date} - returns the current date with a specific format
   */
  cacheKey?: string;
  invalidate?: CacheInvalidateConfig;
}
/**
 * Invalidation rules
 */
export interface CacheInvalidateConfig {
  /**
   * Invalidate the cache when a specific operation is done without an error
   */
  effectingOperations?: CacheEffectingOperationConfig[];
  /**
   * Specified in seconds, the time-to-live (TTL) value limits the lifespan
   */
  ttl?: number;
}
export interface CacheEffectingOperationConfig {
  /**
   * Path to the operation that could effect it. In a form: Mutation.something. Note that wildcard is not supported in this field.
   */
  operation: string;
  /**
   * Cache key to invalidate on sucessful resolver (no error), see `cacheKey` for list of available options in this field.
   */
  matchKey?: string;
}
/**
 * Transformer to apply encapsulation to the API source, by creating a field for it under the root query
 */
export interface EncapsulateTransformObject {
  /**
   * Optional, name to use for grouping under the root types. If not specific, the API name is used.
   */
  name?: string;
  applyTo?: EncapsulateTransformApplyTo;
}
/**
 * Allow you to choose which root operations you would like to apply. By default, it's applied to all root types.
 */
export interface EncapsulateTransformApplyTo {
  query?: boolean;
  mutation?: boolean;
  subscription?: boolean;
}
export interface ExtendTransform {
  typeDefs?: any;
  resolvers?: any;
}
export interface FederationTransform {
  types?: FederationTransformType[];
}
export interface FederationTransformType {
  name: string;
  config?: FederationObjectConfig;
}
export interface FederationObjectConfig {
  keyFields?: string[];
  extend?: boolean;
  fields?: FederationField[];
  /**
   * Any of: String, ResolveReferenceObject
   */
  resolveReference?: string | ResolveReferenceObject;
}
export interface FederationField {
  name: string;
  config: FederationFieldConfig;
}
export interface FederationFieldConfig {
  external?: boolean;
  provides?: string;
  requires?: string;
}
export interface ResolveReferenceObject {
  /**
   * Name of root field name that resolves the reference
   */
  queryFieldName: string;
  /**
   * If the root field name has multiple args,
   * you need to define which argument should receive the key
   */
  keyArg?: string;
}
export interface FilterSchemaTransform {
  /**
   * Specify to apply filter-schema transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of filter rules
   */
  filters: string[];
}
/**
 * Mock configuration for your source
 */
export interface MockingConfig {
  /**
   * If this expression is truthy, mocking would be enabled
   * You can use environment variables expression, for example: `${MOCKING_ENABLED}`
   */
  if?: boolean;
  /**
   * Do not mock any other resolvers other than defined in `mocks`.
   * For example, you can enable this if you don't want to mock entire schema but partially.
   */
  preserveResolvers?: boolean;
  /**
   * Mock configurations
   */
  mocks?: MockingFieldConfig[];
  /**
   * The path to the code runs before the store is attached to the schema
   */
  initializeStore?: any;
}
export interface MockingFieldConfig {
  /**
   * Resolver path
   * Example: User.firstName
   */
  apply: string;
  /**
   * If this expression is truthy, mocking would be enabled
   * You can use environment variables expression, for example: `${MOCKING_ENABLED}`
   */
  if?: boolean;
  /**
   * Faker.js expression or function
   * Read more (https://github.com/marak/Faker.js/#fakerfake)
   * Example;
   * faker: name.firstName
   * faker: "{{ name.firstName }} {{ name.lastName }}"
   */
  faker?: string;
  /**
   * Custom mocking
   * It can be a module or json file.
   * Both "moduleName#exportName" or only "moduleName" would work
   */
  custom?: string;
  /**
   * Length of the mock list
   * For the list types `[ObjectType]`, how many `ObjectType` you want to return?
   * default: 2
   */
  length?: number;
  store?: GetFromMockStoreConfig;
  /**
   * Update the data on the mock store
   */
  updateStore?: UpdateMockStoreConfig[];
}
/**
 * Get the data from the mock store
 */
export interface GetFromMockStoreConfig {
  type?: string;
  key?: string;
  fieldName?: string;
}
export interface UpdateMockStoreConfig {
  type?: string;
  key?: string;
  fieldName?: string;
  value?: string;
}
/**
 * Transformer to apply naming convention to GraphQL Types
 */
export interface NamingConventionTransformConfig {
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  typeNames?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  fieldNames?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  enumValues?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
}
/**
 * Prefix transform
 */
export interface PrefixTransformConfig {
  /**
   * Specify to apply prefix transform to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * The prefix to apply to the schema types. By default it's the API name.
   */
  value?: string;
  /**
   * List of ignored types
   */
  ignore?: string[];
  /**
   * Changes root types and changes the field names (default: false)
   */
  includeRootOperations?: boolean;
  /**
   * Changes types (default: true)
   */
  includeTypes?: boolean;
}
export interface RenameTransform {
  /**
   * Specify to apply rename transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of rename rules
   */
  renames: RenameTransformObject[];
}
export interface RenameTransformObject {
  from: RenameConfig;
  to: RenameConfig1;
  /**
   * Use Regular Expression for type names
   */
  useRegExpForTypes?: boolean;
  /**
   * Use Regular Expression for field names
   */
  useRegExpForFields?: boolean;
  /**
   * Flags to use in the Regular Expression
   */
  regExpFlags?: string;
}
export interface RenameConfig {
  type?: string;
  field?: string;
}
export interface RenameConfig1 {
  type?: string;
  field?: string;
}
/**
 * Transformer to replace GraphQL field with partial of full config from a different field
 */
export interface ReplaceFieldTransformConfig {
  /**
   * Additional type definition to used to replace field types
   */
  typeDefs?: any;
  /**
   * Array of rules to replace fields
   */
  replacements: ReplaceFieldTransformObject[];
}
export interface ReplaceFieldTransformObject {
  from: ReplaceFieldConfig;
  to: ReplaceFieldConfig1;
  /**
   * Allowed values: config, hoistValue
   */
  scope?: 'config' | 'hoistValue';
  composer?: any;
  name?: string;
}
export interface ReplaceFieldConfig {
  type: string;
  field: string;
}
export interface ReplaceFieldConfig1 {
  type: string;
  field: string;
}
export interface ResolversCompositionTransform {
  /**
   * Specify to apply resolvers-composition transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of resolver/composer to apply
   */
  compositions: ResolversCompositionTransformObject[];
}
export interface ResolversCompositionTransformObject {
  /**
   * The GraphQL Resolver path
   * Example: Query.users
   */
  resolver: string;
  /**
   * Path to the composer function
   * Example: ./src/auth.js#authComposer
   */
  composer: any;
}
/**
 * Configuration for Snapshot extension
 */
export interface SnapshotTransformConfig {
  /**
   * Expression for when to activate this extension.
   * Value can be a valid JS expression string or a boolean (Any of: String, Boolean)
   */
  if?: string | boolean;
  /**
   * Resolver to be applied
   * For example;
   *   apply:
   *       - Query.* <- * will apply this extension to all fields of Query type
   *       - Mutation.someMutationButProbablyYouWontNeedIt
   */
  apply: string[];
  /**
   * Path to the directory of the generated snapshot files
   */
  outputDir: string;
  /**
   * Take snapshots by respecting the requested selection set.
   * This might be needed for the handlers like Postgraphile or OData that rely on the incoming GraphQL operation.
   */
  respectSelectionSet?: boolean;
}
/**
 * [Type Merging](https://www.graphql-tools.com/docs/stitch-type-merging) Configuration
 */
export interface TypeMergingConfig {
  types?: MergedTypeConfig[];
  /**
   * Denotes a root field used to query a merged type across services.
   * The marked field's name is analogous
   * to the fieldName setting in
   * [merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example),
   * while the field's arguments and return type are used to infer merge configuration.
   * Directive arguments tune the merge behavior
   */
  queryFields?: MergedRootFieldConfig[];
  /**
   * The path to a code file that has additional type merging configuration
   */
  additionalConfiguration?: any;
}
export interface MergedTypeConfig {
  /**
   * Name of the type (Query by default)
   */
  typeName?: string;
  key?: KeyAnnotation;
  /**
   * Specifies types and fields
   * that provide a [canonical definition](https://www.graphql-tools.com/docs/stitch-type-merging#canonical-definitions) to be built into the gateway schema. Useful for selecting preferred characteristics among types and fields that overlap across subschemas. Root fields marked as canonical specify which subschema the field proxies for new queries entering the graph.
   */
  canonical?: boolean;
  fields?: MergedTypeField[];
}
/**
 * Specifies a base selection set needed to merge the annotated type across subschemas.
 * Analogous to the `selectionSet` setting specified in [merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example).
 */
export interface KeyAnnotation {
  selectionSet: string;
}
export interface MergedTypeField {
  fieldName: string;
  computed?: ComputedAnnotation;
}
/**
 * specifies a selection of fields required from other services to compute the value of this field.
 * These additional fields are only selected when the computed field is requested.
 * Analogous to [computed field](https://www.graphql-tools.com/docs/stitch-type-merging#computed-fields) in merged type configuration.
 * Computed field dependencies must be sent into the subservice using an [object key](https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys).
 */
export interface ComputedAnnotation {
  selectionSet: string;
}
export interface MergedRootFieldConfig {
  queryFieldName: string;
  /**
   * Specifies the name of a field to pick off origin objects as the key value. When omitted, a `@key` directive must be included on the return type's definition to be built into an object key.
   * https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys
   */
  keyField?: string;
  /**
   * Specifies which field argument receives the merge key. This may be omitted for fields with only one argument where the recipient can be inferred.
   */
  keyArg?: string;
  /**
   * Specifies a string of additional keys and values to apply to other arguments,
   * formatted as `\"\"\" arg1: "value", arg2: "value" \"\"\"`.
   */
  additionalArgs?: string;
  /**
   * Advanced use only; Allows building a custom key just for the argument from the selectionSet included by the `@key` directive.
   */
  key?: string[];
  /**
   * Advanced use only; This argument specifies a string expression that allows more customization of the input arguments. Rules for evaluation of this argument are as follows:
   *   - basic object parsing of the input key: `"arg1: $key.arg1, arg2: $key.arg2"`
   *   - any expression enclosed by double brackets will be evaluated once for each of the requested keys, and then sent as a list: `"input: { keys: [[$key]] }"`
   *   - selections from the key can be referenced by using the $ sign and dot notation: `"upcs: [[$key.upc]]"`, so that `$key.upc` refers to the `upc` field of the key.
   */
  argsExpr?: string;
}
export interface AdditionalStitchingResolverObject {
  sourceName: string;
  sourceTypeName: string;
  sourceFieldName: string;
  sourceSelectionSet?: string;
  requiredSelectionSet?: string;
  sourceArgs?: {
    [k: string]: any;
  };
  targetTypeName: string;
  targetFieldName: string;
  /**
   * Extract specific property from the result
   */
  result?: string;
  /**
   * If return types don't match,
   * you can specify a result type to apply inline fragment
   */
  resultType?: string;
}
export interface AdditionalStitchingBatchResolverObject {
  sourceName: string;
  sourceTypeName: string;
  sourceFieldName: string;
  sourceSelectionSet?: string;
  requiredSelectionSet?: string;
  keyField: string;
  keysArg: string;
  additionalArgs?: {
    [k: string]: any;
  };
  targetTypeName: string;
  targetFieldName: string;
  /**
   * Extract specific property from the result
   */
  result?: string;
  /**
   * If return types don't match,
   * you can specify a result type to apply inline fragment
   */
  resultType?: string;
}
export interface AdditionalSubscriptionObject {
  targetTypeName: string;
  targetFieldName: string;
  pubsubTopic: string;
  result?: string;
  filterBy?: string;
}
/**
 * Backend cache
 */
export interface Cache {
  file?: FileCacheConfig;
  inmemoryLRU?: InMemoryLRUConfig;
  localforage?: LocalforageConfig;
  redis?: RedisConfig;
  [k: string]: any;
}
export interface FileCacheConfig {
  path?: string;
}
export interface InMemoryLRUConfig {
  max?: number;
}
export interface LocalforageConfig {
  /**
   * Allowed values: WEBSQL, INDEXEDDB, LOCALSTORAGE
   */
  driver?: ('WEBSQL' | 'INDEXEDDB' | 'LOCALSTORAGE')[];
  name?: string;
  version?: number;
  size?: number;
  storeName?: string;
  description?: string;
}
export interface RedisConfig {
  host?: string;
  port?: string;
  password?: string;
  url?: string;
}
export interface PubSubConfig {
  name: string;
  config?: any;
}
export interface LiveQueryInvalidation {
  field: string;
  invalidate: string[];
}
