{
  "definitions": {
    "Cache": {
      "additionalProperties": true,
      "type": "object",
      "title": "Cache",
      "properties": {
        "file": {
          "$ref": "#/definitions/FileCacheConfig"
        },
        "inmemoryLRU": {
          "$ref": "#/definitions/InMemoryLRUConfig"
        },
        "localforage": {
          "$ref": "#/definitions/LocalforageConfig"
        },
        "redis": {
          "$ref": "#/definitions/RedisConfig"
        }
      }
    },
    "FileCacheConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "FileCacheConfig",
      "properties": {
        "path": {
          "type": "string"
        }
      }
    },
    "InMemoryLRUConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "InMemoryLRUConfig",
      "properties": {
        "max": {
          "type": "integer"
        }
      }
    },
    "LocalforageConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "LocalforageConfig",
      "properties": {
        "driver": {
          "type": "array",
          "items": {
            "type": "string",
            "enum": ["WEBSQL", "INDEXEDDB", "LOCALSTORAGE"],
            "description": "Allowed values: WEBSQL, INDEXEDDB, LOCALSTORAGE"
          },
          "additionalItems": false,
          "description": "Allowed values: WEBSQL, INDEXEDDB, LOCALSTORAGE"
        },
        "name": {
          "type": "string"
        },
        "version": {
          "type": "number"
        },
        "size": {
          "type": "integer"
        },
        "storeName": {
          "type": "string"
        },
        "description": {
          "type": "string"
        }
      }
    },
    "RedisConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "RedisConfig",
      "properties": {
        "host": {
          "type": "string"
        },
        "port": {
          "type": "string"
        },
        "password": {
          "type": "string"
        },
        "url": {
          "type": "string"
        }
      }
    },
    "ServeConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "ServeConfig",
      "properties": {
        "fork": {
          "description": "Spawn multiple server instances as node clusters (default: `1`) (Any of: Int, Boolean)",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "port": {
          "description": "TCP Port to listen (default: `3000`) (Any of: Int, String)",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "hostname": {
          "type": "string",
          "description": "The binding hostname (default: `localhost`)"
        },
        "cors": {
          "$ref": "#/definitions/CorsConfig",
          "description": "Configuration for CORS"
        },
        "handlers": {
          "type": "array",
          "items": {
            "description": "Any of: WebhookHandler, ExpressHandler",
            "anyOf": [
              {
                "$ref": "#/definitions/WebhookHandler"
              },
              {
                "$ref": "#/definitions/ExpressHandler"
              }
            ]
          },
          "additionalItems": false,
          "description": "Express/Connect compatible handlers and middlewares extend GraphQL Mesh HTTP Server (Any of: WebhookHandler, ExpressHandler)"
        },
        "staticFiles": {
          "type": "string",
          "description": "Path to your static files you want to be served with GraphQL Mesh HTTP Server"
        },
        "playground": {
          "type": "boolean",
          "description": "Show GraphiQL Playground"
        },
        "maxRequestBodySize": {
          "description": "Controls the maximum request body size. If this is a number, then the value specifies the number of bytes; if it is a string, the value is passed to the bytes library for parsing. Defaults to '100kb'. (Any of: Int, String)",
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "string"
            }
          ]
        },
        "upload": {
          "$ref": "#/definitions/UploadOptions",
          "description": "Configuration for GraphQL File Upload"
        },
        "sslCredentials": {
          "$ref": "#/definitions/HTTPSConfig",
          "description": "SSL Credentials for HTTPS Server\nIf this is provided, Mesh will be served via HTTPS"
        },
        "endpoint": {
          "type": "string",
          "description": "Path to GraphQL Endpoint (default: /graphql)"
        },
        "browser": {
          "description": "Path to the browser that will be used by `mesh serve` to open a playground window in development mode\nThis feature can be disable by passing `false` (Any of: String, Boolean)",
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "customServerHandler": {
          "type": "string",
          "description": "If you want to use a custom GraphQL server, you can pass the path of the code file that exports a custom Mesh Server Handler\nWith a custom server handler, you won't be able to use the features of GraphQL Mesh HTTP Server"
        }
      }
    },
    "CorsConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "CorsConfig",
      "properties": {
        "origin": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "allowedHeaders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "exposedHeaders": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "credentials": {
          "type": "boolean"
        },
        "maxAge": {
          "type": "integer"
        },
        "preflightContinue": {
          "type": "boolean"
        },
        "optionsSuccessStatus": {
          "type": "integer"
        }
      }
    },
    "ExpressHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "ExpressHandler",
      "properties": {
        "path": {
          "type": "string",
          "description": "Path that the handler will control"
        },
        "handler": {
          "type": "string",
          "description": "Path of the handler's code"
        },
        "method": {
          "type": "string",
          "enum": ["GET", "POST", "DELETE", "PATCH"],
          "description": "HTTP Method that the handler will control (Allowed values: GET, POST, DELETE, PATCH)"
        }
      },
      "required": ["path", "handler"]
    },
    "WebhookHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "WebhookHandler",
      "properties": {
        "path": {
          "type": "string",
          "description": "Path that remote API will ping"
        },
        "method": {
          "type": "string",
          "enum": ["GET", "POST", "DELETE", "PATCH"],
          "description": "HTTP Method that the handler will control (Allowed values: GET, POST, DELETE, PATCH)"
        },
        "pubsubTopic": {
          "type": "string",
          "description": "Name of the topic you want to pass incoming payload"
        },
        "payload": {
          "type": "string",
          "description": "Part of the object you want to pass (e.g. `data.messages`)"
        }
      },
      "required": ["path", "pubsubTopic"]
    },
    "UploadOptions": {
      "additionalProperties": false,
      "type": "object",
      "title": "UploadOptions",
      "properties": {
        "maxFileSize": {
          "type": "integer",
          "description": "Maximum File Size for GraphQL Upload (default: `100000000`)"
        },
        "maxFiles": {
          "type": "integer",
          "description": "Maximum number of files for GraphQL Upload (default: `10`)"
        }
      }
    },
    "HTTPSConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "HTTPSConfig",
      "properties": {
        "key": {
          "type": "string"
        },
        "cert": {
          "type": "string"
        }
      },
      "required": ["key", "cert"]
    },
    "SDKConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SDKConfig",
      "properties": {
        "generateOperations": {
          "$ref": "#/definitions/GenerateOperationsConfig",
          "description": "Use this only if you don't want to use `documents` for SDK,\nand let Mesh generate them for you"
        }
      }
    },
    "GenerateOperationsConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "GenerateOperationsConfig",
      "properties": {
        "selectionSetDepth": {
          "type": "integer"
        }
      }
    },
    "Source": {
      "additionalProperties": false,
      "type": "object",
      "title": "Source",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name you wish to set to your remote API, this will be used for building the GraphQL context"
        },
        "handler": {
          "$ref": "#/definitions/Handler",
          "description": "Point to the handler you wish to use, it can either be a predefined handler, or a custom"
        },
        "transforms": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Transform"
          },
          "additionalItems": false,
          "description": "List of transforms to apply to the current API source, before unifying it with the rest of the sources"
        }
      },
      "required": ["name", "handler"]
    },
    "Transform": {
      "additionalProperties": true,
      "type": "object",
      "title": "Transform",
      "properties": {
        "cache": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CacheTransformConfig"
          },
          "additionalItems": false,
          "description": "Transformer to apply caching for your data sources"
        },
        "encapsulate": {
          "$ref": "#/definitions/EncapsulateTransformObject",
          "description": "Transformer to apply encapsulation to the API source, by creating a field for it under the root query"
        },
        "extend": {
          "$ref": "#/definitions/ExtendTransform"
        },
        "federation": {
          "$ref": "#/definitions/FederationTransform"
        },
        "filterSchema": {
          "description": "Transformer to filter (white/black list) GraphQL types, fields and arguments (Any of: FilterSchemaTransform, Any)",
          "anyOf": [
            {
              "$ref": "#/definitions/FilterSchemaTransform"
            },
            {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "additionalItems": true
                }
              ]
            }
          ]
        },
        "mock": {
          "$ref": "#/definitions/MockingConfig",
          "description": "Mock configuration for your source"
        },
        "namingConvention": {
          "$ref": "#/definitions/NamingConventionTransformConfig",
          "description": "Transformer to apply naming convention to GraphQL Types"
        },
        "prefix": {
          "$ref": "#/definitions/PrefixTransformConfig",
          "description": "Prefix transform"
        },
        "rename": {
          "description": "Transformer to rename GraphQL types and fields (Any of: RenameTransform, Any)",
          "anyOf": [
            {
              "$ref": "#/definitions/RenameTransform"
            },
            {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "additionalItems": true
                }
              ]
            }
          ]
        },
        "replaceField": {
          "$ref": "#/definitions/ReplaceFieldTransformConfig",
          "description": "Transformer to replace GraphQL field with partial of full config from a different field"
        },
        "resolversComposition": {
          "description": "Transformer to apply composition to resolvers (Any of: ResolversCompositionTransform, Any)",
          "anyOf": [
            {
              "$ref": "#/definitions/ResolversCompositionTransform"
            },
            {
              "anyOf": [
                {
                  "type": "object",
                  "additionalProperties": true
                },
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "additionalItems": true
                }
              ]
            }
          ]
        },
        "snapshot": {
          "$ref": "#/definitions/SnapshotTransformConfig",
          "description": "Configuration for Snapshot extension"
        },
        "typeMerging": {
          "$ref": "#/definitions/TypeMergingConfig",
          "description": "[Type Merging](https://www.graphql-tools.com/docs/stitch-type-merging) Configuration"
        }
      }
    },
    "Handler": {
      "additionalProperties": true,
      "type": "object",
      "title": "Handler",
      "properties": {
        "graphql": {
          "$ref": "#/definitions/GraphQLHandler",
          "description": "Handler for remote/local/third-party GraphQL schema"
        },
        "grpc": {
          "$ref": "#/definitions/GrpcHandler",
          "description": "Handler for gRPC and Protobuf schemas"
        },
        "JsonSchema": {
          "$ref": "#/definitions/JsonSchemaHandler",
          "description": "Handler for JSON Schema specification. Source could be a local json file, or a url to it."
        },
        "mongoose": {
          "$ref": "#/definitions/MongooseHandler"
        },
        "mysql": {
          "$ref": "#/definitions/MySQLHandler"
        },
        "neo4j": {
          "$ref": "#/definitions/Neo4jHandler",
          "description": "Handler for Neo4j"
        },
        "newOpenapi": {
          "$ref": "#/definitions/NewOpenapiHandler",
          "description": "Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it."
        },
        "odata": {
          "$ref": "#/definitions/ODataHandler",
          "description": "Handler for OData"
        },
        "openapi": {
          "$ref": "#/definitions/OpenapiHandler",
          "description": "Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it."
        },
        "postgraphile": {
          "$ref": "#/definitions/PostGraphileHandler",
          "description": "Handler for Postgres database, based on `postgraphile`"
        },
        "raml": {
          "$ref": "#/definitions/RAMLHandler"
        },
        "soap": {
          "$ref": "#/definitions/SoapHandler",
          "description": "Handler for SOAP"
        },
        "thrift": {
          "$ref": "#/definitions/ThriftHandler",
          "description": "Handler for OData"
        },
        "tuql": {
          "$ref": "#/definitions/TuqlHandler",
          "description": "Handler for SQLite database, based on `tuql`"
        }
      }
    },
    "AdditionalStitchingResolverObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "AdditionalStitchingResolverObject",
      "properties": {
        "sourceName": {
          "type": "string"
        },
        "sourceTypeName": {
          "type": "string"
        },
        "sourceFieldName": {
          "type": "string"
        },
        "sourceSelectionSet": {
          "type": "string"
        },
        "requiredSelectionSet": {
          "type": "string"
        },
        "sourceArgs": {
          "type": "object",
          "properties": {}
        },
        "targetTypeName": {
          "type": "string"
        },
        "targetFieldName": {
          "type": "string"
        },
        "result": {
          "type": "string",
          "description": "Extract specific property from the result"
        },
        "resultType": {
          "type": "string",
          "description": "If return types don't match,\nyou can specify a result type to apply inline fragment"
        }
      },
      "required": ["sourceName", "sourceTypeName", "sourceFieldName", "targetTypeName", "targetFieldName"]
    },
    "AdditionalStitchingBatchResolverObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "AdditionalStitchingBatchResolverObject",
      "properties": {
        "sourceName": {
          "type": "string"
        },
        "sourceTypeName": {
          "type": "string"
        },
        "sourceFieldName": {
          "type": "string"
        },
        "sourceSelectionSet": {
          "type": "string"
        },
        "requiredSelectionSet": {
          "type": "string"
        },
        "keyField": {
          "type": "string"
        },
        "keysArg": {
          "type": "string"
        },
        "additionalArgs": {
          "type": "object",
          "properties": {}
        },
        "targetTypeName": {
          "type": "string"
        },
        "targetFieldName": {
          "type": "string"
        },
        "result": {
          "type": "string",
          "description": "Extract specific property from the result"
        },
        "resultType": {
          "type": "string",
          "description": "If return types don't match,\nyou can specify a result type to apply inline fragment"
        }
      },
      "required": [
        "sourceName",
        "sourceTypeName",
        "sourceFieldName",
        "keyField",
        "keysArg",
        "targetTypeName",
        "targetFieldName"
      ]
    },
    "AdditionalSubscriptionObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "AdditionalSubscriptionObject",
      "properties": {
        "targetTypeName": {
          "type": "string"
        },
        "targetFieldName": {
          "type": "string"
        },
        "pubsubTopic": {
          "type": "string"
        },
        "result": {
          "type": "string"
        },
        "filterBy": {
          "type": "string"
        }
      },
      "required": ["targetTypeName", "targetFieldName", "pubsubTopic"]
    },
    "PubSubConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "PubSubConfig",
      "properties": {
        "name": {
          "type": "string"
        },
        "config": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        }
      },
      "required": ["name"]
    },
    "LiveQueryInvalidation": {
      "additionalProperties": false,
      "type": "object",
      "title": "LiveQueryInvalidation",
      "properties": {
        "field": {
          "type": "string"
        },
        "invalidate": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      },
      "required": ["field", "invalidate"]
    },
    "GraphQLHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "GraphQLHandler",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "A url or file path to your remote GraphQL endpoint.\nIf you provide a path to a code file(js or ts),\nother options will be ignored and the schema exported from the file will be used directly."
        },
        "schemaHeaders": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "JSON object representing the Headers to add to the runtime of the API calls only for schema introspection\nYou can also provide `.js` or `.ts` file path that exports schemaHeaders as an object"
        },
        "operationHeaders": {
          "type": "object",
          "properties": {},
          "description": "JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime"
        },
        "useGETForQueries": {
          "type": "boolean",
          "description": "Use HTTP GET for Query operations"
        },
        "method": {
          "type": "string",
          "enum": ["GET", "POST"],
          "description": "HTTP method used for GraphQL operations (Allowed values: GET, POST)"
        },
        "customFetch": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Path to a custom W3 Compatible Fetch Implementation"
        },
        "webSocketImpl": {
          "type": "string",
          "description": "Path to a custom W3 Compatible WebSocket Implementation"
        },
        "introspection": {
          "type": "string",
          "description": "Path to the introspection\nYou can seperately give schema introspection"
        },
        "multipart": {
          "type": "boolean",
          "description": "Enable multipart/formdata in order to support file uploads"
        },
        "batch": {
          "type": "boolean",
          "description": "Batch requests"
        },
        "subscriptionsProtocol": {
          "type": "string",
          "enum": ["SSE", "WS", "LEGACY_WS"],
          "description": "SSE - Server Sent Events\nWS - New graphql-ws\nLEGACY_WS - Legacy subscriptions-transport-ws (Allowed values: SSE, WS, LEGACY_WS)"
        }
      },
      "required": ["endpoint"]
    },
    "GrpcHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "GrpcHandler",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "gRPC Endpoint"
        },
        "protoFilePath": {
          "description": "gRPC Proto file that contains your protobuf schema (Any of: ProtoFilePath, String)",
          "anyOf": [
            {
              "$ref": "#/definitions/ProtoFilePath"
            },
            {
              "type": "string"
            }
          ]
        },
        "descriptorSetFilePath": {
          "description": "Use a binary-encoded or JSON file descriptor set file (Any of: ProtoFilePath, String)",
          "anyOf": [
            {
              "$ref": "#/definitions/ProtoFilePath"
            },
            {
              "type": "string"
            }
          ]
        },
        "requestTimeout": {
          "type": "integer",
          "description": "Request timeout in milliseconds\nDefault: 200000"
        },
        "credentialsSsl": {
          "$ref": "#/definitions/GrpcCredentialsSsl",
          "description": "SSL Credentials"
        },
        "useHTTPS": {
          "type": "boolean",
          "description": "Use https instead of http for gRPC connection"
        },
        "metaData": {
          "type": "object",
          "properties": {},
          "description": "MetaData"
        },
        "useReflection": {
          "type": "boolean",
          "description": "Use gRPC reflection to automatically gather the connection"
        }
      },
      "required": ["endpoint"]
    },
    "LoadOptions": {
      "additionalProperties": false,
      "type": "object",
      "title": "LoadOptions",
      "properties": {
        "defaults": {
          "type": "boolean"
        },
        "includeDirs": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      }
    },
    "ProtoFilePath": {
      "additionalProperties": false,
      "type": "object",
      "title": "ProtoFilePath",
      "properties": {
        "file": {
          "type": "string"
        },
        "load": {
          "$ref": "#/definitions/LoadOptions"
        }
      },
      "required": ["file"]
    },
    "GrpcCredentialsSsl": {
      "additionalProperties": false,
      "type": "object",
      "title": "GrpcCredentialsSsl",
      "properties": {
        "rootCA": {
          "type": "string"
        },
        "certChain": {
          "type": "string"
        },
        "privateKey": {
          "type": "string"
        }
      }
    },
    "JsonSchemaHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "JsonSchemaHandler",
      "properties": {
        "baseUrl": {
          "type": "string"
        },
        "operationHeaders": {
          "type": "object",
          "properties": {}
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {}
        },
        "operations": {
          "type": "array",
          "items": {
            "description": "Any of: JsonSchemaHTTPOperation, JsonSchemaPubSubOperation",
            "anyOf": [
              {
                "$ref": "#/definitions/JsonSchemaHTTPOperation"
              },
              {
                "$ref": "#/definitions/JsonSchemaPubSubOperation"
              }
            ]
          },
          "additionalItems": false,
          "description": "Any of: JsonSchemaHTTPOperation, JsonSchemaPubSubOperation"
        }
      },
      "required": ["operations"]
    },
    "JsonSchemaHTTPOperation": {
      "additionalProperties": false,
      "type": "object",
      "title": "JsonSchemaHTTPOperation",
      "properties": {
        "field": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": ["Query", "Mutation", "Subscription"],
          "description": "Allowed values: Query, Mutation, Subscription"
        },
        "requestSchema": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "requestSample": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "requestTypeName": {
          "type": "string"
        },
        "responseSchema": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "responseSample": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "responseTypeName": {
          "type": "string"
        },
        "argTypeMap": {
          "type": "object",
          "properties": {}
        },
        "path": {
          "type": "string"
        },
        "method": {
          "type": "string",
          "enum": ["GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"],
          "description": "Allowed values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH"
        },
        "headers": {
          "type": "object",
          "properties": {}
        },
        "binary": {
          "type": "boolean",
          "description": "If true, this operation cannot have requestSchema or requestSample\nAnd the request body will be passed as binary with its mime type\nunless you define an explicit Content-Type header"
        }
      },
      "required": ["field", "type", "path"]
    },
    "JsonSchemaPubSubOperation": {
      "additionalProperties": false,
      "type": "object",
      "title": "JsonSchemaPubSubOperation",
      "properties": {
        "field": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": ["Query", "Mutation", "Subscription"],
          "description": "Allowed values: Query, Mutation, Subscription"
        },
        "requestSchema": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "requestSample": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "requestTypeName": {
          "type": "string"
        },
        "responseSchema": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "responseSample": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "responseTypeName": {
          "type": "string"
        },
        "argTypeMap": {
          "type": "object",
          "properties": {}
        },
        "pubsubTopic": {
          "type": "string"
        }
      },
      "required": ["field", "type", "pubsubTopic"]
    },
    "MongooseHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "MongooseHandler",
      "properties": {
        "connectionString": {
          "type": "string"
        },
        "models": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MongooseModel"
          },
          "additionalItems": false
        },
        "discriminators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MongooseModel"
          },
          "additionalItems": false
        },
        "autoTypeMerging": {
          "type": "boolean",
          "description": "Enable Automatic Type Merging/Federation support"
        }
      }
    },
    "MongooseModel": {
      "additionalProperties": false,
      "type": "object",
      "title": "MongooseModel",
      "properties": {
        "name": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "options": {
          "$ref": "#/definitions/ComposeWithMongooseOpts"
        }
      },
      "required": ["name", "path"]
    },
    "ComposeWithMongooseOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "ComposeWithMongooseOpts",
      "properties": {
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "fields": {
          "$ref": "#/definitions/ComposeWithMongooseFieldsOpts"
        },
        "inputType": {
          "$ref": "#/definitions/ComposeMongooseInputType"
        },
        "resolvers": {
          "$ref": "#/definitions/TypeConverterResolversOpts"
        }
      }
    },
    "ComposeMongooseInputType": {
      "additionalProperties": false,
      "type": "object",
      "title": "ComposeMongooseInputType",
      "properties": {
        "name": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "fields": {
          "$ref": "#/definitions/ComposeWithMongooseFieldsOpts"
        },
        "resolvers": {
          "$ref": "#/definitions/TypeConverterResolversOpts"
        }
      }
    },
    "ComposeWithMongooseFieldsOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "ComposeWithMongooseFieldsOpts",
      "properties": {
        "only": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "remove": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "required": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      }
    },
    "TypeConverterResolversOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "TypeConverterResolversOpts",
      "properties": {
        "findById": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "findByIds": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "findOne": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "findMany": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "updateById": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "updateOne": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "updateMany": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "removeById": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "removeOne": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "removeMany": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "createOne": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "createMany": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "count": {
          "description": "Any of: Boolean, ComposeWithMongooseResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/ComposeWithMongooseResolverOpts"
            }
          ]
        },
        "connection": {
          "description": "Any of: Boolean, JSON",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "object",
              "properties": {}
            }
          ]
        },
        "pagination": {
          "description": "Any of: Boolean, PaginationResolverOpts",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "$ref": "#/definitions/PaginationResolverOpts"
            }
          ]
        }
      }
    },
    "ComposeWithMongooseResolverOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "ComposeWithMongooseResolverOpts",
      "properties": {
        "filter": {
          "$ref": "#/definitions/FilterHelperArgsOpts"
        },
        "sort": {
          "$ref": "#/definitions/SortHelperArgsOpts"
        },
        "limit": {
          "$ref": "#/definitions/LimitHelperArgsOpts"
        },
        "record": {
          "$ref": "#/definitions/RecordHelperArgsOpts"
        },
        "skip": {
          "type": "boolean"
        }
      }
    },
    "FilterHelperArgsOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "FilterHelperArgsOpts",
      "properties": {
        "filterTypeName": {
          "type": "string"
        },
        "isRequired": {
          "type": "boolean"
        },
        "onlyIndexed": {
          "type": "boolean"
        },
        "requiredFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "operators": {
          "description": "Any of: Boolean, JSON",
          "anyOf": [
            {
              "type": "boolean"
            },
            {
              "type": "object",
              "properties": {}
            }
          ]
        },
        "removeFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      }
    },
    "SortHelperArgsOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "SortHelperArgsOpts",
      "properties": {
        "sortTypeName": {
          "type": "string"
        }
      }
    },
    "LimitHelperArgsOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "LimitHelperArgsOpts",
      "properties": {
        "defaultValue": {
          "type": "integer"
        }
      }
    },
    "RecordHelperArgsOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "RecordHelperArgsOpts",
      "properties": {
        "recordTypeName": {
          "type": "string"
        },
        "isRequired": {
          "type": "boolean"
        },
        "removeFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "requiredFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      }
    },
    "PaginationResolverOpts": {
      "additionalProperties": false,
      "type": "object",
      "title": "PaginationResolverOpts",
      "properties": {
        "perPage": {
          "type": "integer"
        }
      }
    },
    "MySQLHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "MySQLHandler",
      "properties": {
        "host": {
          "type": "string"
        },
        "port": {
          "type": "integer"
        },
        "user": {
          "type": "string"
        },
        "password": {
          "type": "string"
        },
        "database": {
          "type": "string"
        },
        "pool": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Use existing `Pool` instance\nFormat: modulePath#exportName"
        },
        "tables": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Use specific tables for your schema"
        },
        "tableFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/TableField"
          },
          "additionalItems": false,
          "description": "Use specific fields of specific tables"
        }
      }
    },
    "TableField": {
      "additionalProperties": false,
      "type": "object",
      "title": "TableField",
      "properties": {
        "table": {
          "type": "string"
        },
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        }
      },
      "required": ["table", "fields"]
    },
    "Neo4jHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "Neo4jHandler",
      "properties": {
        "url": {
          "type": "string",
          "description": "URL for the Neo4j Instance e.g. neo4j://localhost"
        },
        "username": {
          "type": "string",
          "description": "Username for basic authentication"
        },
        "password": {
          "type": "string",
          "description": "Password for basic authentication"
        },
        "alwaysIncludeRelationships": {
          "type": "boolean",
          "description": "Specifies whether relationships should always be included in the type definitions as [relationship](https://grandstack.io/docs/neo4j-graphql-js.html#relationship-types) types, even if the relationships do not have properties."
        },
        "database": {
          "type": "string",
          "description": "Specifies database name"
        },
        "typeDefs": {
          "type": "string",
          "description": "Provide GraphQL Type Definitions instead of inferring"
        }
      },
      "required": ["url", "username", "password"]
    },
    "NewOpenapiHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "NewOpenapiHandler",
      "properties": {
        "oasFilePath": {
          "type": "string"
        },
        "baseUrl": {
          "type": "string"
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {}
        },
        "operationHeaders": {
          "type": "object",
          "properties": {}
        }
      },
      "required": ["oasFilePath"]
    },
    "ODataHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "ODataHandler",
      "properties": {
        "baseUrl": {
          "type": "string",
          "description": "Base URL for OData API"
        },
        "metadata": {
          "type": "string",
          "description": "Custom $metadata File or URL"
        },
        "operationHeaders": {
          "type": "object",
          "properties": {},
          "description": "Headers to be used with the operation requests"
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {},
          "description": "Headers to be used with the $metadata requests"
        },
        "batch": {
          "type": "string",
          "enum": ["multipart", "json"],
          "description": "Enable batching (Allowed values: multipart, json)"
        },
        "expandNavProps": {
          "type": "boolean",
          "description": "Use $expand for navigation props instead of seperate HTTP requests (Default: false)"
        },
        "customFetch": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Custom Fetch"
        }
      },
      "required": ["baseUrl"]
    },
    "OpenapiHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "OpenapiHandler",
      "properties": {
        "source": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "A pointer to your API source - could be a local file, remote file or url endpoint"
        },
        "sourceFormat": {
          "type": "string",
          "enum": ["json", "yaml"],
          "description": "Format of the source file (Allowed values: json, yaml)"
        },
        "operationHeaders": {
          "type": "object",
          "properties": {},
          "description": "JSON object representing the Headers to add to the runtime of the API calls"
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {},
          "description": "If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema."
        },
        "baseUrl": {
          "type": "string",
          "description": "Specifies the URL on which all paths will be based on.\nOverrides the server object in the OAS."
        },
        "qs": {
          "type": "object",
          "properties": {},
          "description": "JSON object representing the query search parameters to add to the API calls"
        },
        "customFetch": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "W3 Compatible Fetch Implementation"
        },
        "includeHttpDetails": {
          "type": "boolean",
          "description": "Include HTTP Response details to the result object"
        },
        "addLimitArgument": {
          "type": "boolean",
          "description": "Auto-generate a 'limit' argument for all fields that return lists of objects, including ones produced by links"
        },
        "genericPayloadArgName": {
          "type": "boolean",
          "description": "Set argument name for mutation payload to 'requestBody'. If false, name defaults to camelCased pathname"
        },
        "selectQueryOrMutationField": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SelectQueryOrMutationFieldConfig"
          },
          "additionalItems": false,
          "description": "Allows to explicitly override the default operation (Query or Mutation) for any OAS operation"
        },
        "provideErrorExtensions": {
          "type": "boolean",
          "description": "Overwrite automatic wrapping of errors into GraphqlErrors"
        },
        "operationIdFieldNames": {
          "type": "boolean",
          "description": "Field names can only be sanitized operationIds\n\nBy default, query field names are based on the return type type name and mutation field names are based on the operationId, which may be generated if it does not exist.\n\nThis option forces OpenAPI handler to only create field names based on the operationId."
        }
      },
      "required": ["source"]
    },
    "SelectQueryOrMutationFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SelectQueryOrMutationFieldConfig",
      "properties": {
        "title": {
          "type": "string",
          "description": "OAS Title"
        },
        "path": {
          "type": "string",
          "description": "Operation Path"
        },
        "type": {
          "type": "string",
          "enum": ["Query", "Mutation"],
          "description": "Target Root Type for this operation (Allowed values: Query, Mutation)"
        },
        "method": {
          "type": "string",
          "description": "Which method is used for this operation"
        }
      }
    },
    "PostGraphileHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "PostGraphileHandler",
      "properties": {
        "connectionString": {
          "type": "string",
          "description": "A connection string to your Postgres database"
        },
        "schemaName": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "An array of strings which specifies the PostgreSQL schemas that PostGraphile will use to create a GraphQL schema. The default schema is the public schema."
        },
        "pool": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Connection Pool instance or settings or you can provide the path of a code file that exports any of those"
        },
        "appendPlugins": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Extra Postgraphile Plugins to append"
        },
        "skipPlugins": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Postgraphile Plugins to skip (e.g. \"graphile-build#NodePlugin\")"
        },
        "options": {
          "description": "Extra Postgraphile options that will be added to the postgraphile constructor. It can either be an object or a string pointing to the object's path (e.g. \"./my-config#options\"). See the [postgraphile docs](https://www.graphile.org/postgraphile/usage-library/) for more information. (Any of: JSON, String)",
          "anyOf": [
            {
              "type": "object",
              "properties": {}
            },
            {
              "type": "string"
            }
          ]
        },
        "subscriptions": {
          "type": "boolean",
          "description": "Enable GraphQL websocket transport support for subscriptions (default: true)"
        },
        "live": {
          "type": "boolean",
          "description": "Enables live-query support via GraphQL subscriptions (sends updated payload any time nested collections/records change) (default: true)"
        }
      }
    },
    "RAMLHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "RAMLHandler",
      "properties": {
        "ramlFilePath": {
          "type": "string"
        },
        "baseUrl": {
          "type": "string"
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {}
        },
        "operationHeaders": {
          "type": "object",
          "properties": {}
        }
      },
      "required": ["ramlFilePath"]
    },
    "SoapHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "SoapHandler",
      "properties": {
        "wsdl": {
          "type": "string",
          "description": "A url to your WSDL"
        },
        "basicAuth": {
          "$ref": "#/definitions/SoapSecurityBasicAuthConfig",
          "description": "Basic Authentication Configuration\nIncluding username and password fields"
        },
        "securityCert": {
          "$ref": "#/definitions/SoapSecurityCertificateConfig",
          "description": "SSL Certificate Based Authentication Configuration\nIncluding public key, private key and password fields"
        },
        "schemaHeaders": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "JSON object representing the Headers to add to the runtime of the API calls only for schema introspection\nYou can also provide `.js` or `.ts` file path that exports schemaHeaders as an object"
        },
        "operationHeaders": {
          "type": "object",
          "properties": {},
          "description": "JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime"
        },
        "includePorts": {
          "type": "boolean",
          "description": "If true, the ports defined in the WSDL will be represented as GraphQL-Type objects in the schema.\nThe fields of the object will be the operations of the port.\n\nMost soap-endpoints only define one port; so including it in the schema will just be inconvenient.\nBut if there are multiple ports with operations of the same name, you should set this option to true.\nOtherwise only one of the identical-named operations will be callable.\n\ndefault: false"
        },
        "includeServices": {
          "type": "boolean",
          "description": "If true, the services defined in the WSDL will be represented as GraphQL-Type objects in the schema.\nThe fields of the object will be the ports of the service (or the operation, dependent on 'includePorts').\n\nMost soap-endpoints only define one service; so including it in the schema will just be inconvenient.\nBut if there are multiple services with operations of the same name, you should set this option to true.\nOtherwise only one of the identical-named operations will be callable.\n\ndefault: false"
        },
        "selectQueryOrMutationField": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/SoapSelectQueryOrMutationFieldConfig"
          },
          "additionalItems": false,
          "description": "Allows to explicitly override the default operation (Query or Mutation) for any SOAP operation"
        },
        "selectQueryOperationsAuto": {
          "type": "boolean",
          "description": "Automatically put operations starts with `query` or `get` into the Query type"
        }
      },
      "required": ["wsdl"]
    },
    "SoapSelectQueryOrMutationFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SoapSelectQueryOrMutationFieldConfig",
      "properties": {
        "service": {
          "type": "string"
        },
        "port": {
          "type": "string"
        },
        "operation": {
          "type": "string"
        },
        "type": {
          "type": "string",
          "enum": ["query", "mutation"],
          "description": "Allowed values: query, mutation"
        }
      },
      "required": ["service", "port", "operation", "type"]
    },
    "SoapSecurityBasicAuthConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SoapSecurityBasicAuthConfig",
      "properties": {
        "username": {
          "type": "string",
          "description": "Username for Basic Authentication"
        },
        "password": {
          "type": "string",
          "description": "Password for Basic Authentication"
        }
      },
      "required": ["username", "password"]
    },
    "SoapSecurityCertificateConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SoapSecurityCertificateConfig",
      "properties": {
        "publicKey": {
          "type": "string",
          "description": "Your public key"
        },
        "privateKey": {
          "type": "string",
          "description": "Your private key"
        },
        "password": {
          "type": "string",
          "description": "Password"
        },
        "publicKeyPath": {
          "type": "string",
          "description": "Path to the file or URL contains your public key"
        },
        "privateKeyPath": {
          "type": "string",
          "description": "Path to the file or URL contains your private key"
        },
        "passwordPath": {
          "type": "string",
          "description": "Path to the file or URL contains your password"
        }
      }
    },
    "ThriftHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "ThriftHandler",
      "properties": {
        "hostName": {
          "type": "string",
          "description": "The name of the host to connect to."
        },
        "port": {
          "type": "integer",
          "description": "The port number to attach to on the host."
        },
        "path": {
          "type": "string",
          "description": "The path on which the Thrift service is listening. Defaults to '/thrift'."
        },
        "https": {
          "type": "boolean",
          "description": "Boolean value indicating whether to use https. Defaults to false."
        },
        "protocol": {
          "type": "string",
          "enum": ["binary", "compact", "json"],
          "description": "Name of the Thrift protocol type to use. Defaults to 'binary'. (Allowed values: binary, compact, json)"
        },
        "serviceName": {
          "type": "string",
          "description": "The name of your service. Used for logging."
        },
        "operationHeaders": {
          "type": "object",
          "properties": {},
          "description": "JSON object representing the Headers to add to the runtime of the API calls"
        },
        "schemaHeaders": {
          "type": "object",
          "properties": {},
          "description": "If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema."
        },
        "idl": {
          "type": "string",
          "description": "Path to IDL file"
        }
      },
      "required": ["hostName", "port", "serviceName", "idl"]
    },
    "CacheTransformConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "CacheTransformConfig",
      "properties": {
        "field": {
          "type": "string",
          "description": "The type and field to apply cache to, you can use wild cards as well, for example: `Query.*`"
        },
        "cacheKey": {
          "type": "string",
          "description": "Cache key to use to store your resolvers responses.\nThe defualt is: {typeName}-{fieldName}-{argsHash}-{fieldNamesHash}\n\nAvailable variables:\n- {args.argName} - use resolver argument\n- {typeName} - use name of the type\n- {fieldName} - use name of the field\n- {argsHash} - a hash based on the 'args' object\n- {fieldNamesHash} - a hash based on the field names selected by the client\n- {info} - the GraphQLResolveInfo of the resolver\n\nAvailable interpolations:\n- {format|date} - returns the current date with a specific format"
        },
        "invalidate": {
          "$ref": "#/definitions/CacheInvalidateConfig",
          "description": "Invalidation rules"
        }
      },
      "required": ["field"]
    },
    "CacheInvalidateConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "CacheInvalidateConfig",
      "properties": {
        "effectingOperations": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/CacheEffectingOperationConfig"
          },
          "additionalItems": false,
          "description": "Invalidate the cache when a specific operation is done without an error"
        },
        "ttl": {
          "type": "integer",
          "description": "Specified in seconds, the time-to-live (TTL) value limits the lifespan"
        }
      }
    },
    "CacheEffectingOperationConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "CacheEffectingOperationConfig",
      "properties": {
        "operation": {
          "type": "string",
          "description": "Path to the operation that could effect it. In a form: Mutation.something. Note that wildcard is not supported in this field."
        },
        "matchKey": {
          "type": "string",
          "description": "Cache key to invalidate on sucessful resolver (no error), see `cacheKey` for list of available options in this field."
        }
      },
      "required": ["operation"]
    },
    "EncapsulateTransformObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "EncapsulateTransformObject",
      "properties": {
        "name": {
          "type": "string",
          "description": "Optional, name to use for grouping under the root types. If not specific, the API name is used."
        },
        "applyTo": {
          "$ref": "#/definitions/EncapsulateTransformApplyTo",
          "description": "Allow you to choose which root operations you would like to apply. By default, it's applied to all root types."
        }
      }
    },
    "EncapsulateTransformApplyTo": {
      "additionalProperties": false,
      "type": "object",
      "title": "EncapsulateTransformApplyTo",
      "properties": {
        "query": {
          "type": "boolean"
        },
        "mutation": {
          "type": "boolean"
        },
        "subscription": {
          "type": "boolean"
        }
      }
    },
    "ExtendTransform": {
      "additionalProperties": false,
      "type": "object",
      "title": "ExtendTransform",
      "properties": {
        "typeDefs": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "resolvers": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        }
      }
    },
    "FederationTransform": {
      "additionalProperties": false,
      "type": "object",
      "title": "FederationTransform",
      "properties": {
        "types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FederationTransformType"
          },
          "additionalItems": false
        }
      }
    },
    "FederationTransformType": {
      "additionalProperties": false,
      "type": "object",
      "title": "FederationTransformType",
      "properties": {
        "name": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/FederationObjectConfig"
        }
      },
      "required": ["name"]
    },
    "FederationObjectConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "FederationObjectConfig",
      "properties": {
        "keyFields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false
        },
        "extend": {
          "type": "boolean"
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FederationField"
          },
          "additionalItems": false
        },
        "resolveReference": {
          "description": "Any of: String, ResolveReferenceObject",
          "anyOf": [
            {
              "type": "string"
            },
            {
              "$ref": "#/definitions/ResolveReferenceObject"
            }
          ]
        }
      }
    },
    "ResolveReferenceObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "ResolveReferenceObject",
      "properties": {
        "queryFieldName": {
          "type": "string",
          "description": "Name of root field name that resolves the reference"
        },
        "keyArg": {
          "type": "string",
          "description": "If the root field name has multiple args,\nyou need to define which argument should receive the key"
        }
      },
      "required": ["queryFieldName"]
    },
    "FederationField": {
      "additionalProperties": false,
      "type": "object",
      "title": "FederationField",
      "properties": {
        "name": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/FederationFieldConfig"
        }
      },
      "required": ["name", "config"]
    },
    "FederationFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "FederationFieldConfig",
      "properties": {
        "external": {
          "type": "boolean"
        },
        "provides": {
          "type": "string"
        },
        "requires": {
          "type": "string"
        }
      }
    },
    "FilterSchemaTransform": {
      "additionalProperties": false,
      "type": "object",
      "title": "FilterSchemaTransform",
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["bare", "wrap"],
          "description": "Specify to apply filter-schema transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)"
        },
        "filters": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Array of filter rules"
        }
      },
      "required": ["filters"]
    },
    "MockingConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "MockingConfig",
      "properties": {
        "if": {
          "type": "boolean",
          "description": "If this expression is truthy, mocking would be enabled\nYou can use environment variables expression, for example: `${MOCKING_ENABLED}`"
        },
        "preserveResolvers": {
          "type": "boolean",
          "description": "Do not mock any other resolvers other than defined in `mocks`.\nFor example, you can enable this if you don't want to mock entire schema but partially."
        },
        "mocks": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MockingFieldConfig"
          },
          "additionalItems": false,
          "description": "Mock configurations"
        },
        "initializeStore": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "The path to the code runs before the store is attached to the schema"
        }
      }
    },
    "MockingFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "MockingFieldConfig",
      "properties": {
        "apply": {
          "type": "string",
          "description": "Resolver path\nExample: User.firstName"
        },
        "if": {
          "type": "boolean",
          "description": "If this expression is truthy, mocking would be enabled\nYou can use environment variables expression, for example: `${MOCKING_ENABLED}`"
        },
        "faker": {
          "type": "string",
          "description": "Faker.js expression or function\nRead more (https://github.com/marak/Faker.js/#fakerfake)\nExample;\nfaker: name.firstName\nfaker: \"{{ name.firstName }} {{ name.lastName }}\""
        },
        "custom": {
          "type": "string",
          "description": "Custom mocking\nIt can be a module or json file.\nBoth \"moduleName#exportName\" or only \"moduleName\" would work"
        },
        "length": {
          "type": "integer",
          "description": "Length of the mock list\nFor the list types `[ObjectType]`, how many `ObjectType` you want to return?\ndefault: 2"
        },
        "store": {
          "$ref": "#/definitions/GetFromMockStoreConfig",
          "description": "Get the data from the mock store"
        },
        "updateStore": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UpdateMockStoreConfig"
          },
          "additionalItems": false,
          "description": "Update the data on the mock store"
        }
      },
      "required": ["apply"]
    },
    "GetFromMockStoreConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "GetFromMockStoreConfig",
      "properties": {
        "type": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "fieldName": {
          "type": "string"
        }
      }
    },
    "UpdateMockStoreConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "UpdateMockStoreConfig",
      "properties": {
        "type": {
          "type": "string"
        },
        "key": {
          "type": "string"
        },
        "fieldName": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "NamingConventionTransformConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "NamingConventionTransformConfig",
      "properties": {
        "typeNames": {
          "type": "string",
          "enum": [
            "camelCase",
            "capitalCase",
            "constantCase",
            "dotCase",
            "headerCase",
            "noCase",
            "paramCase",
            "pascalCase",
            "pathCase",
            "sentenceCase",
            "snakeCase",
            "upperCase",
            "lowerCase"
          ],
          "description": "Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase"
        },
        "fieldNames": {
          "type": "string",
          "enum": [
            "camelCase",
            "capitalCase",
            "constantCase",
            "dotCase",
            "headerCase",
            "noCase",
            "paramCase",
            "pascalCase",
            "pathCase",
            "sentenceCase",
            "snakeCase",
            "upperCase",
            "lowerCase"
          ],
          "description": "Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase"
        },
        "enumValues": {
          "type": "string",
          "enum": [
            "camelCase",
            "capitalCase",
            "constantCase",
            "dotCase",
            "headerCase",
            "noCase",
            "paramCase",
            "pascalCase",
            "pathCase",
            "sentenceCase",
            "snakeCase",
            "upperCase",
            "lowerCase"
          ],
          "description": "Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase"
        }
      }
    },
    "PrefixTransformConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "PrefixTransformConfig",
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["bare", "wrap"],
          "description": "Specify to apply prefix transform to bare schema or by wrapping original schema (Allowed values: bare, wrap)"
        },
        "value": {
          "type": "string",
          "description": "The prefix to apply to the schema types. By default it's the API name."
        },
        "ignore": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "List of ignored types"
        },
        "includeRootOperations": {
          "type": "boolean",
          "description": "Changes root types and changes the field names (default: false)"
        },
        "includeTypes": {
          "type": "boolean",
          "description": "Changes types (default: true)"
        }
      }
    },
    "RenameTransform": {
      "additionalProperties": false,
      "type": "object",
      "title": "RenameTransform",
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["bare", "wrap"],
          "description": "Specify to apply rename transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)"
        },
        "renames": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/RenameTransformObject"
          },
          "additionalItems": false,
          "description": "Array of rename rules"
        }
      },
      "required": ["renames"]
    },
    "RenameTransformObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "RenameTransformObject",
      "properties": {
        "from": {
          "$ref": "#/definitions/RenameConfig"
        },
        "to": {
          "$ref": "#/definitions/RenameConfig"
        },
        "useRegExpForTypes": {
          "type": "boolean",
          "description": "Use Regular Expression for type names"
        },
        "useRegExpForFields": {
          "type": "boolean",
          "description": "Use Regular Expression for field names"
        },
        "regExpFlags": {
          "type": "string",
          "description": "Flags to use in the Regular Expression"
        }
      },
      "required": ["from", "to"]
    },
    "RenameConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "RenameConfig",
      "properties": {
        "type": {
          "type": "string"
        },
        "field": {
          "type": "string"
        }
      }
    },
    "ReplaceFieldTransformConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "ReplaceFieldTransformConfig",
      "properties": {
        "typeDefs": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Additional type definition to used to replace field types"
        },
        "replacements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ReplaceFieldTransformObject"
          },
          "additionalItems": false,
          "description": "Array of rules to replace fields"
        }
      },
      "required": ["replacements"]
    },
    "ReplaceFieldTransformObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "ReplaceFieldTransformObject",
      "properties": {
        "from": {
          "$ref": "#/definitions/ReplaceFieldConfig"
        },
        "to": {
          "$ref": "#/definitions/ReplaceFieldConfig"
        },
        "scope": {
          "type": "string",
          "enum": ["config", "hoistValue"],
          "description": "Allowed values: config, hoistValue"
        },
        "composer": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ]
        },
        "name": {
          "type": "string"
        }
      },
      "required": ["from", "to"]
    },
    "ReplaceFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "ReplaceFieldConfig",
      "properties": {
        "type": {
          "type": "string"
        },
        "field": {
          "type": "string"
        }
      },
      "required": ["type", "field"]
    },
    "ResolversCompositionTransform": {
      "additionalProperties": false,
      "type": "object",
      "title": "ResolversCompositionTransform",
      "properties": {
        "mode": {
          "type": "string",
          "enum": ["bare", "wrap"],
          "description": "Specify to apply resolvers-composition transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)"
        },
        "compositions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ResolversCompositionTransformObject"
          },
          "additionalItems": false,
          "description": "Array of resolver/composer to apply"
        }
      },
      "required": ["compositions"]
    },
    "ResolversCompositionTransformObject": {
      "additionalProperties": false,
      "type": "object",
      "title": "ResolversCompositionTransformObject",
      "properties": {
        "resolver": {
          "type": "string",
          "description": "The GraphQL Resolver path\nExample: Query.users"
        },
        "composer": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "Path to the composer function\nExample: ./src/auth.js#authComposer"
        }
      },
      "required": ["resolver", "composer"]
    },
    "SnapshotTransformConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "SnapshotTransformConfig",
      "properties": {
        "if": {
          "description": "Expression for when to activate this extension.\nValue can be a valid JS expression string or a boolean (Any of: String, Boolean)",
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "boolean"
            }
          ]
        },
        "apply": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Resolver to be applied\nFor example;\n  apply:\n      - Query.* <- * will apply this extension to all fields of Query type\n      - Mutation.someMutationButProbablyYouWontNeedIt"
        },
        "outputDir": {
          "type": "string",
          "description": "Path to the directory of the generated snapshot files"
        },
        "respectSelectionSet": {
          "type": "boolean",
          "description": "Take snapshots by respecting the requested selection set.\nThis might be needed for the handlers like Postgraphile or OData that rely on the incoming GraphQL operation."
        }
      },
      "required": ["apply", "outputDir"]
    },
    "TypeMergingConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "TypeMergingConfig",
      "properties": {
        "types": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MergedTypeConfig"
          },
          "additionalItems": false
        },
        "queryFields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MergedRootFieldConfig"
          },
          "additionalItems": false,
          "description": "Denotes a root field used to query a merged type across services.\nThe marked field's name is analogous\nto the fieldName setting in\n[merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example),\nwhile the field's arguments and return type are used to infer merge configuration.\nDirective arguments tune the merge behavior"
        },
        "additionalConfiguration": {
          "anyOf": [
            {
              "type": "object",
              "additionalProperties": true
            },
            {
              "type": "string"
            },
            {
              "type": "array",
              "additionalItems": true
            }
          ],
          "description": "The path to a code file that has additional type merging configuration"
        }
      }
    },
    "MergedRootFieldConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "MergedRootFieldConfig",
      "properties": {
        "queryFieldName": {
          "type": "string"
        },
        "keyField": {
          "type": "string",
          "description": "Specifies the name of a field to pick off origin objects as the key value. When omitted, a `@key` directive must be included on the return type's definition to be built into an object key.\nhttps://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys"
        },
        "keyArg": {
          "type": "string",
          "description": "Specifies which field argument receives the merge key. This may be omitted for fields with only one argument where the recipient can be inferred."
        },
        "additionalArgs": {
          "type": "string",
          "description": "Specifies a string of additional keys and values to apply to other arguments,\nformatted as `\\\"\\\"\\\" arg1: \"value\", arg2: \"value\" \\\"\\\"\\\"`."
        },
        "key": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "additionalItems": false,
          "description": "Advanced use only; Allows building a custom key just for the argument from the selectionSet included by the `@key` directive."
        },
        "argsExpr": {
          "type": "string",
          "description": "Advanced use only; This argument specifies a string expression that allows more customization of the input arguments. Rules for evaluation of this argument are as follows:\n  - basic object parsing of the input key: `\"arg1: $key.arg1, arg2: $key.arg2\"`\n  - any expression enclosed by double brackets will be evaluated once for each of the requested keys, and then sent as a list: `\"input: { keys: [[$key]] }\"`\n  - selections from the key can be referenced by using the $ sign and dot notation: `\"upcs: [[$key.upc]]\"`, so that `$key.upc` refers to the `upc` field of the key."
        }
      },
      "required": ["queryFieldName"]
    },
    "MergedTypeConfig": {
      "additionalProperties": false,
      "type": "object",
      "title": "MergedTypeConfig",
      "properties": {
        "typeName": {
          "type": "string",
          "description": "Name of the type (Query by default)"
        },
        "key": {
          "$ref": "#/definitions/KeyAnnotation",
          "description": "Specifies a base selection set needed to merge the annotated type across subschemas.\nAnalogous to the `selectionSet` setting specified in [merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example)."
        },
        "canonical": {
          "type": "boolean",
          "description": "Specifies types and fields\nthat provide a [canonical definition](https://www.graphql-tools.com/docs/stitch-type-merging#canonical-definitions) to be built into the gateway schema. Useful for selecting preferred characteristics among types and fields that overlap across subschemas. Root fields marked as canonical specify which subschema the field proxies for new queries entering the graph."
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/MergedTypeField"
          },
          "additionalItems": false
        }
      }
    },
    "KeyAnnotation": {
      "additionalProperties": false,
      "type": "object",
      "title": "KeyAnnotation",
      "properties": {
        "selectionSet": {
          "type": "string"
        }
      },
      "required": ["selectionSet"]
    },
    "MergedTypeField": {
      "additionalProperties": false,
      "type": "object",
      "title": "MergedTypeField",
      "properties": {
        "fieldName": {
          "type": "string"
        },
        "computed": {
          "$ref": "#/definitions/ComputedAnnotation",
          "description": "specifies a selection of fields required from other services to compute the value of this field.\nThese additional fields are only selected when the computed field is requested.\nAnalogous to [computed field](https://www.graphql-tools.com/docs/stitch-type-merging#computed-fields) in merged type configuration.\nComputed field dependencies must be sent into the subservice using an [object key](https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys)."
        }
      },
      "required": ["fieldName"]
    },
    "ComputedAnnotation": {
      "additionalProperties": false,
      "type": "object",
      "title": "ComputedAnnotation",
      "properties": {
        "selectionSet": {
          "type": "string"
        }
      },
      "required": ["selectionSet"]
    },
    "TuqlHandler": {
      "additionalProperties": false,
      "type": "object",
      "title": "TuqlHandler",
      "properties": {
        "db": {
          "type": "string",
          "description": "Pointer to your SQLite database"
        },
        "infile": {
          "type": "string",
          "description": "Path to the SQL Dump file if you want to build a in-memory database"
        }
      }
    }
  },
  "title": "Config",
  "type": "object",
  "$schema": "http://json-schema.org/draft-04/schema#",
  "required": ["sources"],
  "properties": {
    "serve": {
      "$ref": "#/definitions/ServeConfig",
      "description": "Configuration for `mesh start` or `mesh dev` command.\nThose commands won't be available in programmatic usage."
    },
    "sdk": {
      "$ref": "#/definitions/SDKConfig",
      "description": "SDK Configuration"
    },
    "require": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "additionalItems": false
    },
    "sources": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Source"
      },
      "additionalItems": false,
      "description": "Defines the list of your external data sources for your API mesh"
    },
    "transforms": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/Transform"
      },
      "additionalItems": false,
      "description": "Transform to apply to the unified mesh schema"
    },
    "additionalTypeDefs": {
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": true
        },
        {
          "type": "string"
        },
        {
          "type": "array",
          "additionalItems": true
        }
      ],
      "description": "Additional type definitions, or type definitions overrides you wish to add to the schema mesh"
    },
    "additionalResolvers": {
      "type": "array",
      "items": {
        "description": "Any of: String, AdditionalStitchingResolverObject, AdditionalStitchingBatchResolverObject, AdditionalSubscriptionObject",
        "anyOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/definitions/AdditionalStitchingResolverObject"
          },
          {
            "$ref": "#/definitions/AdditionalStitchingBatchResolverObject"
          },
          {
            "$ref": "#/definitions/AdditionalSubscriptionObject"
          }
        ]
      },
      "additionalItems": false,
      "description": "Additional resolvers, or resolvers overrides you wish to add to the schema mesh (Any of: String, AdditionalStitchingResolverObject, AdditionalStitchingBatchResolverObject, AdditionalSubscriptionObject)"
    },
    "cache": {
      "$ref": "#/definitions/Cache",
      "description": "Backend cache"
    },
    "merger": {
      "type": "string",
      "description": "Merge method"
    },
    "pubsub": {
      "description": "PubSub Implementation (Any of: String, PubSubConfig)",
      "anyOf": [
        {
          "type": "string"
        },
        {
          "$ref": "#/definitions/PubSubConfig"
        }
      ]
    },
    "liveQueryInvalidations": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/LiveQueryInvalidation"
      },
      "additionalItems": false,
      "description": "Live Query Invalidations"
    },
    "documents": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "additionalItems": false,
      "description": "Provide a query or queries for GraphQL Playground, validation and SDK Generation\nThe value can be the file path, glob expression for the file paths or the SDL.\n(.js, .jsx, .graphql, .gql, .ts and .tsx files are supported."
    },
    "logger": {
      "anyOf": [
        {
          "type": "object",
          "additionalProperties": true
        },
        {
          "type": "string"
        },
        {
          "type": "array",
          "additionalItems": true
        }
      ],
      "description": "Logger instance that matches `Console` interface of NodeJS"
    },
    "skipSSLValidation": {
      "type": "boolean",
      "description": "Allow connections to an SSL endpoint without certificates"
    }
  },
  "additionalProperties": false
}
