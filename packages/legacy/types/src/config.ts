/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface Config {
  serve?: ServeConfig;
  sdk?: SDKConfig;
  /**
   * Codegen Configuration
   */
  codegen?: any;
  require?: string[];
  /**
   * Defines the list of your external data sources for your API mesh
   */
  sources: Source[];
  /**
   * Transform to apply to the unified mesh schema
   */
  transforms?: Transform[];
  /**
   * Additional type definitions, or type definitions overrides you wish to add to the schema mesh
   */
  additionalTypeDefs?: any;
  /**
   * Additional resolvers, or resolvers overrides you wish to add to the schema mesh (Any of: String, AdditionalStitchingResolverObject, AdditionalStitchingBatchResolverObject, AdditionalSubscriptionObject)
   */
  additionalResolvers?: (
    | string
    | AdditionalStitchingResolverObject
    | AdditionalStitchingBatchResolverObject
    | AdditionalSubscriptionObject
  )[];
  cache?: Cache;
  /**
   * Merge method
   */
  merger?: string;
  /**
   * PubSub Implementation (Any of: String, PubSubConfig)
   */
  pubsub?: string | PubSubConfig;
  /**
   * Provide a query or queries for GraphQL Playground, validation and SDK Generation
   * The value can be the file path, glob expression for the file paths or the SDL.
   * (.js, .jsx, .graphql, .gql, .ts and .tsx files are supported.
   */
  documents?: string[];
  persistedOperations?: PersistedOperationsConfig;
  /**
   * Path to a file exporting a logger instance compatible with the `Logger` type from `@graphql-mesh/types`
   */
  logger?: string;
  /**
   * Path to a custom W3 Compatible Fetch Implementation
   */
  customFetch?: any;
  /**
   * Allow connections to an SSL endpoint without certificates
   */
  skipSSLValidation?: boolean;
  /**
   * Path to a JavaScript file with a default export of Envelop plugins
   */
  additionalEnvelopPlugins?: string;
  plugins?: Plugin[];
  /**
   * If you are using a CDN for a source (e.g. Federation Supergraph), this will be the polling interval in milliseconds for the CDN without a downtime
   */
  pollingInterval?: number;
}
/**
 * Configuration for `mesh start` or `mesh dev` command.
 * Those commands won't be available in programmatic usage.
 */
export interface ServeConfig {
  /**
   * Spawn multiple server instances as node clusters (default: `1`) (Any of: Int, Boolean)
   */
  fork?: number | boolean;
  /**
   * TCP Port to listen (default: `4000`) (Any of: Int, String)
   */
  port?: number | string;
  /**
   * The binding hostname (default: `localhost`)
   */
  hostname?: string;
  cors?: CorsConfig;
  /**
   * Path to your static files you want to be served with GraphQL Mesh HTTP Server
   */
  staticFiles?: string;
  /**
   * Show GraphiQL Playground
   */
  playground?: boolean;
  sslCredentials?: HTTPSConfig;
  /**
   * Path to GraphQL Endpoint (default: /graphql)
   */
  endpoint?: string;
  /**
   * Path to the browser that will be used by `mesh serve` to open a playground window in development mode
   * This feature can be disabled by passing `false` (Any of: String, Boolean)
   */
  browser?: string | boolean;
  /**
   * Title of GraphiQL Playground
   */
  playgroundTitle?: string;
  /**
   * Enable and define a limit for [Request Batching](https://github.com/graphql/graphql-over-http/blob/main/rfcs/Batching.md)
   */
  batchingLimit?: number;
  /**
   * Endpoint for [Health Check](https://the-guild.dev/graphql/yoga-server/docs/features/health-check)
   */
  healthCheckEndpoint?: string;
  /**
   * By default, GraphQL Mesh does not allow parameters in the request body except `query`, `variables`, `extensions`, and `operationName`.
   *
   * This option allows you to specify additional parameters that are allowed in the request body.
   *
   * @default []
   *
   * @example ['doc_id', 'id']
   */
  extraParamNames?: string[];
}
/**
 * Configuration for CORS
 */
export interface CorsConfig {
  origin?: any;
  allowedHeaders?: string[];
  exposedHeaders?: string[];
  credentials?: boolean;
  maxAge?: number;
  preflightContinue?: boolean;
  optionsSuccessStatus?: number;
}
/**
 * SSL Credentials for HTTPS Server
 * If this is provided, Mesh will be served via HTTPS
 */
export interface HTTPSConfig {
  key: string;
  cert: string;
}
/**
 * SDK Configuration
 */
export interface SDKConfig {
  generateOperations?: GenerateOperationsConfig;
}
/**
 * Use this only if you don't want to use `documents` for SDK,
 * and let Mesh generate them for you
 */
export interface GenerateOperationsConfig {
  selectionSetDepth?: number;
}
export interface Source {
  /**
   * The name you wish to set to your remote API, this will be used for building the GraphQL context
   */
  name: string;
  handler: Handler;
  /**
   * List of transforms to apply to the current API source, before unifying it with the rest of the sources
   */
  transforms?: Transform[];
}
/**
 * Point to the handler you wish to use, it can either be a predefined handler, or a custom
 */
export interface Handler {
  /**
   * Handler for remote/local/third-party GraphQL schema (Any of: GraphQLHandlerHTTPConfiguration, GraphQLHandlerCodeFirstConfiguration, GraphQLHandlerMultipleHTTPConfiguration)
   */
  graphql?:
    | GraphQLHandlerHTTPConfiguration
    | GraphQLHandlerCodeFirstConfiguration
    | GraphQLHandlerMultipleHTTPConfiguration;
  grpc?: GrpcHandler;
  jsonSchema?: JsonSchemaHandler;
  mongoose?: MongooseHandler;
  mysql?: MySQLHandler;
  neo4j?: Neo4JHandler;
  odata?: ODataHandler;
  openapi?: OpenapiHandler;
  postgraphile?: PostGraphileHandler;
  raml?: RAMLHandler;
  soap?: SoapHandler;
  supergraph?: SupergraphHandler;
  thrift?: ThriftHandler;
  tuql?: TuqlHandler;
  [k: string]: any;
}
export interface GraphQLHandlerHTTPConfiguration {
  /**
   * A url or file path to your remote GraphQL endpoint.
   * If you provide a path to a code file(js or ts),
   * other options will be ignored and the schema exported from the file will be used directly.
   */
  endpoint: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for schema introspection
   */
  schemaHeaders?: any;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Use HTTP GET for Query operations
   */
  useGETForQueries?: boolean;
  /**
   * HTTP method used for GraphQL operations (Allowed values: GET, POST)
   */
  method?: 'GET' | 'POST';
  /**
   * Request Credentials if your environment supports it.
   * [See more](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)
   *
   * @default "same-origin" (Allowed values: omit, include)
   */
  credentials?: 'omit' | 'include';
  /**
   * Path to a custom W3 Compatible WebSocket Implementation
   */
  webSocketImpl?: string;
  /**
   * Path to the introspection
   * You can separately give schema introspection or SDL
   */
  source?: string;
  /**
   * SSE - Server Sent Events
   * WS - New graphql-ws
   * LEGACY_WS - Legacy subscriptions-transport-ws (Allowed values: SSE, WS, LEGACY_WS)
   */
  subscriptionsProtocol?: 'SSE' | 'WS' | 'LEGACY_WS';
  /**
   * URL to your endpoint serving all subscription queries for this source
   */
  subscriptionsEndpoint?: string;
  /**
   * Retry attempts if fails
   */
  retry?: number;
  /**
   * Timeout in milliseconds
   */
  timeout?: number;
  /**
   * Enable/Disable automatic query batching
   */
  batch?: boolean;
  /**
   * JSON object representing the `connectionParams` from a WebSocket connection to add to the runtime of the API calls only for operation during runtime.
   * More information about the WebSocket `connectionParams`:
   *   - When using `subscriptionsProtocol=WS` (graphql-ws): https://github.com/enisdenjo/graphql-ws/blob/master/docs/interfaces/client.ClientOptions.md#connectionparams
   *   - When using `subscriptionsProtocol=LEGACY_WS` (subscriptions-transport-ws): https://github.com/apollographql/subscriptions-transport-ws/blob/51270cc7dbaf09c7b9aa67368f1de58148c7d334/README.md#subscriptionclient
   */
  connectionParams?: {
    [k: string]: any;
  };
}
export interface GraphQLHandlerCodeFirstConfiguration {
  /**
   * A file path to your GraphQL Schema
   * If you provide a path to a code file(js or ts),
   * other options will be ignored and the schema exported from the file will be used directly.
   */
  source: any;
}
export interface GraphQLHandlerMultipleHTTPConfiguration {
  /**
   * HTTP Source Configurations
   */
  sources: GraphQLHandlerHTTPConfiguration[];
  /**
   * Handling strategy (default: fallback) (Allowed values: fallback, race, highestValue)
   */
  strategy?: 'fallback' | 'race' | 'highestValue';
  strategyConfig?: GraphQLHandlerhighestValueStrategyConfig;
}
/**
 * Handling strategy configuration
 */
export interface GraphQLHandlerhighestValueStrategyConfig {
  selectionSet: string;
  value: string;
}
/**
 * Handler for gRPC and Protobuf schemas
 */
export interface GrpcHandler {
  /**
   * gRPC Endpoint
   */
  endpoint: string;
  /**
   * gRPC Proto file that contains your protobuf schema
   * OR
   * Use a binary-encoded or JSON file descriptor set file (Any of: ProtoFilePath, String)
   */
  source?: ProtoFilePath | string;
  /**
   * Request timeout in milliseconds
   * Default: 200000
   */
  requestTimeout?: number;
  credentialsSsl?: GrpcCredentialsSsl;
  /**
   * Use https instead of http for gRPC connection
   */
  useHTTPS?: boolean;
  /**
   * MetaData
   */
  metaData?: {
    [k: string]: any;
  };
  /**
   * prefix to collect Query method default: list, get
   */
  prefixQueryMethod?: string[];
  /**
   * Allows to explicitly override the default operation (Query or Mutation) for any gRPC operation
   */
  selectQueryOrMutationField?: SelectQueryOrMutationFieldConfig[];
  schemaHeaders?: {
    [k: string]: any;
  };
}
export interface ProtoFilePath {
  file: string;
  load?: LoadOptions;
}
export interface LoadOptions {
  defaults?: boolean;
  includeDirs?: string[];
}
/**
 * SSL Credentials
 */
export interface GrpcCredentialsSsl {
  rootCA?: string;
  certChain?: string;
  privateKey?: string;
}
export interface SelectQueryOrMutationFieldConfig {
  /**
   * Allowed values: query, mutation, Query, Mutation
   */
  type: 'query' | 'mutation' | 'Query' | 'Mutation';
  fieldName: string;
}
/**
 * Handler for JSON Schema specification.
 * Source could be a local json file, or a url to it.
 */
export interface JsonSchemaHandler {
  source?: string;
  endpoint?: string;
  operationHeaders?: {
    [k: string]: any;
  };
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Any of: JsonSchemaHTTPOperation, JsonSchemaPubSubOperation
   */
  operations?: (JsonSchemaHTTPOperation | JsonSchemaPubSubOperation)[];
  ignoreErrorResponses?: boolean;
  queryParams?: any;
  queryStringOptions?: QueryStringOptions;
  /**
   * Timeout for the HTTP request in milliseconds
   */
  timeout?: number;
}
export interface JsonSchemaHTTPOperation {
  /**
   * This Field based on the field name of the URL path.
   * Example: "https://MyAPIURL.com/FieldNameHere/",
   * so we will set the "field: FieldNameHere".
   */
  field: string;
  /**
   * Your chance to describe the operation!
   * Make sure the description is clear and concise.
   */
  description?: string;
  /**
   * Type field is set the opertion type: Query, Mutation or Subscription. (Allowed values: Query, Mutation, Subscription)
   */
  type: 'Query' | 'Mutation' | 'Subscription';
  /**
   * Your chance to provide request schema name.
   */
  requestSchema?: any;
  /**
   * The path definition of the JSON Schema sample.
   * Example: "./jsons/questions.response.json".
   */
  requestSample?: any;
  /**
   * Inset any name for the type of the request body.
   */
  requestTypeName?: string;
  /**
   * This body will be merged with the request body sent with
   * the underlying HTTP request
   */
  requestBaseBody?: any;
  /**
   * Yay! Now you can provide the response schema name.
   */
  responseSchema?: any;
  /**
   * Did you use Sample? Provide the response sample path.
   */
  responseSample?: any;
  /**
   * Inset any name for the type of the response body.
   */
  responseTypeName?: string;
  /**
   * You can define your response schemas by status codes;
   * ```yaml filename=".meshrc.yaml"
   * responseByStatusCode:
   *   200:
   *     responseSchema: ./someschema.json#/somepath
   *   404:
   *     responseSample: ./error-sample.json
   *     responseTypeName: MyError
   * ```
   */
  responseByStatusCode?: any;
  /**
   * Expose response details done to the upstream API
   * When you enable this, you will see a new field in the response type;
   * ```graphql
   * type MyResponseType {
   *   myFooField: String
   *   _response: ResponseMetadata
   * }
   *
   * # And a new type for the response metadata object
   * type ResponseMetadata {
   *   url: URL
   *   status: Int
   *   method: String
   *   headers: JSON
   *   body: String
   * }
   * ```
   */
  exposeResponseMetadata?: boolean;
  /**
   * Mapping the JSON Schema and define the arguments of the operation.
   *
   * # Example:
   * argTypeMap:
   *   user_id:
   *     type: string
   */
  argTypeMap?: {
    [k: string]: any;
  };
  /**
   * JSON object representing the mapping of query search parameters (added to the route path) and the matching argument.
   *
   * # Example:
   * queryParamArgMap:
   *   id: user_id
   */
  queryParamArgMap?: {
    [k: string]: any;
  };
  path: string;
  /**
   * Allowed values: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH
   */
  method?: 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'PATCH';
  headers?: {
    [k: string]: any;
  };
  /**
   * If true, this operation cannot have requestSchema or requestSample
   * And the request body will be passed as binary with its mime type
   * unless you define an explicit Content-Type header
   */
  binary?: boolean;
  /**
   * If true, `@deprecated` will be added to the field definition
   */
  deprecated?: boolean;
}
export interface JsonSchemaPubSubOperation {
  field: string;
  description?: string;
  /**
   * Allowed values: Query, Mutation, Subscription
   */
  type: 'Query' | 'Mutation' | 'Subscription';
  requestSchema?: any;
  requestSample?: any;
  requestTypeName?: string;
  /**
   * This body will be merged with the request body sent with
   * the underlying HTTP request
   */
  requestBaseBody?: any;
  responseSchema?: any;
  responseSample?: any;
  responseTypeName?: string;
  argTypeMap?: {
    [k: string]: any;
  };
  pubsubTopic: string;
  /**
   * If true, `@deprecated` will be added to the field definition
   */
  deprecated?: boolean;
}
export interface QueryStringOptions {
  /**
   * When arrays are stringified, by default they are not given explicit indices:
   * `a=b&a=c&a=d`
   * You may override this by setting the indices option to true:
   * `a[0]=b&a[1]=c&a[2]=d`
   */
  indices?: boolean;
  /**
   * You can configure how to format arrays in the query strings.
   *
   * Note: when using arrayFormat set to 'comma', you can also pass the commaRoundTrip option set to true or false, to append [] on single-item arrays, so that they can round trip through a parse. (Allowed values: indices, brackets, repeat, comma)
   */
  arrayFormat?: 'indices' | 'brackets' | 'repeat' | 'comma';
  /**
   * Even if there is a single item in an array, this option treats them as arrays
   * (default: false)
   */
  commaRoundTrip?: boolean;
  /**
   * Stringify the nested objects as JSON
   * (default: false)
   */
  jsonStringify?: boolean;
}
export interface MongooseHandler {
  connectionString?: string;
  models?: MongooseModel[];
  discriminators?: MongooseModel[];
}
export interface MongooseModel {
  name: string;
  path: string;
  options?: ComposeWithMongooseOpts;
}
export interface ComposeWithMongooseOpts {
  name?: string;
  description?: string;
  fields?: ComposeWithMongooseFieldsOpts;
  inputType?: ComposeMongooseInputType;
  resolvers?: TypeConverterResolversOpts1;
}
export interface ComposeWithMongooseFieldsOpts {
  only?: string[];
  remove?: string[];
  required?: string[];
}
export interface ComposeMongooseInputType {
  name?: string;
  description?: string;
  fields?: ComposeWithMongooseFieldsOpts1;
  resolvers?: TypeConverterResolversOpts;
}
export interface ComposeWithMongooseFieldsOpts1 {
  only?: string[];
  remove?: string[];
  required?: string[];
}
export interface TypeConverterResolversOpts {
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findByIds?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  count?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, JSON
   */
  connection?:
    | boolean
    | {
        [k: string]: any;
      };
  /**
   * Any of: Boolean, PaginationResolverOpts
   */
  pagination?: boolean | PaginationResolverOpts;
}
export interface ComposeWithMongooseResolverOpts {
  filter?: FilterHelperArgsOpts;
  sort?: SortHelperArgsOpts;
  limit?: LimitHelperArgsOpts;
  record?: RecordHelperArgsOpts;
  skip?: boolean;
}
export interface FilterHelperArgsOpts {
  filterTypeName?: string;
  isRequired?: boolean;
  onlyIndexed?: boolean;
  requiredFields?: string[];
  /**
   * Any of: Boolean, JSON
   */
  operators?:
    | boolean
    | {
        [k: string]: any;
      };
  removeFields?: string[];
}
export interface SortHelperArgsOpts {
  sortTypeName?: string;
}
export interface LimitHelperArgsOpts {
  defaultValue?: number;
}
export interface RecordHelperArgsOpts {
  recordTypeName?: string;
  isRequired?: boolean;
  removeFields?: string[];
  requiredFields?: string[];
}
export interface PaginationResolverOpts {
  perPage?: number;
}
export interface TypeConverterResolversOpts1 {
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findByIds?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  count?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, JSON
   */
  connection?:
    | boolean
    | {
        [k: string]: any;
      };
  /**
   * Any of: Boolean, PaginationResolverOpts
   */
  pagination?: boolean | PaginationResolverOpts;
}
export interface MySQLHandler {
  /**
   * The hostname of the database you are connecting to. (Default: localhost)
   */
  host?: string;
  /**
   * The port number to connect to. (Default: 3306)
   */
  port?: number;
  /**
   * The source IP address to use for TCP connection
   */
  localAddress?: string;
  /**
   * The MySQL user to authenticate as
   */
  user?: string;
  /**
   * The password of that MySQL user
   */
  password?: string;
  /**
   * Name of the database to use for this connection
   */
  database?: string;
  ssl?: MySQLSSLOptions;
  /**
   * Use existing `Pool` instance
   * Format: modulePath#exportName
   */
  pool?: any;
  /**
   * Use specific tables for your schema
   */
  tables?: string[];
  /**
   * Use specific fields of specific tables
   */
  tableFields?: TableField[];
}
/**
 * SSL Options for your MySQL connection
 */
export interface MySQLSSLOptions {
  /**
   * Default: true
   */
  rejectUnauthorized?: boolean;
  /**
   * Path to your CA
   */
  ca?: string;
}
export interface TableField {
  table: string;
  fields: string[];
}
/**
 * Handler for Neo4j
 */
export interface Neo4JHandler {
  /**
   * URL for the Neo4j Instance e.g. neo4j://localhost
   */
  endpoint: string;
  /**
   * Provide GraphQL Type Definitions instead of inferring
   */
  source?: string;
  /**
   * Username for basic authentication
   */
  username: string;
  /**
   * Password for basic authentication
   */
  password: string;
  /**
   * Specifies whether relationships should always be included in the type definitions as [relationship](https://grandstack.io/docs/neo4j-graphql-js.html#relationship-types) types, even if the relationships do not have properties.
   */
  alwaysIncludeRelationships?: boolean;
  /**
   * Specifies database name
   */
  database?: string;
}
/**
 * Handler for OData
 */
export interface ODataHandler {
  /**
   * Base URL for OData API
   */
  endpoint: string;
  /**
   * Custom $metadata File or URL
   */
  source?: string;
  /**
   * Headers to be used with the $metadata requests
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Headers to be used with the operation requests
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Enable batching (Allowed values: multipart, json)
   */
  batch?: 'multipart' | 'json';
  /**
   * Use $expand for navigation props instead of seperate HTTP requests (Default: false)
   */
  expandNavProps?: boolean;
}
/**
 * Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it.
 */
export interface OpenapiHandler {
  /**
   * A pointer to your API source (Support both JSON and YAML) - could be a local file, remote file or url endpoint
   */
  source: string;
  /**
   * Format of the files referenced from the source file, for cases content type isn't detected automatically (Allowed values: json, yaml, js, ts)
   */
  fallbackFormat?: 'json' | 'yaml' | 'js' | 'ts';
  /**
   * Specifies the URL on which all paths will be based on.
   * Overrides the server object in the OAS.
   */
  endpoint?: string;
  /**
   * If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema.
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Responses are converted to a Union type grouping all possible responses.
   * Applying this will ignore all responses with status code other than 2xx, resulting in simpler response types, usualy regular object type instead of union.
   * Default: false
   */
  ignoreErrorResponses?: boolean;
  /**
   * Allows to explicitly override the default operation (Query or Mutation) for any OAS operation
   */
  selectQueryOrMutationField?: SelectQueryOrMutationFieldConfig[];
  /**
   * JSON object representing the query search parameters to add to the API calls
   */
  queryParams?: {
    [k: string]: any;
  };
  /**
   * Timeout for the HTTP request in milliseconds
   */
  timeout?: number;
}
/**
 * Handler for Postgres database, based on `postgraphile`
 */
export interface PostGraphileHandler {
  /**
   * A connection string to your Postgres database
   */
  connectionString?: string;
  /**
   * An array of strings which specifies the PostgreSQL schemas that PostGraphile will use to create a GraphQL schema. The default schema is the public schema.
   */
  schemaName?: string[];
  /**
   * Connection Pool instance or settings or you can provide the path of a code file that exports any of those
   */
  pool?: any;
  /**
   * Extra Postgraphile Plugins to append
   */
  appendPlugins?: string[];
  /**
   * Postgraphile Plugins to skip (e.g. "graphile-build#NodePlugin")
   */
  skipPlugins?: string[];
  /**
   * Extra Postgraphile options that will be added to the postgraphile constructor. It can either be an object or a string pointing to the object's path (e.g. "./my-config#options"). See the [postgraphile docs](https://www.graphile.org/postgraphile/usage-library/) for more information. (Any of: JSON, String)
   */
  options?:
    | {
        [k: string]: any;
      }
    | string;
  /**
   * Enable GraphQL websocket transport support for subscriptions (default: true)
   */
  subscriptions?: boolean;
  /**
   * Enables live-query support via GraphQL subscriptions (sends updated payload any time nested collections/records change) (default: true)
   */
  live?: boolean;
  /**
   * A file that exports a function which takes context as a paramter and returns postgraphile context options (e.g. "./my-function#pgSettings"). See the [postgraphile docs](https://www.graphile.org/postgraphile/usage-schema/) for more information.
   */
  contextOptions?: any;
}
export interface RAMLHandler {
  source: string;
  endpoint?: string;
  schemaHeaders?: {
    [k: string]: any;
  };
  operationHeaders?: {
    [k: string]: any;
  };
  ignoreErrorResponses?: boolean;
  selectQueryOrMutationField?: SelectQueryOrMutationFieldConfig[];
  queryParams?: any;
  /**
   * Timeout for the HTTP request in milliseconds
   */
  timeout?: number;
}
/**
 * Handler for SOAP
 */
export interface SoapHandler {
  /**
   * A url to your WSDL or generated SDL with annotations
   */
  source: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for schema introspection
   * You can also provide `.js` or `.ts` file path that exports schemaHeaders as an object
   */
  schemaHeaders?: any;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * The name of the alias to be used in the envelope for body components
   *
   * default: `body`
   */
  bodyAlias?: string;
  soapHeaders?: SOAPHeaders;
  /**
   * The namespace of the SOAP envelope
   * By default, SOAP handler detects the SOAP version and if SOAP version is 1.1,
   * it uses `http://schemas.xmlsoap.org/soap/envelope/` namespace
   * If SOAP version is 1.2, it uses `http://www.w3.org/2003/05/soap-envelope` namespace
   */
  soapNamespace?: string;
}
/**
 * SOAP Headers to be added to the request
 */
export interface SOAPHeaders {
  /**
   * The name of the alias to be used in the envelope
   *
   * default: `header`
   */
  alias?: string;
  /**
   * The namespace of the SOAP Header
   * For example: `http://www.example.com/namespace`
   */
  namespace: string;
  /**
   * The content of the SOAP Header
   * For example: { "key": "value" } then the content will be `<key>value</key>`
   */
  headers: {
    [k: string]: any;
  };
}
export interface SupergraphHandler {
  /**
   * A file path to your Supergraph Schema
   * If you provide a path to a code file(js or ts),
   * other options will be ignored and the schema exported from the file will be used directly.
   */
  source: string;
  schemaHeaders?: any;
  operationHeaders?: any;
  batch?: boolean;
  subgraphs?: SubgraphConfiguration[];
}
export interface SubgraphConfiguration {
  /**
   * The name of the subgraph you want to configure
   */
  name: string;
  /**
   * A url or file path to your remote GraphQL endpoint.
   * If you provide a path to a code file(js or ts),
   * other options will be ignored and the schema exported from the file will be used directly.
   */
  endpoint?: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls only for operation during runtime
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * Use HTTP GET for Query operations
   */
  useGETForQueries?: boolean;
  /**
   * HTTP method used for GraphQL operations (Allowed values: GET, POST)
   */
  method?: 'GET' | 'POST';
  /**
   * Request Credentials if your environment supports it.
   * [See more](https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials)
   *
   * @default "same-origin" (Allowed values: omit, include)
   */
  credentials?: 'omit' | 'include';
  /**
   * Path to a custom W3 Compatible WebSocket Implementation
   */
  webSocketImpl?: string;
  /**
   * Path to the introspection
   * You can separately give schema introspection or SDL
   */
  source?: string;
  /**
   * SSE - Server Sent Events
   * WS - New graphql-ws
   * LEGACY_WS - Legacy subscriptions-transport-ws (Allowed values: SSE, WS, LEGACY_WS)
   */
  subscriptionsProtocol?: 'SSE' | 'WS' | 'LEGACY_WS';
  /**
   * URL to your endpoint serving all subscription queries for this source
   */
  subscriptionsEndpoint?: string;
  /**
   * Retry attempts if fails
   */
  retry?: number;
  /**
   * Timeout in milliseconds
   */
  timeout?: number;
  /**
   * JSON object representing the `connectionParams` from a WebSocket connection to add to the runtime of the API calls only for operation during runtime.
   * More information about the WebSocket `connectionParams`:
   *   - When using `subscriptionsProtocol=WS` (graphql-ws): https://github.com/enisdenjo/graphql-ws/blob/master/docs/interfaces/client.ClientOptions.md#connectionparams
   *   - When using `subscriptionsProtocol=LEGACY_WS` (subscriptions-transport-ws): https://github.com/apollographql/subscriptions-transport-ws/blob/51270cc7dbaf09c7b9aa67368f1de58148c7d334/README.md#subscriptionclient
   */
  connectionParams?: {
    [k: string]: any;
  };
}
/**
 * Handler for OData
 */
export interface ThriftHandler {
  /**
   * The name of the host to connect to.
   */
  hostName: string;
  /**
   * The port number to attach to on the host.
   */
  port: number;
  /**
   * The path on which the Thrift service is listening. Defaults to '/thrift'.
   */
  path?: string;
  /**
   * Boolean value indicating whether to use https. Defaults to false.
   */
  https?: boolean;
  /**
   * Name of the Thrift protocol type to use. Defaults to 'binary'. (Allowed values: binary, compact, json)
   */
  protocol?: 'binary' | 'compact' | 'json';
  /**
   * The name of your service. Used for logging.
   */
  serviceName: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  operationHeaders?: {
    [k: string]: any;
  };
  /**
   * If you are using a remote URL endpoint to fetch your schema, you can set headers for the HTTP request to fetch your schema.
   */
  schemaHeaders?: {
    [k: string]: any;
  };
  /**
   * Path to IDL file
   */
  idl: string;
}
/**
 * Handler for SQLite database, based on `tuql`
 */
export interface TuqlHandler {
  /**
   * Pointer to your SQLite database
   */
  db?: string;
  /**
   * Path to the SQL Dump file if you want to build a in-memory database
   */
  infile?: string;
}
export interface Transform {
  /**
   * Transformer to apply caching for your data sources
   */
  cache?: CacheTransformConfig[];
  encapsulate?: EncapsulateTransformObject;
  extend?: ExtendTransform;
  federation?: FederationTransform;
  /**
   * Transformer to filter (white/black list) GraphQL types, fields and arguments (Any of: FilterSchemaTransform, Any)
   */
  filterSchema?: FilterSchemaTransform | any;
  /**
   * Transformer to hoist GraphQL fields
   */
  hoistField?: HoistFieldTransformConfig[];
  namingConvention?: NamingConventionTransformConfig;
  prefix?: PrefixTransformConfig;
  prune?: PruneTransformConfig;
  /**
   * RateLimit transform
   */
  rateLimit?: RateLimitTransformConfig[];
  /**
   * Transformer to rename GraphQL types and fields (Any of: RenameTransform, Any)
   */
  rename?: RenameTransform | any;
  replaceField?: ReplaceFieldTransformConfig;
  /**
   * Transformer to apply composition to resolvers (Any of: ResolversCompositionTransform, Any)
   */
  resolversComposition?: ResolversCompositionTransform | any;
  transferSchema?: TransferSchemaTransformConfig;
  typeMerging?: TypeMergingConfig;
  [k: string]: any;
}
export interface CacheTransformConfig {
  /**
   * The type and field to apply cache to, you can use wild cards as well, for example: `Query.*`
   */
  field: string;
  /**
   * Cache key to use to store your resolvers responses.
   * The default is: `{typeName}-{fieldName}-{argsHash}-{fieldNamesHash}`
   *
   * Available variables:
   *   - `{args.argName}` - use resolver argument
   *   - `{typeName}` - use name of the type
   *   - `{fieldName}` - use name of the field
   *   - `{argsHash}` - a hash based on the 'args' object
   *   - `{fieldNamesHash}` - a hash based on the field names selected by the client
   *   - `{info}` - the GraphQLResolveInfo of the resolver
   *
   * Available interpolations:
   *   - `{format|date}` - returns the current date with a specific format
   */
  cacheKey?: string;
  invalidate?: CacheInvalidateConfig;
}
/**
 * Invalidation rules
 */
export interface CacheInvalidateConfig {
  /**
   * Invalidate the cache when a specific operation is done without an error
   */
  effectingOperations?: CacheEffectingOperationConfig[];
  /**
   * Specified in seconds, the time-to-live (TTL) value limits the lifespan
   */
  ttl?: number;
}
export interface CacheEffectingOperationConfig {
  /**
   * Path to the operation that could effect it. In a form: Mutation.something. Note that wildcard is not supported in this field.
   */
  operation: string;
  /**
   * Cache key to invalidate on successful resolver (no error), see `cacheKey` for list of available options in this field.
   */
  matchKey?: string;
}
/**
 * Transformer to apply encapsulation to the API source, by creating a field for it under the root query
 */
export interface EncapsulateTransformObject {
  /**
   * Optional, name to use for grouping under the root types. If not specific, the API name is used.
   */
  name?: string;
  applyTo?: EncapsulateTransformApplyTo;
}
/**
 * Allow you to choose which root operations you would like to apply. By default, it's applied to all root types.
 */
export interface EncapsulateTransformApplyTo {
  query?: boolean;
  mutation?: boolean;
  subscription?: boolean;
}
export interface ExtendTransform {
  typeDefs?: any;
  resolvers?: any;
}
export interface FederationTransform {
  types?: FederationTransformType[];
  /**
   * Version of the federation spec
   * Default: v2.0
   */
  version?: string;
}
export interface FederationTransformType {
  name: string;
  config?: FederationObjectConfig;
}
export interface FederationObjectConfig {
  key?: FederationObjectKeyConfig[];
  shareable?: boolean;
  extends?: boolean;
  fields?: FederationField[];
  /**
   * Any of: String, ResolveReferenceObject
   */
  resolveReference?: string | ResolveReferenceObject;
}
export interface FederationObjectKeyConfig {
  fields?: string;
}
export interface FederationField {
  name: string;
  config: FederationFieldConfig;
}
export interface FederationFieldConfig {
  external?: boolean;
  provides?: FederationFieldProvidesConfig;
  requires?: FederationFieldRequiresConfig;
  tag?: FederationFieldTagConfig;
  inaccessible?: boolean;
  override?: FederationFieldOverrideConfig;
}
export interface FederationFieldProvidesConfig {
  fields?: string;
}
export interface FederationFieldRequiresConfig {
  fields?: string;
}
export interface FederationFieldTagConfig {
  name?: string;
}
export interface FederationFieldOverrideConfig {
  from?: string;
}
export interface ResolveReferenceObject {
  /**
   * Name of root field name that resolves the reference
   */
  queryFieldName: string;
  /**
   * You need configure the arguments for that field;
   * ```yaml
   * args:
   *   someArg: "{root.someKeyValue}"
   * ```
   */
  args?: {
    [k: string]: any;
  };
}
export interface FilterSchemaTransform {
  /**
   * Specify to apply filter-schema transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of filter rules
   */
  filters: string[];
  /**
   * Filter deprecated types
   */
  filterDeprecatedTypes?: boolean;
  /**
   * Filter deprecated fields
   */
  filterDeprecatedFields?: boolean;
}
export interface HoistFieldTransformConfig {
  /**
   * Type name that defines where field should be hoisted to
   */
  typeName: string;
  /**
   * Array of fieldsNames to reach the field to be hoisted (Any of: String, HoistFieldTransformFieldPathConfigObject)
   */
  pathConfig: (string | HoistFieldTransformFieldPathConfigObject)[];
  /**
   * Name the hoisted field should have when hoisted to the type specified in typeName
   */
  newFieldName: string;
  alias?: string;
  /**
   * Defines if args in path are filtered (default = false)
   */
  filterArgsInPath?: boolean;
}
export interface HoistFieldTransformFieldPathConfigObject {
  /**
   * Field name
   */
  fieldName: string;
  /**
   * Match fields based on argument, needs to implement `(arg: GraphQLArgument) => boolean`;
   */
  filterArgs: string[];
}
/**
 * Transformer to apply naming convention to GraphQL Types
 */
export interface NamingConventionTransformConfig {
  /**
   * Specify to apply naming-convention transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  typeNames?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  fieldNames?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  enumValues?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
  /**
   * Allowed values: camelCase, capitalCase, constantCase, dotCase, headerCase, noCase, paramCase, pascalCase, pathCase, sentenceCase, snakeCase, upperCase, lowerCase
   */
  fieldArgumentNames?:
    | 'camelCase'
    | 'capitalCase'
    | 'constantCase'
    | 'dotCase'
    | 'headerCase'
    | 'noCase'
    | 'paramCase'
    | 'pascalCase'
    | 'pathCase'
    | 'sentenceCase'
    | 'snakeCase'
    | 'upperCase'
    | 'lowerCase';
}
/**
 * Prefix transform
 */
export interface PrefixTransformConfig {
  /**
   * Specify to apply prefix transform to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * The prefix to apply to the schema types. By default it's the API name.
   */
  value?: string;
  /**
   * List of ignored types
   */
  ignore?: string[];
  /**
   * Changes root types and changes the field names (default: false)
   */
  includeRootOperations?: boolean;
  /**
   * Changes types (default: true)
   */
  includeTypes?: boolean;
}
/**
 * Prune transform
 */
export interface PruneTransformConfig {
  /**
   * Types to skip pruning
   */
  skipPruning?: string[];
  /**
   * Set to `true` to skip pruning object types or interfaces with no fields
   */
  skipEmptyCompositeTypePruning?: boolean;
  /**
   * Set to `true` to skip pruning interfaces that are not implemented by any other types
   */
  skipUnimplementedInterfacesPruning?: boolean;
  /**
   * Set to `true` to skip pruning empty unions
   */
  skipEmptyUnionPruning?: boolean;
  /**
   * Set to `true` to skip pruning unused types
   */
  skipUnusedTypesPruning?: boolean;
}
export interface RateLimitTransformConfig {
  /**
   * The type name that the following field belongs to
   */
  type: string;
  /**
   * The field of the type that the rate limit is applied to
   */
  field: string;
  /**
   * The maximum number of requests that can be made in a given time period
   */
  max: number;
  /**
   * The time period in which the rate limit is applied
   */
  ttl: number;
  /**
   * The identifier expression that determines the identity of the request (e.g. `{context.req.socket.remoteAddress}`)
   */
  identifier: string;
}
export interface RenameTransform {
  /**
   * Specify to apply rename transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of rename rules
   */
  renames: RenameTransformObject[];
}
export interface RenameTransformObject {
  from: RenameConfig;
  to: RenameConfig1;
  /**
   * Use Regular Expression for type names
   */
  useRegExpForTypes?: boolean;
  /**
   * Use Regular Expression for field names
   */
  useRegExpForFields?: boolean;
  /**
   * Use Regular Expression for field names
   */
  useRegExpForArguments?: boolean;
  /**
   * Flags to use in the Regular Expression
   */
  regExpFlags?: string;
  /**
   * Flag to indicate whether certain default types (built-ins, scalars and other types specified an exclusion list) should be renamed or not.
   *
   * @default: false
   */
  includeDefaults?: boolean;
}
export interface RenameConfig {
  type?: string;
  field?: string;
  argument?: string;
}
export interface RenameConfig1 {
  type?: string;
  field?: string;
  argument?: string;
}
/**
 * Transformer to replace GraphQL field with partial of full config from a different field
 */
export interface ReplaceFieldTransformConfig {
  /**
   * Additional type definition to used to replace field types
   */
  typeDefs?: any;
  /**
   * Array of rules to replace fields
   */
  replacements: ReplaceFieldTransformObject[];
}
export interface ReplaceFieldTransformObject {
  from: ReplaceFieldConfig;
  to: ReplaceFieldConfig1;
  /**
   * Allowed values: config, hoistValue
   */
  scope?: 'config' | 'hoistValue';
  composer?: any;
  name?: string;
}
export interface ReplaceFieldConfig {
  type: string;
  field: string;
}
export interface ReplaceFieldConfig1 {
  type: string;
  field: string;
}
export interface ResolversCompositionTransform {
  /**
   * Specify to apply resolvers-composition transforms to bare schema or by wrapping original schema (Allowed values: bare, wrap)
   */
  mode?: 'bare' | 'wrap';
  /**
   * Array of resolver/composer to apply
   */
  compositions: ResolversCompositionTransformObject[];
}
export interface ResolversCompositionTransformObject {
  /**
   * The GraphQL Resolver path
   * Example: Query.users
   */
  resolver: string;
  /**
   * Path to the composer function
   * Example: ./src/auth.js#authComposer
   */
  composer: any;
}
/**
 * Transformer to transfer (move or copy) GraphQL parts of GraphQL schema across Types and Fields
 */
export interface TransferSchemaTransformConfig {
  /**
   * Array of rules to transfer fields or args
   */
  transfers: TransferSchemaTransformObject[];
}
export interface TransferSchemaTransformObject {
  from: string;
  to: string;
  /**
   * Allowed values: move, copy
   */
  action?: 'move' | 'copy';
}
/**
 * [Type Merging](https://www.graphql-tools.com/docs/stitch-type-merging) Configuration
 */
export interface TypeMergingConfig {
  types?: MergedTypeConfig[];
  /**
   * Denotes a root field used to query a merged type across services.
   * The marked field's name is analogous
   * to the fieldName setting in
   * [merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example),
   * while the field's arguments and return type are used to infer merge configuration.
   * Directive arguments tune the merge behavior
   */
  queryFields?: MergedRootFieldConfig[];
  /**
   * The path to a code file that has additional type merging configuration
   */
  additionalConfiguration?: any;
}
export interface MergedTypeConfig {
  /**
   * Name of the type (Query by default)
   */
  typeName?: string;
  key?: KeyAnnotation;
  /**
   * Specifies types and fields
   * that provide a [canonical definition](https://www.graphql-tools.com/docs/stitch-type-merging#canonical-definitions) to be built into the gateway schema. Useful for selecting preferred characteristics among types and fields that overlap across subschemas. Root fields marked as canonical specify which subschema the field proxies for new queries entering the graph.
   */
  canonical?: boolean;
  fields?: MergedTypeField[];
}
/**
 * Specifies a base selection set needed to merge the annotated type across subschemas.
 * Analogous to the `selectionSet` setting specified in [merged type configuration](https://www.graphql-tools.com/docs/stitch-type-merging#basic-example).
 */
export interface KeyAnnotation {
  selectionSet: string;
}
export interface MergedTypeField {
  fieldName: string;
  computed?: ComputedAnnotation;
}
/**
 * specifies a selection of fields required from other services to compute the value of this field.
 * These additional fields are only selected when the computed field is requested.
 * Analogous to [computed field](https://www.graphql-tools.com/docs/stitch-type-merging#computed-fields) in merged type configuration.
 * Computed field dependencies must be sent into the subservice using an [object key](https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys).
 */
export interface ComputedAnnotation {
  selectionSet: string;
}
export interface MergedRootFieldConfig {
  queryFieldName: string;
  /**
   * Specifies the name of a field to pick off origin objects as the key value. When omitted, a `@key` directive must be included on the return type's definition to be built into an object key.
   * https://www.graphql-tools.com/docs/stitch-directives-sdl#object-keys
   */
  keyField?: string;
  /**
   * Specifies which field argument receives the merge key. This may be omitted for fields with only one argument where the recipient can be inferred.
   */
  keyArg?: string;
  /**
   * Specifies a string of additional keys and values to apply to other arguments,
   * formatted as `\"\"\" arg1: "value", arg2: "value" \"\"\"`.
   */
  additionalArgs?: string;
  /**
   * Advanced use only; Allows building a custom key just for the argument from the selectionSet included by the `@key` directive.
   */
  key?: string[];
  /**
   * Advanced use only; This argument specifies a string expression that allows more customization of the input arguments. Rules for evaluation of this argument are as follows:
   *   - basic object parsing of the input key: `"arg1: $key.arg1, arg2: $key.arg2"`
   *   - any expression enclosed by double brackets will be evaluated once for each of the requested keys, and then sent as a list: `"input: { keys: [[$key]] }"`
   *   - selections from the key can be referenced by using the $ sign and dot notation: `"upcs: [[$key.upc]]"`, so that `$key.upc` refers to the `upc` field of the key.
   */
  argsExpr?: string;
}
export interface AdditionalStitchingResolverObject {
  sourceName: string;
  sourceTypeName: string;
  sourceFieldName: string;
  sourceSelectionSet?: string;
  requiredSelectionSet?: string;
  sourceArgs?: {
    [k: string]: any;
  };
  targetTypeName: string;
  targetFieldName: string;
  /**
   * Extract specific property from the result
   */
  result?: string;
  /**
   * If return types don't match,
   * you can specify a result type to apply inline fragment
   */
  resultType?: string;
}
export interface AdditionalStitchingBatchResolverObject {
  sourceName: string;
  sourceTypeName: string;
  sourceFieldName: string;
  sourceSelectionSet?: string;
  requiredSelectionSet?: string;
  keyField: string;
  keysArg: string;
  additionalArgs?: {
    [k: string]: any;
  };
  targetTypeName: string;
  targetFieldName: string;
  /**
   * Extract specific property from the result
   */
  result?: string;
  /**
   * If return types don't match,
   * you can specify a result type to apply inline fragment
   */
  resultType?: string;
}
export interface AdditionalSubscriptionObject {
  targetTypeName: string;
  targetFieldName: string;
  pubsubTopic: string;
  result?: string;
  filterBy?: string;
}
/**
 * Backend cache
 */
export interface Cache {
  cfwKv?: CFWorkersKVCacheConfig;
  file?: FileCacheConfig;
  localforage?: LocalforageConfig;
  /**
   * Any of: RedisConfigSentinel, RedisConfigSingle
   */
  redis?: RedisConfigSentinel | RedisConfigSingle;
  [k: string]: any;
}
export interface CFWorkersKVCacheConfig {
  /**
   * The name of the Workers KV namespace to use for caching.
   *
   * Make sure you have configured the following namespace described in [here](https://developers.cloudflare.com/workers/wrangler/cli-wrangler/commands/#kv).
   */
  namespace: string;
}
export interface FileCacheConfig {
  path?: string;
}
export interface LocalforageConfig {
  /**
   * Allowed values: WEBSQL, INDEXEDDB, LOCALSTORAGE
   */
  driver?: ('WEBSQL' | 'INDEXEDDB' | 'LOCALSTORAGE')[];
  name?: string;
  version?: number;
  size?: number;
  storeName?: string;
  description?: string;
}
export interface RedisConfigSentinel {
  /**
   * identifies a group of Redis instances composed of a master and one or more slaves
   */
  name: string;
  /**
   * (optional) password for Sentinel instances.
   */
  sentinelPassword?: string;
  /**
   * A list of sentinels to connect to. The list does not need to enumerate all your sentinel instances, but a few so that if one is down the client will try the next one.
   */
  sentinels: RedisSentinelConfig[];
  /**
   * (optional) with a value of slave will return a random slave from the Sentinel group. (Allowed values: master, slave)
   */
  role?: 'master' | 'slave';
  /**
   * (optional) set to true if connecting to sentinel instances that are encrypted
   */
  enableTLSForSentinelMode?: boolean;
  /**
   * Flag to indicate lazyConnect value for Redis client.
   *
   * @default: true
   */
  lazyConnect?: boolean;
}
export interface RedisSentinelConfig {
  host: string;
  port: string;
  family?: string;
}
export interface RedisConfigSingle {
  host?: string;
  port?: string;
  username?: string;
  password?: string;
  db?: number;
  url?: string;
  family?: string;
  /**
   * Flag to indicate lazyConnect value for Redis client.
   *
   * @default: true
   */
  lazyConnect?: boolean;
}
export interface PubSubConfig {
  name: string;
  config?: any;
}
/**
 * Configure persisted operations options
 */
export interface PersistedOperationsConfig {
  /**
   * Whether to allow execution of arbitrary GraphQL operations aside from persisted operations.
   */
  allowArbitraryOperations?: boolean;
  /**
   * Whether to skip validation of the persisted operation
   */
  skipDocumentValidation?: boolean;
  customErrors?: CustomPersistedQueryErrors;
}
/**
 * Custom errors to be thrown
 */
export interface CustomPersistedQueryErrors {
  /**
   * Error to be thrown when the persisted operation is not found
   */
  notFound?: string;
  /**
   * Error to be thrown when rejecting non-persisted operations
   */
  persistedQueryOnly?: string;
  /**
   * Error to be thrown when the extraction of the persisted operation id failed
   */
  keyNotFound?: string;
}
export interface Plugin {
  maskedErrors?: MaskedErrorsPluginConfig;
  immediateIntrospection?: any;
  deduplicateRequest?: any;
  hive?: HivePlugin;
  httpCache?: HTTPCachePlugin;
  httpDetailsExtensions?: HTTPDetailsExtensionsConfig;
  liveQuery?: LiveQueryConfig;
  mock?: MockingConfig;
  newrelic?: NewrelicConfig;
  operationFieldPermissions?: OperationFieldPermissionsConfig;
  rateLimit?: RateLimitPluginConfig;
  responseCache?: ResponseCacheConfig;
  snapshot?: SnapshotPluginConfig;
  statsd?: StatsdPlugin;
  prometheus?: PrometheusConfig;
  [k: string]: any;
}
export interface MaskedErrorsPluginConfig {
  errorMessage?: string;
}
export interface HivePlugin {
  /**
   * If this expression is truthy, mocking would be enabled
   * You can use environment variables expression, for example: `process.env.MOCKING_ENABLED != null` (Any of: Boolean, String)
   */
  enabled?: boolean | string;
  /**
   * Access Token for Usage Reporting
   */
  token?: string;
  agent?: HiveAgentOptions;
  usage?: HiveUsageOptions;
  reporting?: HiveReportingOptions;
  selfHosting?: HiveSelfHostingOptions;
  experimental__persistedDocuments?: HivePersistedDocumentsConfiguration;
}
/**
 * Agent Options
 */
export interface HiveAgentOptions {
  name?: string;
  logger?: any;
  /**
   * 30s by default
   */
  timeout?: number;
  /**
   * 5 by default
   */
  maxRetries?: number;
  /**
   * 200 by default
   */
  minTimeout?: number;
  /**
   * Send reports in interval (defaults to 10_000ms)
   */
  sendInterval?: number;
  /**
   * Max number of traces to send at once (defaults to 25)
   */
  maxSize?: number;
}
/**
 * Collects schema usage based on operations
 */
export interface HiveUsageOptions {
  clientInfo?: HiveClientInfo;
  /**
   * Hive uses LRU cache to store info about operations.
   * This option represents the maximum size of the cache.
   * Default: 1000
   */
  max?: number;
  /**
   * Hive uses LRU cache to store info about operations.
   * This option represents the maximum age of an unused operation in the cache.
   * Default: no ttl
   */
  ttl?: number;
  /**
   * A list of operations (by name) to be ignored by Hive.
   */
  exclude?: string[];
  /**
   * Sample rate to determine sampling.
   * 0.0 = 0% chance of being sent
   * 1.0 = 100% chance of being sent
   * Default: 1.0
   */
  sampleRate?: number;
  /**
   * (Experimental) Enables collecting Input fields usage based on the variables passed to the operation.
   * Default: false
   */
  processVariables?: boolean;
  sampler?: any;
}
/**
 * Extract client info from GraphQL Context
 */
export interface HiveClientInfo {
  /**
   * Extract client name
   * Example: `{context.headers['x-client-name']}`
   */
  name?: string;
  /**
   * Extract client version
   * Example: `{context.headers['x-client-version']}`
   */
  version?: string;
}
/**
 * Schema reporting
 */
export interface HiveReportingOptions {
  /**
   * Author of current version of the schema
   */
  author: string;
  /**
   * Commit SHA hash (or any identifier) related to the schema version
   */
  commit: string;
  serviceName?: string;
  serviceUrl?: string;
}
/**
 * Options for self-hosting
 * [See more](https://github.com/kamilkisiela/graphql-hive/tree/main/packages/libraries/client#self-hosting)
 */
export interface HiveSelfHostingOptions {
  /**
   * Point to your own instance of GraphQL Hive API
   *
   * Used by schema reporting and token info.
   */
  graphqlEndpoint: string;
  /**
   * Address of your own GraphQL Hive application
   *
   * Used by token info to generate a link to the organization, project and target.
   */
  applicationUrl: string;
  /**
   * Point to your own instance of GraphQL Hive Usage API
   *
   * Used by usage reporting.
   */
  usageEndpoint?: string;
}
/**
 * Experimental persisted documents configuration
 * [See more](https://the-guild.dev/graphql/hive/docs/features/app-deployments#persisted-documents-on-graphql-server-and-gateway)
 */
export interface HivePersistedDocumentsConfiguration {
  cdn: HivePersistedDocumentsConfigurationCDN;
  /**
   * Whether arbitrary documents should be allowed along-side persisted documents. false by default
   */
  allowArbitraryDocuments?: boolean;
  /**
   * Maximum amount of operations that shall be kept in memory after being loaded from the CDN. 10 seconds by default
   */
  cache?: number;
}
/**
 * Point to your own instance of GraphQL Hive API
 *
 * Used by schema reporting and token info.
 */
export interface HivePersistedDocumentsConfigurationCDN {
  /**
   * CDN endpoint
   */
  endpoint: string;
  /**
   * Access Token for Persisted Documents CDN
   */
  accessToken: string;
}
export interface HTTPCachePlugin {
  /**
   * If the following patterns match the request URL, the response will be cached. (Any of: String, URLPatternObj)
   */
  matches?: (string | URLPatternObj)[];
  /**
   * If the following patterns match the request URL, the response will not be cached. (Any of: String, URLPatternObj)
   */
  ignores?: (string | URLPatternObj)[];
}
export interface URLPatternObj {
  protocol?: string;
  username?: string;
  password?: string;
  hostname?: string;
  port?: string;
  pathname?: string;
  search?: string;
  hash?: string;
  baseURL?: string;
}
export interface HTTPDetailsExtensionsConfig {
  if?: any;
}
export interface LiveQueryConfig {
  /**
   * Invalidate a query or queries when a specific operation is done without an error
   */
  invalidations?: LiveQueryInvalidation[];
  /**
   * Custom strategy for building resources identifiers
   * By default resource identifiers are built by concatenating the Typename with the id separated by a color (`User:1`).
   *
   * This may be useful if you are using a relay compliant schema and the Typename information is not required for building a unique topic.
   *
   * Default: "{typename}:{id}"
   */
  resourceIdentifier?: string;
  /**
   * Whether the extensions should include a list of all resource identifiers for the latest operation result.
   * Any of those can be used for invalidating and re-scheduling the operation execution.
   *
   * This is mainly useful for discovering and learning what kind of topics a given query will subscribe to.
   * The default value is `true` if `DEBUG` environment variable is set
   */
  includeIdentifierExtension?: boolean;
  /**
   * Identifier unique field
   *
   * Default: "id"
   */
  idFieldName?: string;
  /**
   * Specify which fields should be indexed for specific invalidations.
   */
  indexBy?: LiveQueryIndexBy[];
}
export interface LiveQueryInvalidation {
  /**
   * Path to the operation that could effect it. In a form: Mutation.something. Note that wildcard is not supported in this field.
   */
  field: string;
  invalidate: string[];
}
export interface LiveQueryIndexBy {
  field: string;
  args: string[];
}
/**
 * Mock configuration for your source
 */
export interface MockingConfig {
  /**
   * If this expression is truthy, mocking would be enabled
   * You can use environment variables expression, for example: `process.env.MOCKING_ENABLED != null`
   */
  if?: boolean;
  /**
   * Do not mock any other resolvers other than defined in `mocks`.
   * For example, you can enable this if you don't want to mock entire schema but partially.
   */
  preserveResolvers?: boolean;
  /**
   * Mock configurations
   */
  mocks?: MockingFieldConfig[];
  /**
   * The path to the code runs before the store is attached to the schema
   */
  initializeStore?: any;
}
export interface MockingFieldConfig {
  /**
   * Resolver path
   * Example: User.firstName
   */
  apply: string;
  /**
   * If this expression is truthy, mocking would be enabled
   * You can use environment variables expression, for example: `${MOCKING_ENABLED}`
   */
  if?: boolean;
  /**
   * Faker.js expression or function
   * Read more (https://github.com/marak/Faker.js/#fakerfake)
   * Example:
   * faker: `name.firstName`
   * faker: `{{ name.firstName }} {{ name.lastName }}`
   */
  faker?: string;
  /**
   * Custom mocking
   * It can be a module or json file.
   * Both "moduleName#exportName" or only "moduleName" would work
   */
  custom?: string;
  /**
   * Length of the mock list
   * For the list types `[ObjectType]`, how many `ObjectType` you want to return?
   * default: 2
   */
  length?: number;
  store?: GetFromMockStoreConfig;
  /**
   * Update the data on the mock store
   */
  updateStore?: UpdateMockStoreConfig[];
}
/**
 * Get the data from the mock store
 */
export interface GetFromMockStoreConfig {
  type?: string;
  key?: string;
  fieldName?: string;
}
export interface UpdateMockStoreConfig {
  type?: string;
  key?: string;
  fieldName?: string;
  value?: string;
}
export interface NewrelicConfig {
  /**
   * default `false`. When set to `true`, includes the GraphQL document defining the operations and fragments
   */
  includeOperationDocument?: boolean;
  /**
   * default `false`. When set to `true`, includes all the operation variables with their values
   */
  includeExecuteVariables?: boolean;
  /**
   * default: `false`. When set to `true`, includes the execution result of both delegation and execution
   */
  includeRawResult?: boolean;
  /**
   * default `false`. When set to `true`, track resolvers as segments to monitor their performance
   */
  trackResolvers?: boolean;
  /**
   * default `false`. When set to `true`, includes all the arguments passed to resolvers and delegation with their values
   */
  includeResolverArgs?: boolean;
  /**
   * default `false`. When set to `true` append the names of operation root fields to the transaction name
   */
  rootFieldsNaming?: boolean;
  /**
   * Allows to set a custom operation name to be used as transaction name and attribute
   * `extractOperationName: {context.headers['x-operation-name']}`
   */
  extractOperationName?: string;
}
export interface OperationFieldPermissionsConfig {
  permissions?: OperationFieldPermission[];
}
export interface OperationFieldPermission {
  if?: string;
  allow?: string[];
}
/**
 * RateLimit plugin
 */
export interface RateLimitPluginConfig {
  config: RateLimitTransformConfig[];
}
export interface ResponseCacheConfig {
  /**
   * Maximum age in ms. Defaults to `Infinity`. Set it to 0 for disabling the global TTL.
   */
  ttl?: number;
  /**
   * Overwrite the ttl for query operations whose selection contains a specific schema coordinate (e.g. Query.users).
   * Useful if the selection of a specific field should reduce the TTL of the query operation.
   */
  ttlPerCoordinate?: ResponseCacheTTLConfig[];
  /**
   * Skip caching of following the types.
   */
  ignoredTypes?: string[];
  /**
   * List of fields that are used to identify the entity.
   */
  idFields?: string[];
  /**
   * Whether the mutation execution result should be used for invalidating resources.
   * Defaults to `true`
   */
  invalidateViaMutation?: boolean;
  /**
   * Include extension values that provide useful information, such as whether the cache was hit or which resources a mutation invalidated.
   */
  includeExtensionMetadata?: boolean;
  /**
   * Allows to cache responses based on the resolved session id.
   * Return a unique value for each session.
   * Creates a global session by default.
   * Example;
   * ```yaml
   * sessionId: "{context.headers.userId}"
   * ```
   */
  sessionId?: string;
  /**
   * Specify whether the cache should be used based on the context.
   * ```yaml
   * if: "context.headers.userId != null"
   * ```
   */
  if?: string;
  /**
   * Customize the behavior how the response cache key is computed from the documentString, variableValues, contextValue and sessionId.
   * If the given string is interpolated as empty, default behavior is used.
   * Example;
   * ```yaml
   * # Cache by specific value
   * cacheKey: "{variableValues.userId}"
   *
   * # Cache by documentString
   * cacheKey: "{documentString}"
   *
   * # Cache by operationName
   * cacheKey: "{operationName}"
   *
   * # Cache by some header value
   * cacheKey: "{contextValue.headers.authorization}"
   *
   * # Or combine two of each
   * cacheKey: "{contextValue.headers.authorization}-{operationName}"
   * ```
   */
  cacheKey?: string;
  /**
   * Checks if the result should be cached.
   * ```yaml
   * shouldCacheResult: "result.errors.length > 0"
   * ```
   */
  shouldCacheResult?: string;
}
export interface ResponseCacheTTLConfig {
  coordinate: string;
  ttl: number;
}
/**
 * Configuration for Snapshot extension
 */
export interface SnapshotPluginConfig {
  /**
   * Expression for when to activate this extension.
   * Value can be a valid JS expression string or a boolean (Any of: String, Boolean)
   */
  if?: string | boolean;
  /**
   * HTTP URL pattern to be applied
   * For example;
   *   apply:
   *       - http://my-remote-api.com/* \<- * will apply this extension to all paths of remote API
   */
  apply: string[];
  /**
   * Path to the directory of the generated snapshot files
   */
  outputDir: string;
}
export interface StatsdPlugin {
  /**
   * If you wish to disable introspection for logging (default: false)
   */
  skipIntrospection?: boolean;
  /**
   * prefix.operations.count (default: graphql)
   */
  prefix?: string;
  client?: StatsdClientConfiguration;
}
/**
 * Client Configuration
 */
export interface StatsdClientConfiguration {
  bufferFlushInterval?: number;
  bufferHolder?: StatsdClientBufferHolder;
  cacheDns?: boolean;
  cacheDnsTtl?: number;
  globalTags?: {
    [k: string]: any;
  };
  globalize?: boolean;
  host?: string;
  isChild?: boolean;
  maxBufferSize?: number;
  mock?: boolean;
  path?: string;
  port?: number;
  /**
   * Allowed values: tcp, udp, uds, stream
   */
  protocol?: 'tcp' | 'udp' | 'uds' | 'stream';
  sampleRate?: number;
  suffix?: string;
  telegraf?: boolean;
  useDefaultRoute?: boolean;
  tagPrefix?: string;
  tagSeperator?: string;
  tcpGracefulErrorHandling?: boolean;
  tcpGracefulRestartRateLimit?: number;
  udsGracefulErrorHandling?: boolean;
  udsGracefulRestartRateLimit?: number;
  closingFlushInterval?: number;
}
export interface StatsdClientBufferHolder {
  buffer: string;
}
export interface PrometheusConfig {
  /**
   * Any of: Boolean, String
   */
  requestCount?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  requestTotalDuration?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  requestSummary?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  parse?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  validate?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  contextBuilding?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  execute?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  errors?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  deprecatedFields?: boolean | string;
  skipIntrospection?: boolean;
  registry?: string;
  /**
   * Any of: Boolean, String
   */
  delegation?: boolean | string;
  delegationArgs?: boolean;
  delegationKey?: boolean;
  /**
   * Any of: Boolean, String
   */
  subgraphExecute?: boolean | string;
  /**
   * Any of: Boolean, String
   */
  fetchMetrics?: boolean | string;
  fetchRequestHeaders?: boolean;
  fetchResponseHeaders?: boolean;
  /**
   * Any of: Boolean, String
   */
  http?: boolean | string;
  httpRequestHeaders?: boolean;
  httpResponseHeaders?: boolean;
  /**
   * The path to the metrics endpoint
   * default: `/metrics` (Any of: Boolean, String)
   */
  endpoint?: boolean | string;
}
